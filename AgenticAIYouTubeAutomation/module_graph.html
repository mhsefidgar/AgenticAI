<html>
    <head>
        <meta charset="utf-8">
        
            <script src="lib/bindings/utils.js"></script>
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css" integrity="sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
            <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js" integrity="sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
            
        
<center>
<h1></h1>
</center>

<!-- <link rel="stylesheet" href="../node_modules/vis/dist/vis.min.css" type="text/css" />
<script type="text/javascript" src="../node_modules/vis/dist/vis.js"> </script>-->
        <link
          href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css"
          rel="stylesheet"
          integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6"
          crossorigin="anonymous"
        />
        <script
          src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js"
          integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf"
          crossorigin="anonymous"
        ></script>


        <center>
          <h1></h1>
        </center>
        <style type="text/css">

             #mynetwork {
                 width: 100%;
                 height: 850px;
                 background-color: #1a1a1a;
                 border: 1px solid lightgray;
                 position: relative;
                 float: left;
             }

             
             #loadingBar {
                 position:absolute;
                 top:0px;
                 left:0px;
                 width: 100%;
                 height: 850px;
                 background-color:rgba(200,200,200,0.8);
                 -webkit-transition: all 0.5s ease;
                 -moz-transition: all 0.5s ease;
                 -ms-transition: all 0.5s ease;
                 -o-transition: all 0.5s ease;
                 transition: all 0.5s ease;
                 opacity:1;
             }

             #bar {
                 position:absolute;
                 top:0px;
                 left:0px;
                 width:20px;
                 height:20px;
                 margin:auto auto auto auto;
                 border-radius:11px;
                 border:2px solid rgba(30,30,30,0.05);
                 background: rgb(0, 173, 246); /* Old browsers */
                 box-shadow: 2px 0px 4px rgba(0,0,0,0.4);
             }

             #border {
                 position:absolute;
                 top:10px;
                 left:10px;
                 width:500px;
                 height:23px;
                 margin:auto auto auto auto;
                 box-shadow: 0px 0px 4px rgba(0,0,0,0.2);
                 border-radius:10px;
             }

             #text {
                 position:absolute;
                 top:8px;
                 left:530px;
                 width:30px;
                 height:50px;
                 margin:auto auto auto auto;
                 font-size:22px;
                 color: #000000;
             }

             div.outerBorder {
                 position:relative;
                 top:400px;
                 width:600px;
                 height:44px;
                 margin:auto auto auto auto;
                 border:8px solid rgba(0,0,0,0.1);
                 background: rgb(252,252,252); /* Old browsers */
                 background: -moz-linear-gradient(top,  rgba(252,252,252,1) 0%, rgba(237,237,237,1) 100%); /* FF3.6+ */
                 background: -webkit-gradient(linear, left top, left bottom, color-stop(0%,rgba(252,252,252,1)), color-stop(100%,rgba(237,237,237,1))); /* Chrome,Safari4+ */
                 background: -webkit-linear-gradient(top,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* Chrome10+,Safari5.1+ */
                 background: -o-linear-gradient(top,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* Opera 11.10+ */
                 background: -ms-linear-gradient(top,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* IE10+ */
                 background: linear-gradient(to bottom,  rgba(252,252,252,1) 0%,rgba(237,237,237,1) 100%); /* W3C */
                 filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#fcfcfc', endColorstr='#ededed',GradientType=0 ); /* IE6-9 */
                 border-radius:72px;
                 box-shadow: 0px 0px 10px rgba(0,0,0,0.2);
             }
             

             

             
        </style>
    </head>


    <body>
        <div class="card" style="width: 100%">
            
            
            <div id="mynetwork" class="card-body"></div>
        </div>

        
            <div id="loadingBar">
              <div class="outerBorder">
                <div id="text">0%</div>
                <div id="border">
                  <div id="bar"></div>
                </div>
              </div>
            </div>
        
        

        <script type="text/javascript">

              // initialize global variables.
              var edges;
              var nodes;
              var allNodes;
              var allEdges;
              var nodeColors;
              var originalNodes;
              var network;
              var container;
              var options, data;
              var filter = {
                  item : '',
                  property : '',
                  value : []
              };

              

              

              // This method is responsible for drawing the graph, returns the drawn network
              function drawGraph() {
                  var container = document.getElementById('mynetwork');

                  

                  // parsing and collecting nodes and edges from the python
                  nodes = new vis.DataSet([{"color": "#ff4d4d", "font": {"color": "white"}, "id": "pandas", "label": "pandas", "shape": "dot", "size": 35, "title": "ROOT: pandas"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.ArrowDtype", "label": "ArrowDtype", "shape": "dot", "size": 20, "title": "NAME: ArrowDtype\n------------------------------\nINPUTS: pyarrow_dtype\nOUTPUTS: None\n------------------------------\nDESCRIPTION: An ExtensionDtype for PyArrow data types. .. warning:: ArrowDtype is considered experimental. The implementation and parts of the API may change without warning. While most ``dtype`` arguments can accept the \"string\" constructor, e.g. ``\"int64[pyarrow]\"``, ArrowDtype is useful if the data...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import pyarrow as pa\n\u003e\u003e\u003e pd.ArrowDtype(pa.int64())\nint64[pyarrow]"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.BooleanDtype", "label": "BooleanDtype", "shape": "dot", "size": 20, "title": "NAME: BooleanDtype\n------------------------------\nINPUTS: \nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Extension dtype for boolean data. .. warning:: BooleanDtype is considered experimental. The implementation and parts of the API may change without warning. Attributes ---------- None Methods ------- None Examples -------- \u003e\u003e\u003e pd.BooleanDtype() BooleanDtype...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.BooleanDtype()\nBooleanDtype"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Categorical", "label": "Categorical", "shape": "dot", "size": 20, "title": "NAME: Categorical\n------------------------------\nINPUTS: values, categories, ordered, dtype, fastpath, copy\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Represent a categorical variable in classic R / S-plus fashion. `Categoricals` can only take on a limited, and usually fixed, number of possible values (`categories`). In contrast to statistical categorical variables, a `Categorical` might have an order, but numerical operations...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Categorical([1, 2, 3, 1, 2, 3])\n[1, 2, 3, 1, 2, 3]\nCategories (3, int64): [1, 2, 3]"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.CategoricalDtype", "label": "CategoricalDtype", "shape": "dot", "size": 20, "title": "NAME: CategoricalDtype\n------------------------------\nINPUTS: categories, ordered\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Type for categorical data with the categories and orderedness. Parameters ---------- categories : sequence, optional Must be unique, and must not contain any nulls. The categories are stored in an Index, and if an index is provided the dtype of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e t = pd.CategoricalDtype(categories=[\u0027b\u0027, \u0027a\u0027], ordered=True)\n\u003e\u003e\u003e pd.Series([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027, \u0027c\u0027], dtype=t)\n0      a\n1      b\n2      a\n3    NaN\ndtype: category\nCategories (2, object): [\u0027b\u0027 \u003c \u0027a\u0027]"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.CategoricalIndex", "label": "CategoricalIndex", "shape": "dot", "size": 20, "title": "NAME: CategoricalIndex\n------------------------------\nINPUTS: data, categories, ordered, dtype, copy, name\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Index based on an underlying :class:`Categorical`. CategoricalIndex, like Categorical, can only take on a limited, and usually fixed, number of possible values (`categories`). Also, like Categorical, it might have an order, but numerical operations (additions, divisions, ...) are not possible....\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.CategoricalIndex([\"a\", \"b\", \"c\", \"a\", \"b\", \"c\"])\nCategoricalIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027a\u0027, \u0027b\u0027, \u0027c\u0027],\n                 categories=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], ordered=False, dtype=\u0027category\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.DataFrame", "label": "DataFrame", "shape": "dot", "size": 20, "title": "NAME: DataFrame\n------------------------------\nINPUTS: data, index, columns, dtype, copy\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Two-dimensional, size-mutable, potentially heterogeneous tabular data. Data structure also contains labeled axes (rows and columns). Arithmetic operations align on both row and column labels. Can be thought of as a dict-like container for Series objects. The primary pandas data structure....\n\n\nEXAMPLE:\n\u003e\u003e\u003e d = {\u0027col1\u0027: [1, 2], \u0027col2\u0027: [3, 4]}\n\u003e\u003e\u003e df = pd.DataFrame(data=d)\n\u003e\u003e\u003e df\n   col1  col2\n0     1     3\n1     2     4"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.DateOffset", "label": "DateOffset", "shape": "dot", "size": 20, "title": "NAME: DateOffset\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Standard kind of date increment used for a date range. Works exactly like the keyword argument form of relativedelta. Note that the positional argument form of relativedelata is not supported. Use of the keyword n is discouraged-- you would be...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas.tseries.offsets import DateOffset\n\u003e\u003e\u003e ts = pd.Timestamp(\u00272017-01-01 09:10:11\u0027)\n\u003e\u003e\u003e ts + DateOffset(months=3)\nTimestamp(\u00272017-04-01 09:10:11\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.DatetimeIndex", "label": "DatetimeIndex", "shape": "dot", "size": 20, "title": "NAME: DatetimeIndex\n------------------------------\nINPUTS: data, freq, tz, normalize, closed, ambiguous, dayfirst, yearfirst, dtype, copy, name\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Immutable ndarray-like of datetime64 data. Represented internally as int64, and which can be boxed to Timestamp objects that are subclasses of datetime and carry metadata. .. versionchanged:: 2.0.0 The various numeric date/time attributes (:attr:`~DatetimeIndex.day`, :attr:`~DatetimeIndex.month`, :attr:`~DatetimeIndex.year` etc.) now have dtype...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.DatetimeIndex([\"1/1/2020 10:00:00+00:00\", \"2/1/2020 11:00:00+00:00\"])\n\u003e\u003e\u003e idx\nDatetimeIndex([\u00272020-01-01 10:00:00+00:00\u0027, \u00272020-02-01 11:00:00+00:00\u0027],\ndtype=\u0027datetime64[ns, UTC]\u0027, freq=None)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.DatetimeTZDtype", "label": "DatetimeTZDtype", "shape": "dot", "size": 20, "title": "NAME: DatetimeTZDtype\n------------------------------\nINPUTS: unit, tz\nOUTPUTS: None\n------------------------------\nDESCRIPTION: An ExtensionDtype for timezone-aware datetime data. **This is not an actual numpy dtype**, but a duck type. Parameters ---------- unit : str, default \"ns\" The precision of the datetime data. Currently limited to ``\"ns\"``. tz : str, int, or datetime.tzinfo...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from zoneinfo import ZoneInfo\n\u003e\u003e\u003e pd.DatetimeTZDtype(tz=ZoneInfo(\u0027UTC\u0027))\ndatetime64[ns, UTC]"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.ExcelFile", "label": "ExcelFile", "shape": "dot", "size": 20, "title": "NAME: ExcelFile\n------------------------------\nINPUTS: path_or_buffer, engine, storage_options, engine_kwargs\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Class for parsing tabular Excel sheets into DataFrame objects. See read_excel for more documentation. Parameters ---------- path_or_buffer : str, bytes, path object (pathlib.Path or py._path.local.LocalPath), A file-like object, xlrd workbook or openpyxl workbook. If a string or path object, expected...\n\n\nEXAMPLE:\n\u003e\u003e\u003e file = pd.ExcelFile(\u0027myfile.xlsx\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e with pd.ExcelFile(\"myfile.xls\") as xls:  # doctest: +SKIP\n...     df1 = pd.read_excel(xls, \"Sheet1\")  # doctest: +SKIP"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.ExcelWriter", "label": "ExcelWriter", "shape": "dot", "size": 20, "title": "NAME: ExcelWriter\n------------------------------\nINPUTS: path, engine, date_format, datetime_format, mode, storage_options, if_sheet_exists, engine_kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Class for writing DataFrame objects into excel sheets. Default is to use: * `xlsxwriter \u003chttps://pypi.org/project/XlsxWriter/\u003e`__ for xlsx files if xlsxwriter is installed otherwise `openpyxl \u003chttps://pypi.org/project/openpyxl/\u003e`__ * `odswriter \u003chttps://pypi.org/project/odswriter/\u003e`__ for ods files See ``DataFrame.to_excel`` for typical usage. The writer should be...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[\"ABC\", \"XYZ\"]], columns=[\"Foo\", \"Bar\"])  # doctest: +SKIP\n\u003e\u003e\u003e with pd.ExcelWriter(\"path_to_file.xlsx\") as writer:\n...     df.to_excel(writer)  # doctest: +SKIP"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Flags", "label": "Flags", "shape": "dot", "size": 20, "title": "NAME: Flags\n------------------------------\nINPUTS: obj, allows_duplicate_labels\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Flags that apply to pandas objects. Parameters ---------- obj : Series or DataFrame The object these flags are associated with. allows_duplicate_labels : bool, default True Whether to allow duplicate labels in this object. By default, duplicate labels are permitted. Setting...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame()\n\u003e\u003e\u003e df.flags\n\u003cFlags(allows_duplicate_labels=True)\u003e\n\u003e\u003e\u003e df.flags.allows_duplicate_labels = False\n\u003e\u003e\u003e df.flags\n\u003cFlags(allows_duplicate_labels=False)\u003e"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Float32Dtype", "label": "Float32Dtype", "shape": "dot", "size": 20, "title": "NAME: Float32Dtype\n------------------------------\nINPUTS: \nOUTPUTS: Any\n------------------------------\nDESCRIPTION: An ExtensionDtype for float32 data. This dtype uses ``pd.NA`` as missing value indicator. Attributes ---------- None Methods ------- None Examples -------- For Float32Dtype: \u003e\u003e\u003e ser = pd.Series([2.25, pd.NA], dtype=pd.Float32Dtype()) \u003e\u003e\u003e ser.dtype Float32Dtype() For Float64Dtype: \u003e\u003e\u003e ser = pd.Series([2.25, pd.NA], dtype=pd.Float64Dtype())...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([2.25, pd.NA], dtype=pd.Float32Dtype())\n\u003e\u003e\u003e ser.dtype\nFloat32Dtype()"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Float64Dtype", "label": "Float64Dtype", "shape": "dot", "size": 20, "title": "NAME: Float64Dtype\n------------------------------\nINPUTS: \nOUTPUTS: Any\n------------------------------\nDESCRIPTION: An ExtensionDtype for float64 data. This dtype uses ``pd.NA`` as missing value indicator. Attributes ---------- None Methods ------- None Examples -------- For Float32Dtype: \u003e\u003e\u003e ser = pd.Series([2.25, pd.NA], dtype=pd.Float32Dtype()) \u003e\u003e\u003e ser.dtype Float32Dtype() For Float64Dtype: \u003e\u003e\u003e ser = pd.Series([2.25, pd.NA], dtype=pd.Float64Dtype())...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([2.25, pd.NA], dtype=pd.Float32Dtype())\n\u003e\u003e\u003e ser.dtype\nFloat32Dtype()"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Grouper", "label": "Grouper", "shape": "dot", "size": 20, "title": "NAME: Grouper\n------------------------------\nINPUTS: args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: A Grouper allows the user to specify a groupby instruction for an object. This specification will select a column via the key parameter, or if the level and/or axis parameters are given, a level of the index of the target...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(\n...     {\n...         \"Animal\": [\"Falcon\", \"Parrot\", \"Falcon\", \"Falcon\", \"Parrot\"],\n...         \"Speed\": [100, 5, 200, 300, 15],\n...     }\n... )\n\u003e\u003e\u003e df\n   Animal  Speed\n0  Falcon    100\n1  Parrot      5\n2  Falcon    200\n3  Falcon    300\n4  Parrot     15\n\u003e\u003e\u003e df.groupby(pd.Grouper(key=\"Animal\")).mean()\n        Speed\nAnimal\nFalcon  200.0\nParrot   10.0"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.HDFStore", "label": "HDFStore", "shape": "dot", "size": 20, "title": "NAME: HDFStore\n------------------------------\nINPUTS: path, mode, complevel, complib, fletcher32, kwargs\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Dict-like IO interface for storing pandas objects in PyTables. Either Fixed or Table format. .. warning:: Pandas uses PyTables for reading and writing HDF5 files, which allows serializing object-dtype data with pickle when using the \"fixed\" format. Loading pickled data...\n\n\nEXAMPLE:\n\u003e\u003e\u003e bar = pd.DataFrame(np.random.randn(10, 4))\n\u003e\u003e\u003e store = pd.HDFStore(\u0027test.h5\u0027)\n\u003e\u003e\u003e store[\u0027foo\u0027] = bar   # write to HDF5\n\u003e\u003e\u003e bar = store[\u0027foo\u0027]   # retrieve\n\u003e\u003e\u003e store.close()"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Index", "label": "Index", "shape": "dot", "size": 20, "title": "NAME: Index\n------------------------------\nINPUTS: data, dtype, copy, name, tupleize_cols\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Immutable sequence used for indexing and alignment. The basic object storing axis labels for all pandas objects. .. versionchanged:: 2.0.0 Index can hold all numpy numeric dtypes (except float16). Previously only int64/uint64/float64 dtypes were accepted. Parameters ---------- data : array-like...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Index([1, 2, 3])\nIndex([1, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Int16Dtype", "label": "Int16Dtype", "shape": "dot", "size": 20, "title": "NAME: Int16Dtype\n------------------------------\nINPUTS: \nOUTPUTS: Any\n------------------------------\nDESCRIPTION: An ExtensionDtype for int16 integer data. Uses :attr:`pandas.NA` as its missing value, rather than :attr:`numpy.nan`. Attributes ---------- None Methods ------- None Examples -------- For Int8Dtype: \u003e\u003e\u003e ser = pd.Series([2, pd.NA], dtype=pd.Int8Dtype()) \u003e\u003e\u003e ser.dtype Int8Dtype() For Int16Dtype: \u003e\u003e\u003e ser = pd.Series([2,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([2, pd.NA], dtype=pd.Int8Dtype())\n\u003e\u003e\u003e ser.dtype\nInt8Dtype()"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Int32Dtype", "label": "Int32Dtype", "shape": "dot", "size": 20, "title": "NAME: Int32Dtype\n------------------------------\nINPUTS: \nOUTPUTS: Any\n------------------------------\nDESCRIPTION: An ExtensionDtype for int32 integer data. Uses :attr:`pandas.NA` as its missing value, rather than :attr:`numpy.nan`. Attributes ---------- None Methods ------- None Examples -------- For Int8Dtype: \u003e\u003e\u003e ser = pd.Series([2, pd.NA], dtype=pd.Int8Dtype()) \u003e\u003e\u003e ser.dtype Int8Dtype() For Int16Dtype: \u003e\u003e\u003e ser = pd.Series([2,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([2, pd.NA], dtype=pd.Int8Dtype())\n\u003e\u003e\u003e ser.dtype\nInt8Dtype()"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Int64Dtype", "label": "Int64Dtype", "shape": "dot", "size": 20, "title": "NAME: Int64Dtype\n------------------------------\nINPUTS: \nOUTPUTS: Any\n------------------------------\nDESCRIPTION: An ExtensionDtype for int64 integer data. Uses :attr:`pandas.NA` as its missing value, rather than :attr:`numpy.nan`. Attributes ---------- None Methods ------- None Examples -------- For Int8Dtype: \u003e\u003e\u003e ser = pd.Series([2, pd.NA], dtype=pd.Int8Dtype()) \u003e\u003e\u003e ser.dtype Int8Dtype() For Int16Dtype: \u003e\u003e\u003e ser = pd.Series([2,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([2, pd.NA], dtype=pd.Int8Dtype())\n\u003e\u003e\u003e ser.dtype\nInt8Dtype()"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Int8Dtype", "label": "Int8Dtype", "shape": "dot", "size": 20, "title": "NAME: Int8Dtype\n------------------------------\nINPUTS: \nOUTPUTS: Any\n------------------------------\nDESCRIPTION: An ExtensionDtype for int8 integer data. Uses :attr:`pandas.NA` as its missing value, rather than :attr:`numpy.nan`. Attributes ---------- None Methods ------- None Examples -------- For Int8Dtype: \u003e\u003e\u003e ser = pd.Series([2, pd.NA], dtype=pd.Int8Dtype()) \u003e\u003e\u003e ser.dtype Int8Dtype() For Int16Dtype: \u003e\u003e\u003e ser = pd.Series([2,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([2, pd.NA], dtype=pd.Int8Dtype())\n\u003e\u003e\u003e ser.dtype\nInt8Dtype()"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Interval", "label": "Interval", "shape": "dot", "size": 20, "title": "NAME: Interval\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Immutable object implementing an Interval, a bounded slice-like interval. Parameters ---------- left : orderable scalar Left bound for the interval. right : orderable scalar Right bound for the interval. closed : {\u0027right\u0027, \u0027left\u0027, \u0027both\u0027, \u0027neither\u0027}, default \u0027right\u0027 Whether the interval...\n\n\nEXAMPLE:\n\u003e\u003e\u003e iv = pd.Interval(left=0, right=5)\n\u003e\u003e\u003e iv\nInterval(0, 5, closed=\u0027right\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.IntervalDtype", "label": "IntervalDtype", "shape": "dot", "size": 20, "title": "NAME: IntervalDtype\n------------------------------\nINPUTS: subtype, closed\nOUTPUTS: None\n------------------------------\nDESCRIPTION: An ExtensionDtype for Interval data. **This is not an actual numpy dtype**, but a duck type. Parameters ---------- subtype : str, np.dtype The dtype of the Interval bounds. Attributes ---------- subtype Methods ------- None Examples -------- \u003e\u003e\u003e pd.IntervalDtype(subtype=\u0027int64\u0027, closed=\u0027both\u0027) interval[int64,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.IntervalDtype(subtype=\u0027int64\u0027, closed=\u0027both\u0027)\ninterval[int64, both]"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.IntervalIndex", "label": "IntervalIndex", "shape": "dot", "size": 20, "title": "NAME: IntervalIndex\n------------------------------\nINPUTS: data, closed, dtype, copy, name, verify_integrity\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Immutable index of intervals that are closed on the same side. Parameters ---------- data : array-like (1-dimensional) Array-like (ndarray, :class:`DateTimeArray`, :class:`TimeDeltaArray`) containing Interval objects from which to build the IntervalIndex. closed : {\u0027left\u0027, \u0027right\u0027, \u0027both\u0027, \u0027neither\u0027}, default \u0027right\u0027 Whether the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.interval_range(start=0, end=5)\nIntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\n              dtype=\u0027interval[int64, right]\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.MultiIndex", "label": "MultiIndex", "shape": "dot", "size": 20, "title": "NAME: MultiIndex\n------------------------------\nINPUTS: levels, codes, sortorder, names, dtype, copy, name, verify_integrity\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: A multi-level, or hierarchical, index object for pandas objects. Parameters ---------- levels : sequence of arrays The unique labels for each level. codes : sequence of arrays Integers for each level designating which label at each location. sortorder : optional...\n\n\nEXAMPLE:\n\u003e\u003e\u003e arrays = [[1, 1, 2, 2], [\u0027red\u0027, \u0027blue\u0027, \u0027red\u0027, \u0027blue\u0027]]\n\u003e\u003e\u003e pd.MultiIndex.from_arrays(arrays, names=(\u0027number\u0027, \u0027color\u0027))\nMultiIndex([(1,  \u0027red\u0027),\n            (1, \u0027blue\u0027),\n            (2,  \u0027red\u0027),\n            (2, \u0027blue\u0027)],\n           names=[\u0027number\u0027, \u0027color\u0027])"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.NamedAgg", "label": "NamedAgg", "shape": "dot", "size": 20, "title": "NAME: NamedAgg\n------------------------------\nINPUTS: column, aggfunc\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Helper for column specific aggregation with control over output column names. Subclass of typing.NamedTuple. Parameters ---------- column : Hashable Column label in the DataFrame to apply aggfunc. aggfunc : function or str Function to apply to the provided column. If...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"key\": [1, 1, 2], \"a\": [-1, 0, 1], 1: [10, 11, 12]})\n\u003e\u003e\u003e agg_a = pd.NamedAgg(column=\"a\", aggfunc=\"min\")\n\u003e\u003e\u003e agg_1 = pd.NamedAgg(column=1, aggfunc=lambda x: np.mean(x))\n\u003e\u003e\u003e df.groupby(\"key\").agg(result_a=agg_a, result_1=agg_1)\n     result_a  result_1\nkey\n1          -1      10.5\n2           1      12.0"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Period", "label": "Period", "shape": "dot", "size": 20, "title": "NAME: Period\n------------------------------\nINPUTS: value, freq, ordinal, year, month, quarter, day, hour, minute, second\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Represents a period of time. Parameters ---------- value : Period, str, datetime, date or pandas.Timestamp, default None The time period represented (e.g., \u00274Q2005\u0027). This represents neither the start or the end of the period, but rather the entire period itself....\n\n\nEXAMPLE:\n\u003e\u003e\u003e period = pd.Period(\u00272012-1-1\u0027, freq=\u0027D\u0027)\n\u003e\u003e\u003e period\nPeriod(\u00272012-01-01\u0027, \u0027D\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.PeriodDtype", "label": "PeriodDtype", "shape": "dot", "size": 20, "title": "NAME: PeriodDtype\n------------------------------\nINPUTS: freq\nOUTPUTS: PeriodDtype\n------------------------------\nDESCRIPTION: An ExtensionDtype for Period data. **This is not an actual numpy dtype**, but a duck type. Parameters ---------- freq : str or DateOffset The frequency of this PeriodDtype. Attributes ---------- freq Methods ------- None Examples -------- \u003e\u003e\u003e pd.PeriodDtype(freq=\u0027D\u0027) period[D] \u003e\u003e\u003e...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.PeriodDtype(freq=\u0027D\u0027)\nperiod[D]"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.PeriodIndex", "label": "PeriodIndex", "shape": "dot", "size": 20, "title": "NAME: PeriodIndex\n------------------------------\nINPUTS: data, ordinal, freq, dtype, copy, name, fields\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Immutable ndarray holding ordinal values indicating regular periods in time. Index keys are boxed to Period objects which carries the metadata (eg, frequency information). Parameters ---------- data : array-like (1d int np.ndarray or PeriodArray), optional Optional period-like data to construct...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.PeriodIndex.from_fields(year=[2000, 2002], quarter=[1, 3])\n\u003e\u003e\u003e idx\nPeriodIndex([\u00272000Q1\u0027, \u00272002Q3\u0027], dtype=\u0027period[Q-DEC]\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.RangeIndex", "label": "RangeIndex", "shape": "dot", "size": 20, "title": "NAME: RangeIndex\n------------------------------\nINPUTS: start, stop, step, dtype, copy, name\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Immutable Index implementing a monotonic integer range. RangeIndex is a memory-saving special case of an Index limited to representing monotonic ranges with a 64-bit dtype. Using RangeIndex may in some instances improve computing speed. This is the default index type...\n\n\nEXAMPLE:\n\u003e\u003e\u003e list(pd.RangeIndex(5))\n[0, 1, 2, 3, 4]"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Series", "label": "Series", "shape": "dot", "size": 20, "title": "NAME: Series\n------------------------------\nINPUTS: data, index, dtype, name, copy, fastpath\nOUTPUTS: None\n------------------------------\nDESCRIPTION: One-dimensional ndarray with axis labels (including time series). Labels need not be unique but must be a hashable type. The object supports both integer- and label-based indexing and provides a host of methods for performing operations involving the index. Statistical...\n\n\nEXAMPLE:\n\u003e\u003e\u003e d = {\u0027a\u0027: 1, \u0027b\u0027: 2, \u0027c\u0027: 3}\n\u003e\u003e\u003e ser = pd.Series(data=d, index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e ser\na   1\nb   2\nc   3\ndtype: int64"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.SparseDtype", "label": "SparseDtype", "shape": "dot", "size": 20, "title": "NAME: SparseDtype\n------------------------------\nINPUTS: dtype, fill_value\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Dtype for data stored in :class:`SparseArray`. This dtype implements the pandas ExtensionDtype interface. Parameters ---------- dtype : str, ExtensionDtype, numpy.dtype, type, default numpy.float64 The dtype of the underlying array storing the non-fill value values. fill_value : scalar, optional The scalar...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([1, 0, 0], dtype=pd.SparseDtype(dtype=int, fill_value=0))\n\u003e\u003e\u003e ser\n0    1\n1    0\n2    0\ndtype: Sparse[int64, 0]\n\u003e\u003e\u003e ser.sparse.density\n0.3333333333333333"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.StringDtype", "label": "StringDtype", "shape": "dot", "size": 20, "title": "NAME: StringDtype\n------------------------------\nINPUTS: storage, na_value\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Extension dtype for string data. .. warning:: StringDtype is considered experimental. The implementation and parts of the API may change without warning. Parameters ---------- storage : {\"python\", \"pyarrow\"}, optional If not given, the value of ``pd.options.mode.string_storage``. na_value : {np.nan, pd.NA},...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.StringDtype()\nstring[python]"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Timedelta", "label": "Timedelta", "shape": "dot", "size": 20, "title": "NAME: Timedelta\n------------------------------\nINPUTS: value, unit, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Represents a duration, the difference between two dates or times. Timedelta is the pandas equivalent of python\u0027s ``datetime.timedelta`` and is interchangeable with it in most cases. Parameters ---------- value : Timedelta, timedelta, np.timedelta64, str, or int unit : str, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e td = pd.Timedelta(1, \"d\")\n\u003e\u003e\u003e td\nTimedelta(\u00271 days 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex", "label": "TimedeltaIndex", "shape": "dot", "size": 20, "title": "NAME: TimedeltaIndex\n------------------------------\nINPUTS: data, unit, freq, closed, dtype, copy, name\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Immutable Index of timedelta64 data. Represented internally as int64, and scalars returned Timedelta objects. Parameters ---------- data : array-like (1-dimensional), optional Optional timedelta-like data to construct index with. unit : {\u0027D\u0027, \u0027h\u0027, \u0027m\u0027, \u0027s\u0027, \u0027ms\u0027, \u0027us\u0027, \u0027ns\u0027}, optional The unit...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.TimedeltaIndex([\u00270 days\u0027, \u00271 days\u0027, \u00272 days\u0027, \u00273 days\u0027, \u00274 days\u0027])\nTimedeltaIndex([\u00270 days\u0027, \u00271 days\u0027, \u00272 days\u0027, \u00273 days\u0027, \u00274 days\u0027],\n               dtype=\u0027timedelta64[ns]\u0027, freq=None)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Timestamp", "label": "Timestamp", "shape": "dot", "size": 20, "title": "NAME: Timestamp\n------------------------------\nINPUTS: ts_input, year, month, day, hour, minute, second, microsecond, tzinfo, nanosecond, tz, unit, fold\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Pandas replacement for python datetime.datetime object. Timestamp is the pandas equivalent of python\u0027s Datetime and is interchangeable with it in most cases. It\u0027s the type used for the entries that make up a DatetimeIndex, and other timeseries oriented data structures...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Timestamp(\u00272017-01-01T12\u0027)\nTimestamp(\u00272017-01-01 12:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.UInt16Dtype", "label": "UInt16Dtype", "shape": "dot", "size": 20, "title": "NAME: UInt16Dtype\n------------------------------\nINPUTS: \nOUTPUTS: Any\n------------------------------\nDESCRIPTION: An ExtensionDtype for uint16 integer data. Uses :attr:`pandas.NA` as its missing value, rather than :attr:`numpy.nan`. Attributes ---------- None Methods ------- None Examples -------- For Int8Dtype: \u003e\u003e\u003e ser = pd.Series([2, pd.NA], dtype=pd.Int8Dtype()) \u003e\u003e\u003e ser.dtype Int8Dtype() For Int16Dtype: \u003e\u003e\u003e ser = pd.Series([2,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([2, pd.NA], dtype=pd.Int8Dtype())\n\u003e\u003e\u003e ser.dtype\nInt8Dtype()"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.UInt32Dtype", "label": "UInt32Dtype", "shape": "dot", "size": 20, "title": "NAME: UInt32Dtype\n------------------------------\nINPUTS: \nOUTPUTS: Any\n------------------------------\nDESCRIPTION: An ExtensionDtype for uint32 integer data. Uses :attr:`pandas.NA` as its missing value, rather than :attr:`numpy.nan`. Attributes ---------- None Methods ------- None Examples -------- For Int8Dtype: \u003e\u003e\u003e ser = pd.Series([2, pd.NA], dtype=pd.Int8Dtype()) \u003e\u003e\u003e ser.dtype Int8Dtype() For Int16Dtype: \u003e\u003e\u003e ser = pd.Series([2,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([2, pd.NA], dtype=pd.Int8Dtype())\n\u003e\u003e\u003e ser.dtype\nInt8Dtype()"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.UInt64Dtype", "label": "UInt64Dtype", "shape": "dot", "size": 20, "title": "NAME: UInt64Dtype\n------------------------------\nINPUTS: \nOUTPUTS: Any\n------------------------------\nDESCRIPTION: An ExtensionDtype for uint64 integer data. Uses :attr:`pandas.NA` as its missing value, rather than :attr:`numpy.nan`. Attributes ---------- None Methods ------- None Examples -------- For Int8Dtype: \u003e\u003e\u003e ser = pd.Series([2, pd.NA], dtype=pd.Int8Dtype()) \u003e\u003e\u003e ser.dtype Int8Dtype() For Int16Dtype: \u003e\u003e\u003e ser = pd.Series([2,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([2, pd.NA], dtype=pd.Int8Dtype())\n\u003e\u003e\u003e ser.dtype\nInt8Dtype()"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.UInt8Dtype", "label": "UInt8Dtype", "shape": "dot", "size": 20, "title": "NAME: UInt8Dtype\n------------------------------\nINPUTS: \nOUTPUTS: Any\n------------------------------\nDESCRIPTION: An ExtensionDtype for uint8 integer data. Uses :attr:`pandas.NA` as its missing value, rather than :attr:`numpy.nan`. Attributes ---------- None Methods ------- None Examples -------- For Int8Dtype: \u003e\u003e\u003e ser = pd.Series([2, pd.NA], dtype=pd.Int8Dtype()) \u003e\u003e\u003e ser.dtype Int8Dtype() For Int16Dtype: \u003e\u003e\u003e ser = pd.Series([2,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([2, pd.NA], dtype=pd.Int8Dtype())\n\u003e\u003e\u003e ser.dtype\nInt8Dtype()"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.api", "label": "api", "shape": "dot", "size": 20, "title": "NAME: api\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: public toolkit API...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.array", "label": "array", "shape": "dot", "size": 20, "title": "NAME: array\n------------------------------\nINPUTS: data, dtype, copy\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Create an array. Parameters ---------- data : Sequence of objects The scalars inside `data` should be instances of the scalar type for `dtype`. It\u0027s expected that `data` represents a 1-dimensional array of data. When `data` is an Index or Series,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.array([\u0027a\u0027, \u0027b\u0027], dtype=str)\n\u003cNumpyExtensionArray\u003e\n[\u0027a\u0027, \u0027b\u0027]\nLength: 2, dtype: str32"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.arrays", "label": "arrays", "shape": "dot", "size": 20, "title": "NAME: arrays\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: All of pandas\u0027 ExtensionArrays. See :ref:`extending.extension-types` for more....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.bdate_range", "label": "bdate_range", "shape": "dot", "size": 20, "title": "NAME: bdate_range\n------------------------------\nINPUTS: start, end, periods, freq, tz, normalize, name, weekmask, holidays, inclusive, kwargs\nOUTPUTS: DatetimeIndex\n------------------------------\nDESCRIPTION: Return a fixed frequency DatetimeIndex with business day as the default. Parameters ---------- start : str or datetime-like, default None Left bound for generating dates. end : str or datetime-like, default None Right bound for generating dates. periods : int,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.bdate_range(start=\u00271/1/2018\u0027, end=\u00271/08/2018\u0027)\nDatetimeIndex([\u00272018-01-01\u0027, \u00272018-01-02\u0027, \u00272018-01-03\u0027, \u00272018-01-04\u0027,\n           \u00272018-01-05\u0027, \u00272018-01-08\u0027],\n          dtype=\u0027datetime64[ns]\u0027, freq=\u0027B\u0027)"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.compat", "label": "compat", "shape": "dot", "size": 20, "title": "NAME: compat\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: compat ====== Cross-compatible functions for different versions of Python. Other items: * platform checker...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.concat", "label": "concat", "shape": "dot", "size": 20, "title": "NAME: concat\n------------------------------\nINPUTS: objs, axis, join, ignore_index, keys, levels, names, verify_integrity, sort, copy\nOUTPUTS: DataFrame | Series\n------------------------------\nDESCRIPTION: Concatenate pandas objects along a particular axis. Allows optional set logic along the other axes. Can also add a layer of hierarchical indexing on the concatenation axis, which may be useful if the labels are the same (or overlapping) on...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s1 = pd.Series([\u0027a\u0027, \u0027b\u0027])\n\u003e\u003e\u003e s2 = pd.Series([\u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e pd.concat([s1, s2])\n0    a\n1    b\n0    c\n1    d\ndtype: object"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core", "label": "core", "shape": "dot", "size": 20, "title": "NAME: core\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.crosstab", "label": "crosstab", "shape": "dot", "size": 20, "title": "NAME: crosstab\n------------------------------\nINPUTS: index, columns, values, rownames, colnames, aggfunc, margins, margins_name, dropna, normalize\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Compute a simple cross tabulation of two (or more) factors. By default, computes a frequency table of the factors unless an array of values and an aggregation function are passed. Parameters ---------- index : array-like, Series, or list of arrays/Series...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = np.array([\"foo\", \"foo\", \"foo\", \"foo\", \"bar\", \"bar\",\n...               \"bar\", \"bar\", \"foo\", \"foo\", \"foo\"], dtype=object)\n\u003e\u003e\u003e b = np.array([\"one\", \"one\", \"one\", \"two\", \"one\", \"one\",\n...               \"one\", \"two\", \"two\", \"two\", \"one\"], dtype=object)\n\u003e\u003e\u003e c = np.array([\"dull\", \"dull\", \"shiny\", \"dull\", \"dull\", \"shiny\",\n...               \"shiny\", \"dull\", \"shiny\", \"shiny\", \"shiny\"],\n...              dtype=object)\n\u003e\u003e\u003e pd.crosstab(a, [b, c], rownames=[\u0027a\u0027], colnames=[\u0027b\u0027, \u0027c\u0027])\nb   one        two\nc   dull shiny dull shiny\na\nbar    1     2    1     0\nfoo    2     2    1     2"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.cut", "label": "cut", "shape": "dot", "size": 20, "title": "NAME: cut\n------------------------------\nINPUTS: x, bins, right, labels, retbins, precision, include_lowest, duplicates, ordered\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Bin values into discrete intervals. Use `cut` when you need to segment and sort data values into bins. This function is also useful for going from a continuous variable to a categorical variable. For example, `cut` could convert ages to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.cut(np.array([1, 7, 5, 4, 6, 3]), 3)\n... # doctest: +ELLIPSIS\n[(0.994, 3.0], (5.0, 7.0], (3.0, 5.0], (3.0, 5.0], (5.0, 7.0], ...\nCategories (3, interval[float64, right]): [(0.994, 3.0] \u003c (3.0, 5.0] ..."}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.date_range", "label": "date_range", "shape": "dot", "size": 20, "title": "NAME: date_range\n------------------------------\nINPUTS: start, end, periods, freq, tz, normalize, name, inclusive, unit, kwargs\nOUTPUTS: DatetimeIndex\n------------------------------\nDESCRIPTION: Return a fixed frequency DatetimeIndex. Returns the range of equally spaced time points (where the difference between any two adjacent points is specified by the given frequency) such that they all satisfy `start \u003c[=] x \u003c[=] end`, where the first...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.date_range(start=\u00271/1/2018\u0027, end=\u00271/08/2018\u0027)\nDatetimeIndex([\u00272018-01-01\u0027, \u00272018-01-02\u0027, \u00272018-01-03\u0027, \u00272018-01-04\u0027,\n               \u00272018-01-05\u0027, \u00272018-01-06\u0027, \u00272018-01-07\u0027, \u00272018-01-08\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=\u0027D\u0027)"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.errors", "label": "errors", "shape": "dot", "size": 20, "title": "NAME: errors\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Expose public exceptions \u0026 warnings...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.eval", "label": "eval", "shape": "dot", "size": 20, "title": "NAME: eval\n------------------------------\nINPUTS: expr, parser, engine, local_dict, global_dict, resolvers, level, target, inplace\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Evaluate a Python expression as a string using various backends. The following arithmetic operations are supported: ``+``, ``-``, ``*``, ``/``, ``**``, ``%``, ``//`` (python engine only) along with the following boolean operations: ``|`` (or), ``\u0026`` (and), and ``~`` (not). Additionally,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"animal\": [\"dog\", \"pig\"], \"age\": [10, 20]})\n\u003e\u003e\u003e df\n  animal  age\n0    dog   10\n1    pig   20"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.factorize", "label": "factorize", "shape": "dot", "size": 20, "title": "NAME: factorize\n------------------------------\nINPUTS: values, sort, use_na_sentinel, size_hint\nOUTPUTS: tuple[np.ndarray, np.ndarray | Index]\n------------------------------\nDESCRIPTION: Encode the object as an enumerated type or categorical variable. This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct values. `factorize` is available as both a top-level function :func:`pandas.factorize`, and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e codes, uniques = pd.factorize(np.array([\u0027b\u0027, \u0027b\u0027, \u0027a\u0027, \u0027c\u0027, \u0027b\u0027], dtype=\"O\"))\n\u003e\u003e\u003e codes\narray([0, 0, 1, 2, 0])\n\u003e\u003e\u003e uniques\narray([\u0027b\u0027, \u0027a\u0027, \u0027c\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.from_dummies", "label": "from_dummies", "shape": "dot", "size": 20, "title": "NAME: from_dummies\n------------------------------\nINPUTS: data, sep, default_category\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Create a categorical ``DataFrame`` from a ``DataFrame`` of dummy variables. Inverts the operation performed by :func:`~pandas.get_dummies`. .. versionadded:: 1.5.0 Parameters ---------- data : DataFrame Data which contains dummy-coded variables in form of integer columns of 1\u0027s and 0\u0027s. sep :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"a\": [1, 0, 0, 1], \"b\": [0, 1, 0, 0],\n...                    \"c\": [0, 0, 1, 0]})"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.get_dummies", "label": "get_dummies", "shape": "dot", "size": 20, "title": "NAME: get_dummies\n------------------------------\nINPUTS: data, prefix, prefix_sep, dummy_na, columns, sparse, drop_first, dtype\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Convert categorical variable into dummy/indicator variables. Each variable is converted in as many 0/1 variables as there are different values. Columns in the output are each named after a value; if the input is a DataFrame, the name of the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(list(\u0027abca\u0027))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.infer_freq", "label": "infer_freq", "shape": "dot", "size": 20, "title": "NAME: infer_freq\n------------------------------\nINPUTS: index\nOUTPUTS: str | None\n------------------------------\nDESCRIPTION: Infer the most likely frequency given the input index. Parameters ---------- index : DatetimeIndex, TimedeltaIndex, Series or array-like If passed a Series will use the values of the series (NOT THE INDEX). Returns ------- str or None None if no...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.date_range(start=\u00272020/12/01\u0027, end=\u00272020/12/30\u0027, periods=30)\n\u003e\u003e\u003e pd.infer_freq(idx)\n\u0027D\u0027"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.interval_range", "label": "interval_range", "shape": "dot", "size": 20, "title": "NAME: interval_range\n------------------------------\nINPUTS: start, end, periods, freq, name, closed\nOUTPUTS: IntervalIndex\n------------------------------\nDESCRIPTION: Return a fixed frequency IntervalIndex. Parameters ---------- start : numeric or datetime-like, default None Left bound for generating intervals. end : numeric or datetime-like, default None Right bound for generating intervals. periods : int, default None Number of periods to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.interval_range(start=0, end=5)\nIntervalIndex([(0, 1], (1, 2], (2, 3], (3, 4], (4, 5]],\n              dtype=\u0027interval[int64, right]\u0027)"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io", "label": "io", "shape": "dot", "size": 20, "title": "NAME: io\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.isna", "label": "isna", "shape": "dot", "size": 20, "title": "NAME: isna\n------------------------------\nINPUTS: obj\nOUTPUTS: bool | npt.NDArray[np.bool_] | NDFrame\n------------------------------\nDESCRIPTION: Detect missing values for an array-like object. This function takes a scalar or array-like object and indicates whether values are missing (``NaN`` in numeric arrays, ``None`` or ``NaN`` in object arrays, ``NaT`` in datetimelike). Parameters ---------- obj : scalar or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.isna(\u0027dog\u0027)\nFalse"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.isnull", "label": "isnull", "shape": "dot", "size": 20, "title": "NAME: isnull\n------------------------------\nINPUTS: obj\nOUTPUTS: bool | npt.NDArray[np.bool_] | NDFrame\n------------------------------\nDESCRIPTION: Detect missing values for an array-like object. This function takes a scalar or array-like object and indicates whether values are missing (``NaN`` in numeric arrays, ``None`` or ``NaN`` in object arrays, ``NaT`` in datetimelike). Parameters ---------- obj : scalar or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.isna(\u0027dog\u0027)\nFalse"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.json_normalize", "label": "json_normalize", "shape": "dot", "size": 20, "title": "NAME: json_normalize\n------------------------------\nINPUTS: data, record_path, meta, meta_prefix, record_prefix, errors, sep, max_level\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Normalize semi-structured JSON data into a flat table. Parameters ---------- data : dict or list of dicts Unserialized JSON objects. record_path : str or list of str, default None Path in each object to list of records. If not passed,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e data = [\n...     {\"id\": 1, \"name\": {\"first\": \"Coleen\", \"last\": \"Volk\"}},\n...     {\"name\": {\"given\": \"Mark\", \"family\": \"Regner\"}},\n...     {\"id\": 2, \"name\": \"Faye Raker\"},\n... ]\n\u003e\u003e\u003e pd.json_normalize(data)\n    id name.first name.last name.given name.family        name\n0  1.0     Coleen      Volk        NaN         NaN         NaN\n1  NaN        NaN       NaN       Mark      Regner         NaN\n2  2.0        NaN       NaN        NaN         NaN  Faye Raker"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.lreshape", "label": "lreshape", "shape": "dot", "size": 20, "title": "NAME: lreshape\n------------------------------\nINPUTS: data, groups, dropna\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Reshape wide-format data to long. Generalized inverse of DataFrame.pivot. Accepts a dictionary, ``groups``, in which each key is a new column name and each value is a list of old column names that will be \"melted\" under the new column...\n\n\nEXAMPLE:\n\u003e\u003e\u003e data = pd.DataFrame({\u0027hr1\u0027: [514, 573], \u0027hr2\u0027: [545, 526],\n...                      \u0027team\u0027: [\u0027Red Sox\u0027, \u0027Yankees\u0027],\n...                      \u0027year1\u0027: [2007, 2007], \u0027year2\u0027: [2008, 2008]})\n\u003e\u003e\u003e data\n   hr1  hr2     team  year1  year2\n0  514  545  Red Sox   2007   2008\n1  573  526  Yankees   2007   2008"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.melt", "label": "melt", "shape": "dot", "size": 20, "title": "NAME: melt\n------------------------------\nINPUTS: frame, id_vars, value_vars, var_name, value_name, col_level, ignore_index\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Unpivot a DataFrame from wide to long format, optionally leaving identifiers set. This function is useful to massage a DataFrame into a format where one or more columns are identifier variables (`id_vars`), while all other columns, considered measured variables (`value_vars`),...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: {0: \u0027a\u0027, 1: \u0027b\u0027, 2: \u0027c\u0027},\n...                    \u0027B\u0027: {0: 1, 1: 3, 2: 5},\n...                    \u0027C\u0027: {0: 2, 1: 4, 2: 6}})\n\u003e\u003e\u003e df\n   A  B  C\n0  a  1  2\n1  b  3  4\n2  c  5  6"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.merge", "label": "merge", "shape": "dot", "size": 20, "title": "NAME: merge\n------------------------------\nINPUTS: left, right, how, on, left_on, right_on, left_index, right_index, sort, suffixes, copy, indicator, validate\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Merge DataFrame or named Series objects with a database-style join. A named Series object is treated as a DataFrame with a single named column. The join is done on columns or indexes. If joining columns on columns, the DataFrame indexes...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df1 = pd.DataFrame({\u0027lkey\u0027: [\u0027foo\u0027, \u0027bar\u0027, \u0027baz\u0027, \u0027foo\u0027],\n...                     \u0027value\u0027: [1, 2, 3, 5]})\n\u003e\u003e\u003e df2 = pd.DataFrame({\u0027rkey\u0027: [\u0027foo\u0027, \u0027bar\u0027, \u0027baz\u0027, \u0027foo\u0027],\n...                     \u0027value\u0027: [5, 6, 7, 8]})\n\u003e\u003e\u003e df1\n    lkey value\n0   foo      1\n1   bar      2\n2   baz      3\n3   foo      5\n\u003e\u003e\u003e df2\n    rkey value\n0   foo      5\n1   bar      6\n2   baz      7\n3   foo      8"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.merge_asof", "label": "merge_asof", "shape": "dot", "size": 20, "title": "NAME: merge_asof\n------------------------------\nINPUTS: left, right, on, left_on, right_on, left_index, right_index, by, left_by, right_by, suffixes, tolerance, allow_exact_matches, direction\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Perform a merge by key distance. This is similar to a left-join except that we match on nearest key rather than equal keys. Both DataFrames must be sorted by the key. For each row in the left DataFrame: - A...\n\n\nEXAMPLE:\n\u003e\u003e\u003e left = pd.DataFrame({\"a\": [1, 5, 10], \"left_val\": [\"a\", \"b\", \"c\"]})\n\u003e\u003e\u003e left\n    a left_val\n0   1        a\n1   5        b\n2  10        c"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.merge_ordered", "label": "merge_ordered", "shape": "dot", "size": 20, "title": "NAME: merge_ordered\n------------------------------\nINPUTS: left, right, on, left_on, right_on, left_by, right_by, fill_method, suffixes, how\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Perform a merge for ordered data with optional filling/interpolation. Designed for ordered data like time series data. Optionally perform group-wise merge (see examples). Parameters ---------- left : DataFrame or named Series right : DataFrame or named Series on : label...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas import merge_ordered\n\u003e\u003e\u003e df1 = pd.DataFrame(\n...     {\n...         \"key\": [\"a\", \"c\", \"e\", \"a\", \"c\", \"e\"],\n...         \"lvalue\": [1, 2, 3, 1, 2, 3],\n...         \"group\": [\"a\", \"a\", \"a\", \"b\", \"b\", \"b\"]\n...     }\n... )\n\u003e\u003e\u003e df1\n  key  lvalue group\n0   a       1     a\n1   c       2     a\n2   e       3     a\n3   a       1     b\n4   c       2     b\n5   e       3     b"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.notna", "label": "notna", "shape": "dot", "size": 20, "title": "NAME: notna\n------------------------------\nINPUTS: obj\nOUTPUTS: bool | npt.NDArray[np.bool_] | NDFrame\n------------------------------\nDESCRIPTION: Detect non-missing values for an array-like object. This function takes a scalar or array-like object and indicates whether values are valid (not missing, which is ``NaN`` in numeric arrays, ``None`` or ``NaN`` in object arrays, ``NaT`` in datetimelike). Parameters ----------...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.notna(\u0027dog\u0027)\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.notnull", "label": "notnull", "shape": "dot", "size": 20, "title": "NAME: notnull\n------------------------------\nINPUTS: obj\nOUTPUTS: bool | npt.NDArray[np.bool_] | NDFrame\n------------------------------\nDESCRIPTION: Detect non-missing values for an array-like object. This function takes a scalar or array-like object and indicates whether values are valid (not missing, which is ``NaN`` in numeric arrays, ``None`` or ``NaN`` in object arrays, ``NaT`` in datetimelike). Parameters ----------...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.notna(\u0027dog\u0027)\nTrue"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.offsets", "label": "offsets", "shape": "dot", "size": 20, "title": "NAME: offsets\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.option_context", "label": "option_context", "shape": "dot", "size": 20, "title": "NAME: option_context\n------------------------------\nINPUTS: args\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Context manager to temporarily set options in the `with` statement context. You need to invoke as ``option_context(pat, val, [(pat, val), ...])``. Examples -------- \u003e\u003e\u003e from pandas import option_context \u003e\u003e\u003e with option_context(\u0027display.max_rows\u0027, 10, \u0027display.max_columns\u0027, 5): ... pass...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas import option_context\n\u003e\u003e\u003e with option_context(\u0027display.max_rows\u0027, 10, \u0027display.max_columns\u0027, 5):\n...     pass"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.pandas", "label": "pandas", "shape": "dot", "size": 20, "title": "NAME: pandas\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: pandas - a powerful data analysis and manipulation library for Python ===================================================================== **pandas** is a Python package providing fast, flexible, and expressive data structures designed to make working with \"relational\" or \"labeled\" data both easy and intuitive. It aims to...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.period_range", "label": "period_range", "shape": "dot", "size": 20, "title": "NAME: period_range\n------------------------------\nINPUTS: start, end, periods, freq, name\nOUTPUTS: PeriodIndex\n------------------------------\nDESCRIPTION: Return a fixed frequency PeriodIndex. The day (calendar) is the default frequency. Parameters ---------- start : str, datetime, date, pandas.Timestamp, or period-like, default None Left bound for generating periods. end : str, datetime, date, pandas.Timestamp, or period-like, default None Right...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.period_range(start=\u00272017-01-01\u0027, end=\u00272018-01-01\u0027, freq=\u0027M\u0027)\nPeriodIndex([\u00272017-01\u0027, \u00272017-02\u0027, \u00272017-03\u0027, \u00272017-04\u0027, \u00272017-05\u0027, \u00272017-06\u0027,\n         \u00272017-07\u0027, \u00272017-08\u0027, \u00272017-09\u0027, \u00272017-10\u0027, \u00272017-11\u0027, \u00272017-12\u0027,\n         \u00272018-01\u0027],\n        dtype=\u0027period[M]\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.pivot", "label": "pivot", "shape": "dot", "size": 20, "title": "NAME: pivot\n------------------------------\nINPUTS: data, columns, index, values\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Return reshaped DataFrame organized by given index / column values. Reshape data (produce a \"pivot\" table) based on column values. Uses unique values from specified `index` / `columns` to form axes of the resulting DataFrame. This function does not support...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027foo\u0027: [\u0027one\u0027, \u0027one\u0027, \u0027one\u0027, \u0027two\u0027, \u0027two\u0027,\n...                            \u0027two\u0027],\n...                    \u0027bar\u0027: [\u0027A\u0027, \u0027B\u0027, \u0027C\u0027, \u0027A\u0027, \u0027B\u0027, \u0027C\u0027],\n...                    \u0027baz\u0027: [1, 2, 3, 4, 5, 6],\n...                    \u0027zoo\u0027: [\u0027x\u0027, \u0027y\u0027, \u0027z\u0027, \u0027q\u0027, \u0027w\u0027, \u0027t\u0027]})\n\u003e\u003e\u003e df\n    foo   bar  baz  zoo\n0   one   A    1    x\n1   one   B    2    y\n2   one   C    3    z\n3   two   A    4    q\n4   two   B    5    w\n5   two   C    6    t"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.pivot_table", "label": "pivot_table", "shape": "dot", "size": 20, "title": "NAME: pivot_table\n------------------------------\nINPUTS: data, values, index, columns, aggfunc, fill_value, margins, dropna, margins_name, observed, sort\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Create a spreadsheet-style pivot table as a DataFrame. The levels in the pivot table will be stored in MultiIndex objects (hierarchical indexes) on the index and columns of the result DataFrame. Parameters ---------- data : DataFrame values : list-like or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"A\": [\"foo\", \"foo\", \"foo\", \"foo\", \"foo\",\n...                          \"bar\", \"bar\", \"bar\", \"bar\"],\n...                    \"B\": [\"one\", \"one\", \"one\", \"two\", \"two\",\n...                          \"one\", \"one\", \"two\", \"two\"],\n...                    \"C\": [\"small\", \"large\", \"large\", \"small\",\n...                          \"small\", \"large\", \"small\", \"small\",\n...                          \"large\"],\n...                    \"D\": [1, 2, 2, 3, 3, 4, 5, 6, 7],\n...                    \"E\": [2, 4, 5, 5, 6, 6, 8, 9, 9]})\n\u003e\u003e\u003e df\n     A    B      C  D  E\n0  foo  one  small  1  2\n1  foo  one  large  2  4\n2  foo  one  large  2  5\n3  foo  two  small  3  5\n4  foo  two  small  3  6\n5  bar  one  large  4  6\n6  bar  one  small  5  8\n7  bar  two  small  6  9\n8  bar  two  large  7  9"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.plotting", "label": "plotting", "shape": "dot", "size": 20, "title": "NAME: plotting\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Plotting public API. Authors of third-party plotting backends should implement a module with a public ``plot(data, kind, **kwargs)``. The parameter `data` will contain the data structure and can be a `Series` or a `DataFrame`. For example, for ``df.plot()`` the parameter...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.qcut", "label": "qcut", "shape": "dot", "size": 20, "title": "NAME: qcut\n------------------------------\nINPUTS: x, q, labels, retbins, precision, duplicates\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Quantile-based discretization function. Discretize variable into equal-sized buckets based on rank or based on sample quantiles. For example 1000 values for 10 quantiles would produce a Categorical object indicating quantile membership for each data point. Parameters ---------- x : 1d...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.qcut(range(5), 4)\n... # doctest: +ELLIPSIS\n[(-0.001, 1.0], (-0.001, 1.0], (1.0, 2.0], (2.0, 3.0], (3.0, 4.0]]\nCategories (4, interval[float64, right]): [(-0.001, 1.0] \u003c (1.0, 2.0] ..."}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_clipboard", "label": "read_clipboard", "shape": "dot", "size": 20, "title": "NAME: read_clipboard\n------------------------------\nINPUTS: sep, dtype_backend, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Read text from clipboard and pass to :func:`~pandas.read_csv`. Parses clipboard contents similar to how CSV files are parsed using :func:`~pandas.read_csv`. Parameters ---------- sep : str, default \u0027\\\\s+\u0027 A string or regex delimiter. The default of ``\u0027\\\\s+\u0027`` denotes one or more...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], columns=[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027])\n\u003e\u003e\u003e df.to_clipboard()  # doctest: +SKIP\n\u003e\u003e\u003e pd.read_clipboard()  # doctest: +SKIP\n     A  B  C\n0    1  2  3\n1    4  5  6"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_csv", "label": "read_csv", "shape": "dot", "size": 20, "title": "NAME: read_csv\n------------------------------\nINPUTS: filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend\nOUTPUTS: DataFrame | TextFileReader\n------------------------------\nDESCRIPTION: Read a comma-separated values (csv) file into DataFrame. Also supports optionally iterating or breaking of the file into chunks. Additional help can be found in the online docs for `IO Tools \u003chttps://pandas.pydata.org/pandas-docs/stable/user_guide/io.html\u003e`_. Parameters ---------- filepath_or_buffer : str, path object or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.read_csv(\u0027data.csv\u0027)  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_excel", "label": "read_excel", "shape": "dot", "size": 20, "title": "NAME: read_excel\n------------------------------\nINPUTS: io, sheet_name, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skiprows, nrows, na_values, keep_default_na, na_filter, verbose, parse_dates, date_parser, date_format, thousands, decimal, comment, skipfooter, storage_options, dtype_backend, engine_kwargs\nOUTPUTS: DataFrame | dict[IntStrT, DataFrame]\n------------------------------\nDESCRIPTION: Read an Excel file into a ``pandas`` ``DataFrame``. Supports `xls`, `xlsx`, `xlsm`, `xlsb`, `odf`, `ods` and `odt` file extensions read from a local filesystem or URL. Supports an option to read a single sheet or a list of sheets. Parameters...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.read_excel(\u0027tmp.xlsx\u0027, index_col=0)  # doctest: +SKIP\n       Name  Value\n0   string1      1\n1   string2      2\n2  #Comment      3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_feather", "label": "read_feather", "shape": "dot", "size": 20, "title": "NAME: read_feather\n------------------------------\nINPUTS: path, columns, use_threads, storage_options, dtype_backend\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Load a feather-format object from the file path. Parameters ---------- path : str, path object, or file-like object String, path object (implementing ``os.PathLike[str]``), or file-like object implementing a binary ``read()`` function. The string could be a URL. Valid URL schemes...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.read_feather(\"path/to/file.feather\")  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_fwf", "label": "read_fwf", "shape": "dot", "size": 20, "title": "NAME: read_fwf\n------------------------------\nINPUTS: filepath_or_buffer, colspecs, widths, infer_nrows, dtype_backend, iterator, chunksize, kwds\nOUTPUTS: DataFrame | TextFileReader\n------------------------------\nDESCRIPTION: Read a table of fixed-width formatted lines into DataFrame. Also supports optionally iterating or breaking of the file into chunks. Additional help can be found in the `online docs for IO Tools \u003chttps://pandas.pydata.org/pandas-docs/stable/user_guide/io.html\u003e`_. Parameters ---------- filepath_or_buffer : str, path object,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.read_fwf(\u0027data.csv\u0027)  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_gbq", "label": "read_gbq", "shape": "dot", "size": 20, "title": "NAME: read_gbq\n------------------------------\nINPUTS: query, project_id, index_col, col_order, reauth, auth_local_webserver, dialect, location, configuration, credentials, use_bqstorage_api, max_results, progress_bar_type\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Load data from Google BigQuery. .. deprecated:: 2.2.0 Please use ``pandas_gbq.read_gbq`` instead. This function requires the `pandas-gbq package \u003chttps://pandas-gbq.readthedocs.io\u003e`__. See the `How to authenticate with Google BigQuery \u003chttps://pandas-gbq.readthedocs.io/en/latest/howto/authentication.html\u003e`__ guide for authentication instructions. Parameters ---------- query : str SQL-Like Query to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e sql = \"SELECT name FROM table_name WHERE state = \u0027TX\u0027 LIMIT 100;\"\n\u003e\u003e\u003e df = pd.read_gbq(sql, dialect=\"standard\")  # doctest: +SKIP\n\u003e\u003e\u003e project_id = \"your-project-id\"  # doctest: +SKIP\n\u003e\u003e\u003e df = pd.read_gbq(sql,\n...                  project_id=project_id,\n...                  dialect=\"standard\"\n...                  )  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_hdf", "label": "read_hdf", "shape": "dot", "size": 20, "title": "NAME: read_hdf\n------------------------------\nINPUTS: path_or_buf, key, mode, errors, where, start, stop, columns, iterator, chunksize, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Read from the store, close it if we opened it. Retrieve pandas object stored in file, optionally based on where criteria. .. warning:: Pandas uses PyTables for reading and writing HDF5 files, which allows serializing object-dtype data with pickle when...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[1, 1.0, \u0027a\u0027]], columns=[\u0027x\u0027, \u0027y\u0027, \u0027z\u0027])  # doctest: +SKIP\n\u003e\u003e\u003e df.to_hdf(\u0027./store.h5\u0027, \u0027data\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e reread = pd.read_hdf(\u0027./store.h5\u0027)  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_html", "label": "read_html", "shape": "dot", "size": 20, "title": "NAME: read_html\n------------------------------\nINPUTS: io, match, flavor, header, index_col, skiprows, attrs, parse_dates, thousands, encoding, decimal, converters, na_values, keep_default_na, displayed_only, extract_links, dtype_backend, storage_options\nOUTPUTS: list[DataFrame]\n------------------------------\nDESCRIPTION: Read HTML tables into a ``list`` of ``DataFrame`` objects. Parameters ---------- io : str, path object, or file-like object String, path object (implementing ``os.PathLike[str]``), or file-like object implementing a string ``read()`` function. The string can represent a URL or the...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_json", "label": "read_json", "shape": "dot", "size": 20, "title": "NAME: read_json\n------------------------------\nINPUTS: path_or_buf, orient, typ, dtype, convert_axes, convert_dates, keep_default_dates, precise_float, date_unit, encoding, encoding_errors, lines, chunksize, compression, nrows, storage_options, dtype_backend, engine\nOUTPUTS: DataFrame | Series | JsonReader\n------------------------------\nDESCRIPTION: Convert a JSON string to pandas object. Parameters ---------- path_or_buf : a valid JSON str, path object or file-like object Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from io import StringIO\n\u003e\u003e\u003e df = pd.DataFrame([[\u0027a\u0027, \u0027b\u0027], [\u0027c\u0027, \u0027d\u0027]],\n...                   index=[\u0027row 1\u0027, \u0027row 2\u0027],\n...                   columns=[\u0027col 1\u0027, \u0027col 2\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_orc", "label": "read_orc", "shape": "dot", "size": 20, "title": "NAME: read_orc\n------------------------------\nINPUTS: path, columns, dtype_backend, filesystem, kwargs\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Load an ORC object from the file path, returning a DataFrame. Parameters ---------- path : str, path object, or file-like object String, path object (implementing ``os.PathLike[str]``), or file-like object implementing a binary ``read()`` function. The string could be a URL....\n\n\nEXAMPLE:\n\u003e\u003e\u003e result = pd.read_orc(\"example_pa.orc\")  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_parquet", "label": "read_parquet", "shape": "dot", "size": 20, "title": "NAME: read_parquet\n------------------------------\nINPUTS: path, engine, columns, storage_options, use_nullable_dtypes, dtype_backend, filesystem, filters, kwargs\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Load a parquet object from the file path, returning a DataFrame. Parameters ---------- path : str, path object or file-like object String, path object (implementing ``os.PathLike[str]``), or file-like object implementing a binary ``read()`` function. The string could be a URL....\n\n\nEXAMPLE:\n\u003e\u003e\u003e original_df = pd.DataFrame(\n...     {\"foo\": range(5), \"bar\": range(5, 10)}\n...    )\n\u003e\u003e\u003e original_df\n   foo  bar\n0    0    5\n1    1    6\n2    2    7\n3    3    8\n4    4    9\n\u003e\u003e\u003e df_parquet_bytes = original_df.to_parquet()\n\u003e\u003e\u003e from io import BytesIO\n\u003e\u003e\u003e restored_df = pd.read_parquet(BytesIO(df_parquet_bytes))\n\u003e\u003e\u003e restored_df\n   foo  bar\n0    0    5\n1    1    6\n2    2    7\n3    3    8\n4    4    9\n\u003e\u003e\u003e restored_df.equals(original_df)\nTrue\n\u003e\u003e\u003e restored_bar = pd.read_parquet(BytesIO(df_parquet_bytes), columns=[\"bar\"])\n\u003e\u003e\u003e restored_bar\n    bar\n0    5\n1    6\n2    7\n3    8\n4    9\n\u003e\u003e\u003e restored_bar.equals(original_df[[\u0027bar\u0027]])\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_pickle", "label": "read_pickle", "shape": "dot", "size": 20, "title": "NAME: read_pickle\n------------------------------\nINPUTS: filepath_or_buffer, compression, storage_options\nOUTPUTS: DataFrame | Series\n------------------------------\nDESCRIPTION: Load pickled pandas object (or any object) from file. .. warning:: Loading pickled data received from untrusted sources can be unsafe. See `here \u003chttps://docs.python.org/3/library/pickle.html\u003e`__. Parameters ---------- filepath_or_buffer : str, path object, or file-like object String, path object (implementing ``os.PathLike[str]``), or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e original_df = pd.DataFrame(\n...     {\"foo\": range(5), \"bar\": range(5, 10)}\n...    )  # doctest: +SKIP\n\u003e\u003e\u003e original_df  # doctest: +SKIP\n   foo  bar\n0    0    5\n1    1    6\n2    2    7\n3    3    8\n4    4    9\n\u003e\u003e\u003e pd.to_pickle(original_df, \"./dummy.pkl\")  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_sas", "label": "read_sas", "shape": "dot", "size": 20, "title": "NAME: read_sas\n------------------------------\nINPUTS: filepath_or_buffer, format, index, encoding, chunksize, iterator, compression\nOUTPUTS: DataFrame | ReaderBase\n------------------------------\nDESCRIPTION: Read SAS files stored as either XPORT or SAS7BDAT format files. Parameters ---------- filepath_or_buffer : str, path object, or file-like object String, path object (implementing ``os.PathLike[str]``), or file-like object implementing a binary ``read()`` function. The string could be a URL....\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.read_sas(\"sas_data.sas7bdat\")  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_spss", "label": "read_spss", "shape": "dot", "size": 20, "title": "NAME: read_spss\n------------------------------\nINPUTS: path, usecols, convert_categoricals, dtype_backend\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Load an SPSS file from the file path, returning a DataFrame. Parameters ---------- path : str or Path File path. usecols : list-like, optional Return a subset of the columns. If None, return all columns. convert_categoricals : bool, default is...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.read_spss(\"spss_data.sav\")  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_sql", "label": "read_sql", "shape": "dot", "size": 20, "title": "NAME: read_sql\n------------------------------\nINPUTS: sql, con, index_col, coerce_float, params, parse_dates, columns, chunksize, dtype_backend, dtype\nOUTPUTS: DataFrame | Iterator[DataFrame]\n------------------------------\nDESCRIPTION: Read SQL query or database table into a DataFrame. This function is a convenience wrapper around ``read_sql_table`` and ``read_sql_query`` (for backward compatibility). It will delegate to the specific function depending on the provided input. A SQL query will be routed...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from sqlite3 import connect\n\u003e\u003e\u003e conn = connect(\u0027:memory:\u0027)\n\u003e\u003e\u003e df = pd.DataFrame(data=[[0, \u002710/11/12\u0027], [1, \u002712/11/10\u0027]],\n...                   columns=[\u0027int_column\u0027, \u0027date_column\u0027])\n\u003e\u003e\u003e df.to_sql(name=\u0027test_data\u0027, con=conn)\n2"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_sql_query", "label": "read_sql_query", "shape": "dot", "size": 20, "title": "NAME: read_sql_query\n------------------------------\nINPUTS: sql, con, index_col, coerce_float, params, parse_dates, chunksize, dtype, dtype_backend\nOUTPUTS: DataFrame | Iterator[DataFrame]\n------------------------------\nDESCRIPTION: Read SQL query into a DataFrame. Returns a DataFrame corresponding to the result set of the query string. Optionally provide an `index_col` parameter to use one of the columns as the index, otherwise default integer index will be used. Parameters...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from sqlalchemy import create_engine  # doctest: +SKIP\n\u003e\u003e\u003e engine = create_engine(\"sqlite:///database.db\")  # doctest: +SKIP\n\u003e\u003e\u003e with engine.connect() as conn, conn.begin():  # doctest: +SKIP\n...     data = pd.read_sql_table(\"data\", conn)  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_sql_table", "label": "read_sql_table", "shape": "dot", "size": 20, "title": "NAME: read_sql_table\n------------------------------\nINPUTS: table_name, con, schema, index_col, coerce_float, parse_dates, columns, chunksize, dtype_backend\nOUTPUTS: DataFrame | Iterator[DataFrame]\n------------------------------\nDESCRIPTION: Read SQL database table into a DataFrame. Given a table name and a SQLAlchemy connectable, returns a DataFrame. This function does not support DBAPI connections. Parameters ---------- table_name : str Name of SQL table in database. con : SQLAlchemy connectable...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.read_sql_table(\u0027table_name\u0027, \u0027postgres:///db_name\u0027)  # doctest:+SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_stata", "label": "read_stata", "shape": "dot", "size": 20, "title": "NAME: read_stata\n------------------------------\nINPUTS: filepath_or_buffer, convert_dates, convert_categoricals, index_col, convert_missing, preserve_dtypes, columns, order_categoricals, chunksize, iterator, compression, storage_options\nOUTPUTS: DataFrame | StataReader\n------------------------------\nDESCRIPTION: Read Stata file into DataFrame. Parameters ---------- filepath_or_buffer : str, path object or file-like object Any valid string path is acceptable. The string could be a URL. Valid URL schemes include http, ftp, s3, and file. For file URLs, a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027animal\u0027: [\u0027falcon\u0027, \u0027parrot\u0027, \u0027falcon\u0027, \u0027parrot\u0027],\n...                     \u0027speed\u0027: [350, 18, 361, 15]})  # doctest: +SKIP\n\u003e\u003e\u003e df.to_stata(\u0027animals.dta\u0027)  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_table", "label": "read_table", "shape": "dot", "size": 20, "title": "NAME: read_table\n------------------------------\nINPUTS: filepath_or_buffer, sep, delimiter, header, names, index_col, usecols, dtype, engine, converters, true_values, false_values, skipinitialspace, skiprows, skipfooter, nrows, na_values, keep_default_na, na_filter, verbose, skip_blank_lines, parse_dates, infer_datetime_format, keep_date_col, date_parser, date_format, dayfirst, cache_dates, iterator, chunksize, compression, thousands, decimal, lineterminator, quotechar, quoting, doublequote, escapechar, comment, encoding, encoding_errors, dialect, on_bad_lines, delim_whitespace, low_memory, memory_map, float_precision, storage_options, dtype_backend\nOUTPUTS: DataFrame | TextFileReader\n------------------------------\nDESCRIPTION: Read general delimited file into DataFrame. Also supports optionally iterating or breaking of the file into chunks. Additional help can be found in the online docs for `IO Tools \u003chttps://pandas.pydata.org/pandas-docs/stable/user_guide/io.html\u003e`_. Parameters ---------- filepath_or_buffer : str, path object or file-like object...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.read_table(\u0027data.csv\u0027)  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.read_xml", "label": "read_xml", "shape": "dot", "size": 20, "title": "NAME: read_xml\n------------------------------\nINPUTS: path_or_buffer, xpath, namespaces, elems_only, attrs_only, names, dtype, converters, parse_dates, encoding, parser, stylesheet, iterparse, compression, storage_options, dtype_backend\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Read XML document into a :class:`~pandas.DataFrame` object. .. versionadded:: 1.3.0 Parameters ---------- path_or_buffer : str, path object, or file-like object String, path object (implementing ``os.PathLike[str]``), or file-like object implementing a ``read()`` function. The string can be any valid XML string...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from io import StringIO\n\u003e\u003e\u003e xml = \u0027\u0027\u0027\u003c?xml version=\u00271.0\u0027 encoding=\u0027utf-8\u0027?\u003e\n... \u003cdata xmlns=\"http://example.com\"\u003e\n...  \u003crow\u003e\n...    \u003cshape\u003esquare\u003c/shape\u003e\n...    \u003cdegrees\u003e360\u003c/degrees\u003e\n...    \u003csides\u003e4.0\u003c/sides\u003e\n...  \u003c/row\u003e\n...  \u003crow\u003e\n...    \u003cshape\u003ecircle\u003c/shape\u003e\n...    \u003cdegrees\u003e360\u003c/degrees\u003e\n...    \u003csides/\u003e\n...  \u003c/row\u003e\n...  \u003crow\u003e\n...    \u003cshape\u003etriangle\u003c/shape\u003e\n...    \u003cdegrees\u003e180\u003c/degrees\u003e\n...    \u003csides\u003e3.0\u003c/sides\u003e\n...  \u003c/row\u003e\n... \u003c/data\u003e\u0027\u0027\u0027"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.set_eng_float_format", "label": "set_eng_float_format", "shape": "dot", "size": 20, "title": "NAME: set_eng_float_format\n------------------------------\nINPUTS: accuracy, use_eng_prefix\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Format float representation in DataFrame with SI notation. Parameters ---------- accuracy : int, default 3 Number of decimal digits after the floating point. use_eng_prefix : bool, default False Whether to represent a value with SI prefixes. Returns ------- None Examples...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([1e-9, 1e-3, 1, 1e3, 1e6])\n\u003e\u003e\u003e df\n              0\n0  1.000000e-09\n1  1.000000e-03\n2  1.000000e+00\n3  1.000000e+03\n4  1.000000e+06"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.show_versions", "label": "show_versions", "shape": "dot", "size": 20, "title": "NAME: show_versions\n------------------------------\nINPUTS: as_json\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Provide useful information, important for bug reports. It comprises info about hosting operation system, pandas version, and versions of other installed relative packages. Parameters ---------- as_json : str or bool, default False * If False, outputs info in a human...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.show_versions()  # doctest: +SKIP\nYour output may look something like this:\nINSTALLED VERSIONS\n------------------\ncommit           : 37ea63d540fd27274cad6585082c91b1283f963d\npython           : 3.10.6.final.0\npython-bits      : 64\nOS               : Linux\nOS-release       : 5.10.102.1-microsoft-standard-WSL2\nVersion          : #1 SMP Wed Mar 2 00:30:59 UTC 2022\nmachine          : x86_64\nprocessor        : x86_64\nbyteorder        : little\nLC_ALL           : None\nLANG             : en_GB.UTF-8\nLOCALE           : en_GB.UTF-8\npandas           : 2.0.1\nnumpy            : 1.24.3\n..."}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.test", "label": "test", "shape": "dot", "size": 20, "title": "NAME: test\n------------------------------\nINPUTS: extra_args, run_doctests\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Run the pandas test suite using pytest. By default, runs with the marks -m \"not slow and not network and not db\" Parameters ---------- extra_args : list[str], default None Extra marks to run the tests. run_doctests : bool, default False...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.test()  # doctest: +SKIP\nrunning: pytest..."}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.testing", "label": "testing", "shape": "dot", "size": 20, "title": "NAME: testing\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Public testing utility functions....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.timedelta_range", "label": "timedelta_range", "shape": "dot", "size": 20, "title": "NAME: timedelta_range\n------------------------------\nINPUTS: start, end, periods, freq, name, closed, unit\nOUTPUTS: TimedeltaIndex\n------------------------------\nDESCRIPTION: Return a fixed frequency TimedeltaIndex with day as the default. Parameters ---------- start : str or timedelta-like, default None Left bound for generating timedeltas. end : str or timedelta-like, default None Right bound for generating timedeltas. periods : int, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.timedelta_range(start=\u00271 day\u0027, periods=4)\nTimedeltaIndex([\u00271 days\u0027, \u00272 days\u0027, \u00273 days\u0027, \u00274 days\u0027],\n               dtype=\u0027timedelta64[ns]\u0027, freq=\u0027D\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.to_datetime", "label": "to_datetime", "shape": "dot", "size": 20, "title": "NAME: to_datetime\n------------------------------\nINPUTS: arg, errors, dayfirst, yearfirst, utc, format, exact, unit, infer_datetime_format, origin, cache\nOUTPUTS: DatetimeIndex | Series | DatetimeScalar | NaTType | None\n------------------------------\nDESCRIPTION: Convert argument to datetime. This function converts a scalar, array-like, :class:`Series` or :class:`DataFrame`/dict-like to a pandas datetime object. Parameters ---------- arg : int, float, str, datetime, list, tuple, 1-d array, Series, DataFrame/dict-like The object to convert to a datetime. If...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027year\u0027: [2015, 2016],\n...                    \u0027month\u0027: [2, 3],\n...                    \u0027day\u0027: [4, 5]})\n\u003e\u003e\u003e pd.to_datetime(df)\n0   2015-02-04\n1   2016-03-05\ndtype: datetime64[ns]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.to_numeric", "label": "to_numeric", "shape": "dot", "size": 20, "title": "NAME: to_numeric\n------------------------------\nINPUTS: arg, errors, downcast, dtype_backend\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Convert argument to a numeric type. The default return dtype is `float64` or `int64` depending on the data supplied. Use the `downcast` parameter to obtain other dtypes. Please note that precision loss may occur if really large numbers are passed...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\u00271.0\u0027, \u00272\u0027, -3])\n\u003e\u003e\u003e pd.to_numeric(s)\n0    1.0\n1    2.0\n2   -3.0\ndtype: float64\n\u003e\u003e\u003e pd.to_numeric(s, downcast=\u0027float\u0027)\n0    1.0\n1    2.0\n2   -3.0\ndtype: float32\n\u003e\u003e\u003e pd.to_numeric(s, downcast=\u0027signed\u0027)\n0    1\n1    2\n2   -3\ndtype: int8\n\u003e\u003e\u003e s = pd.Series([\u0027apple\u0027, \u00271.0\u0027, \u00272\u0027, -3])\n\u003e\u003e\u003e pd.to_numeric(s, errors=\u0027coerce\u0027)\n0    NaN\n1    1.0\n2    2.0\n3   -3.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.to_pickle", "label": "to_pickle", "shape": "dot", "size": 20, "title": "NAME: to_pickle\n------------------------------\nINPUTS: obj, filepath_or_buffer, compression, protocol, storage_options\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Pickle (serialize) object to file. Parameters ---------- obj : any object Any python object. filepath_or_buffer : str, path object, or file-like object String, path object (implementing ``os.PathLike[str]``), or file-like object implementing a binary ``write()`` function. Also accepts URL. URL has...\n\n\nEXAMPLE:\n\u003e\u003e\u003e original_df = pd.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})  # doctest: +SKIP\n\u003e\u003e\u003e original_df  # doctest: +SKIP\n   foo  bar\n0    0    5\n1    1    6\n2    2    7\n3    3    8\n4    4    9\n\u003e\u003e\u003e pd.to_pickle(original_df, \"./dummy.pkl\")  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.to_timedelta", "label": "to_timedelta", "shape": "dot", "size": 20, "title": "NAME: to_timedelta\n------------------------------\nINPUTS: arg, unit, errors\nOUTPUTS: Timedelta | TimedeltaIndex | Series\n------------------------------\nDESCRIPTION: Convert argument to timedelta. Timedeltas are absolute differences in times, expressed in difference units (e.g. days, hours, minutes, seconds). This method converts an argument from a recognized timedelta format / value into a Timedelta type. Parameters ---------- arg : str,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.to_timedelta(\u00271 days 06:05:01.00003\u0027)\nTimedelta(\u00271 days 06:05:01.000030\u0027)\n\u003e\u003e\u003e pd.to_timedelta(\u002715.5us\u0027)\nTimedelta(\u00270 days 00:00:00.000015500\u0027)"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.tseries", "label": "tseries", "shape": "dot", "size": 20, "title": "NAME: tseries\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.unique", "label": "unique", "shape": "dot", "size": 20, "title": "NAME: unique\n------------------------------\nINPUTS: values\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return unique values based on a hash table. Uniques are returned in order of appearance. This does NOT sort. Significantly faster than numpy.unique for long enough sequences. Includes NA values. Parameters ---------- values : 1d array-like Returns ------- numpy.ndarray or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.unique(pd.Series([2, 1, 3, 3]))\narray([2, 1, 3])"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.util", "label": "util", "shape": "dot", "size": 20, "title": "NAME: util\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.value_counts", "label": "value_counts", "shape": "dot", "size": 20, "title": "NAME: value_counts\n------------------------------\nINPUTS: values, sort, ascending, normalize, bins, dropna\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Compute a histogram of the counts of non-null values. Parameters ---------- values : ndarray (1-d) sort : bool, default True Sort by values ascending : bool, default False Sort in ascending order normalize: bool, default False If True then compute...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.wide_to_long", "label": "wide_to_long", "shape": "dot", "size": 20, "title": "NAME: wide_to_long\n------------------------------\nINPUTS: df, stubnames, i, j, sep, suffix\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Unpivot a DataFrame from wide to long format. Less flexible but more user-friendly than melt. With stubnames [\u0027A\u0027, \u0027B\u0027], this function expects to find one or more group of columns with format A-suffix1, A-suffix2,..., B-suffix1, B-suffix2,... You specify what you...\n\n\nEXAMPLE:\n\u003e\u003e\u003e np.random.seed(123)\n\u003e\u003e\u003e df = pd.DataFrame({\"A1970\" : {0 : \"a\", 1 : \"b\", 2 : \"c\"},\n...                    \"A1980\" : {0 : \"d\", 1 : \"e\", 2 : \"f\"},\n...                    \"B1970\" : {0 : 2.5, 1 : 1.2, 2 : .7},\n...                    \"B1980\" : {0 : 3.2, 1 : 1.3, 2 : .1},\n...                    \"X\"     : dict(zip(range(3), np.random.randn(3)))\n...                   })\n\u003e\u003e\u003e df[\"id\"] = df.index\n\u003e\u003e\u003e df\n  A1970 A1980  B1970  B1980         X  id\n0     a     d    2.5    3.2 -1.085631   0\n1     b     e    1.2    1.3  0.997345   1\n2     c     f    0.7    0.1  0.282978   2\n\u003e\u003e\u003e pd.wide_to_long(df, [\"A\", \"B\"], i=\"id\", j=\"year\")\n... # doctest: +NORMALIZE_WHITESPACE\n                X  A    B\nid year\n0  1970 -1.085631  a  2.5\n1  1970  0.997345  b  1.2\n2  1970  0.282978  c  0.7\n0  1980 -1.085631  d  3.2\n1  1980  0.997345  e  1.3\n2  1980  0.282978  f  0.1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.ArrowDtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: \nOUTPUTS: type_t[ArrowExtensionArray]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.ArrowDtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: ArrowDtype\n------------------------------\nDESCRIPTION: Construct this type from a string. Parameters ---------- string : str string should follow the format f\"{pyarrow_type}[pyarrow]\" e.g. int64[pyarrow]...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.ArrowDtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.ArrowDtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if we match \u0027dtype\u0027. Parameters ---------- dtype : object The object to check. Returns ------- bool Notes ----- The default implementation is True if 1. ``cls.construct_from_string(dtype)`` is an instance of ``cls``. 2. ``dtype`` is an object and is an...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.BooleanDtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: \nOUTPUTS: type_t[BooleanArray]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.BooleanDtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Construct this type from a string. This is useful mainly for data types that accept parameters. For example, a period dtype accepts a frequency parameter that can be set as ``period[h]`` (where H means hourly frequency). By default, in the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import re\n\u003e\u003e\u003e @classmethod\n... def construct_from_string(cls, string):\n...     pattern = re.compile(r\"^my_type\\[(?P\u003carg_name\u003e.+)\\]$\")\n...     match = pattern.match(string)\n...     if match:\n...         return cls(**match.groupdict())\n...     else:\n...         raise TypeError(\n...             f\"Cannot construct a \u0027{cls.__name__}\u0027 from \u0027{string}\u0027\"\n...         )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.BooleanDtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.BooleanDtype.from_numpy_dtype", "label": "from_numpy_dtype", "shape": "dot", "size": 20, "title": "NAME: from_numpy_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: BaseMaskedDtype\n------------------------------\nDESCRIPTION: Construct the MaskedDtype corresponding to the given numpy dtype....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.BooleanDtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if we match \u0027dtype\u0027. Parameters ---------- dtype : object The object to check. Returns ------- bool Notes ----- The default implementation is True if 1. ``cls.construct_from_string(dtype)`` is an instance of ``cls``. 2. ``dtype`` is an object and is an...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.add_categories", "label": "add_categories", "shape": "dot", "size": 20, "title": "NAME: add_categories\n------------------------------\nINPUTS: self, new_categories\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Add new categories. `new_categories` will be included at the last/highest place in the categories and will be unused directly after this call. Parameters ---------- new_categories : category or list-like of category The new categories to be included. Returns ------- Categorical...\n\n\nEXAMPLE:\n\u003e\u003e\u003e c = pd.Categorical([\u0027c\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e c\n[\u0027c\u0027, \u0027b\u0027, \u0027c\u0027]\nCategories (2, object): [\u0027b\u0027, \u0027c\u0027]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.argmax", "label": "argmax", "shape": "dot", "size": 20, "title": "NAME: argmax\n------------------------------\nINPUTS: self, axis, skipna\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the index of maximum value. In case of multiple occurrences of the maximum value, the index corresponding to the first occurrence is returned. Parameters ---------- skipna : bool, default True Returns ------- int See Also -------- ExtensionArray.argmin : Return...\n\n\nEXAMPLE:\n\u003e\u003e\u003e arr = pd.array([3, 1, 2, 5, 4])\n\u003e\u003e\u003e arr.argmax()\n3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.argmin", "label": "argmin", "shape": "dot", "size": 20, "title": "NAME: argmin\n------------------------------\nINPUTS: self, axis, skipna\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the index of minimum value. In case of multiple occurrences of the minimum value, the index corresponding to the first occurrence is returned. Parameters ---------- skipna : bool, default True Returns ------- int See Also -------- ExtensionArray.argmax : Return...\n\n\nEXAMPLE:\n\u003e\u003e\u003e arr = pd.array([3, 1, 2, 5, 4])\n\u003e\u003e\u003e arr.argmin()\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.argsort", "label": "argsort", "shape": "dot", "size": 20, "title": "NAME: argsort\n------------------------------\nINPUTS: self, ascending, kind, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the indices that would sort the Categorical. Missing values are sorted at the end. Parameters ---------- ascending : bool, default True Whether the indices should result in an ascending or descending sort. kind : {\u0027quicksort\u0027, \u0027mergesort\u0027, \u0027heapsort\u0027, \u0027stable\u0027}, optional...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Categorical([\u0027b\u0027, \u0027b\u0027, \u0027a\u0027, \u0027c\u0027]).argsort()\narray([2, 0, 1, 3])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.as_ordered", "label": "as_ordered", "shape": "dot", "size": 20, "title": "NAME: as_ordered\n------------------------------\nINPUTS: self\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Set the Categorical to be ordered. Returns ------- Categorical Ordered Categorical. Examples -------- For :class:`pandas.Series`: \u003e\u003e\u003e ser = pd.Series([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027a\u0027], dtype=\u0027category\u0027) \u003e\u003e\u003e ser.cat.ordered False \u003e\u003e\u003e ser = ser.cat.as_ordered() \u003e\u003e\u003e ser.cat.ordered True For :class:`pandas.CategoricalIndex`: \u003e\u003e\u003e ci = pd.CategoricalIndex([\u0027a\u0027, \u0027b\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027a\u0027], dtype=\u0027category\u0027)\n\u003e\u003e\u003e ser.cat.ordered\nFalse\n\u003e\u003e\u003e ser = ser.cat.as_ordered()\n\u003e\u003e\u003e ser.cat.ordered\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.as_unordered", "label": "as_unordered", "shape": "dot", "size": 20, "title": "NAME: as_unordered\n------------------------------\nINPUTS: self\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Set the Categorical to be unordered. Returns ------- Categorical Unordered Categorical. Examples -------- For :class:`pandas.Series`: \u003e\u003e\u003e raw_cat = pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027a\u0027], ordered=True) \u003e\u003e\u003e ser = pd.Series(raw_cat) \u003e\u003e\u003e ser.cat.ordered True \u003e\u003e\u003e ser = ser.cat.as_unordered() \u003e\u003e\u003e ser.cat.ordered False For :class:`pandas.CategoricalIndex`: \u003e\u003e\u003e...\n\n\nEXAMPLE:\n\u003e\u003e\u003e raw_cat = pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027a\u0027], ordered=True)\n\u003e\u003e\u003e ser = pd.Series(raw_cat)\n\u003e\u003e\u003e ser.cat.ordered\nTrue\n\u003e\u003e\u003e ser = ser.cat.as_unordered()\n\u003e\u003e\u003e ser.cat.ordered\nFalse"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.astype", "label": "astype", "shape": "dot", "size": 20, "title": "NAME: astype\n------------------------------\nINPUTS: self, dtype, copy\nOUTPUTS: ArrayLike\n------------------------------\nDESCRIPTION: Coerce this type to another dtype Parameters ---------- dtype : numpy dtype or pandas type copy : bool, default True By default, astype always returns a newly allocated object. If copy is set to False and dtype is categorical, the...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.check_for_ordered", "label": "check_for_ordered", "shape": "dot", "size": 20, "title": "NAME: check_for_ordered\n------------------------------\nINPUTS: self, op\nOUTPUTS: None\n------------------------------\nDESCRIPTION: assert that we are ordered...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.describe", "label": "describe", "shape": "dot", "size": 20, "title": "NAME: describe\n------------------------------\nINPUTS: self\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Describes this Categorical Returns ------- description: `DataFrame` A dataframe with frequency and counts by category....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.dropna", "label": "dropna", "shape": "dot", "size": 20, "title": "NAME: dropna\n------------------------------\nINPUTS: self\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return ExtensionArray without NA values. Returns ------- Examples -------- \u003e\u003e\u003e pd.array([1, 2, np.nan]).dropna() \u003cIntegerArray\u003e [1, 2] Length: 2, dtype: Int64...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.array([1, 2, np.nan]).dropna()\n\u003cIntegerArray\u003e\n[1, 2]\nLength: 2, dtype: Int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.duplicated", "label": "duplicated", "shape": "dot", "size": 20, "title": "NAME: duplicated\n------------------------------\nINPUTS: self, keep\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Return boolean ndarray denoting duplicate values. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, False}, default \u0027first\u0027 - ``first`` : Mark duplicates as ``True`` except for the first occurrence. - ``last`` : Mark duplicates as ``True`` except for the last occurrence. -...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.array([1, 1, 2, 3, 3], dtype=\"Int64\").duplicated()\narray([False,  True, False, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.equals", "label": "equals", "shape": "dot", "size": 20, "title": "NAME: equals\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Returns True if categorical arrays are equal. Parameters ---------- other : `Categorical` Returns ------- bool...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.factorize", "label": "factorize", "shape": "dot", "size": 20, "title": "NAME: factorize\n------------------------------\nINPUTS: self, use_na_sentinel\nOUTPUTS: tuple[np.ndarray, ExtensionArray]\n------------------------------\nDESCRIPTION: Encode the extension array as an enumerated type. Parameters ---------- use_na_sentinel : bool, default True If True, the sentinel -1 will be used for NaN values. If False, NaN values will be encoded as non-negative integers and will not drop...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.PeriodIndex([\"2014-01\", \"2014-01\", \"2014-02\", \"2014-02\",\n...                       \"2014-03\", \"2014-03\"], freq=\"M\")\n\u003e\u003e\u003e arr, idx = idx1.factorize()\n\u003e\u003e\u003e arr\narray([0, 0, 1, 1, 2, 2])\n\u003e\u003e\u003e idx\nPeriodIndex([\u00272014-01\u0027, \u00272014-02\u0027, \u00272014-03\u0027], dtype=\u0027period[M]\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.fillna", "label": "fillna", "shape": "dot", "size": 20, "title": "NAME: fillna\n------------------------------\nINPUTS: self, value, method, limit, copy\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Fill NA/NaN values using the specified method. Parameters ---------- value : scalar, array-like If a scalar value is passed it is used to fill all missing values. Alternatively, an array-like \"value\" can be given. It\u0027s expected that the array-like have...\n\n\nEXAMPLE:\n\u003e\u003e\u003e arr = pd.array([np.nan, np.nan, 2, 3, np.nan, np.nan])\n\u003e\u003e\u003e arr.fillna(0)\n\u003cIntegerArray\u003e\n[0, 0, 2, 3, 0, 0]\nLength: 6, dtype: Int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.from_codes", "label": "from_codes", "shape": "dot", "size": 20, "title": "NAME: from_codes\n------------------------------\nINPUTS: codes, categories, ordered, dtype, validate\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make a Categorical type from codes and categories or dtype. This constructor is useful if you already have codes and categories/dtype and so do not need the (computation intensive) factorization step, which is usually done on the constructor. If your...\n\n\nEXAMPLE:\n\u003e\u003e\u003e dtype = pd.CategoricalDtype([\u0027a\u0027, \u0027b\u0027], ordered=True)\n\u003e\u003e\u003e pd.Categorical.from_codes(codes=[0, 1, 0, 1], dtype=dtype)\n[\u0027a\u0027, \u0027b\u0027, \u0027a\u0027, \u0027b\u0027]\nCategories (2, object): [\u0027a\u0027 \u003c \u0027b\u0027]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.insert", "label": "insert", "shape": "dot", "size": 20, "title": "NAME: insert\n------------------------------\nINPUTS: self, loc, item\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make new ExtensionArray inserting new item at location. Follows Python list.append semantics for negative values. Parameters ---------- loc : int item : object Returns ------- type(self)...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.interpolate", "label": "interpolate", "shape": "dot", "size": 20, "title": "NAME: interpolate\n------------------------------\nINPUTS: self, method, axis, index, limit, limit_direction, limit_area, copy, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: See DataFrame.interpolate.__doc__. Examples -------- \u003e\u003e\u003e arr = pd.arrays.NumpyExtensionArray(np.array([0, 1, np.nan, 3])) \u003e\u003e\u003e arr.interpolate(method=\"linear\", ... limit=3, ... limit_direction=\"forward\", ... index=pd.Index([1, 2, 3, 4]), ... fill_value=1, ... copy=False, ... axis=0, ... limit_area=\"inside\" ... ) \u003cNumpyExtensionArray\u003e [0.0, 1.0, 2.0, 3.0] Length: 4, dtype:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e arr = pd.arrays.NumpyExtensionArray(np.array([0, 1, np.nan, 3]))\n\u003e\u003e\u003e arr.interpolate(method=\"linear\",\n...                 limit=3,\n...                 limit_direction=\"forward\",\n...                 index=pd.Index([1, 2, 3, 4]),\n...                 fill_value=1,\n...                 copy=False,\n...                 axis=0,\n...                 limit_area=\"inside\"\n...                 )\n\u003cNumpyExtensionArray\u003e\n[0.0, 1.0, 2.0, 3.0]\nLength: 4, dtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.isin", "label": "isin", "shape": "dot", "size": 20, "title": "NAME: isin\n------------------------------\nINPUTS: self, values\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Check whether `values` are contained in Categorical. Return a boolean NumPy Array showing whether each element in the Categorical matches an element in the passed sequence of `values` exactly. Parameters ---------- values : np.ndarray or ExtensionArray The sequence of values...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Categorical([\u0027lama\u0027, \u0027cow\u0027, \u0027lama\u0027, \u0027beetle\u0027, \u0027lama\u0027,\n...                \u0027hippo\u0027])\n\u003e\u003e\u003e s.isin([\u0027cow\u0027, \u0027lama\u0027])\narray([ True,  True,  True, False,  True, False])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.isna", "label": "isna", "shape": "dot", "size": 20, "title": "NAME: isna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values Missing values (-1 in .codes) are detected. Returns ------- np.ndarray[bool] of whether my values are null See Also -------- isna : Top-level isna. isnull : Alias of isna. Categorical.notna : Boolean inverse of Categorical.isna....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.isnull", "label": "isnull", "shape": "dot", "size": 20, "title": "NAME: isnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values Missing values (-1 in .codes) are detected. Returns ------- np.ndarray[bool] of whether my values are null See Also -------- isna : Top-level isna. isnull : Alias of isna. Categorical.notna : Boolean inverse of Categorical.isna....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.map", "label": "map", "shape": "dot", "size": 20, "title": "NAME: map\n------------------------------\nINPUTS: self, mapper, na_action\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Map categories using an input mapping or function. Maps the categories to new categories. If the mapping correspondence is one-to-one the result is a :class:`~pandas.Categorical` which has the same order property as the original, otherwise a :class:`~pandas.Index` is returned. NaN...\n\n\nEXAMPLE:\n\u003e\u003e\u003e cat = pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e cat\n[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]\nCategories (3, object): [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]\n\u003e\u003e\u003e cat.map(lambda x: x.upper(), na_action=None)\n[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027]\nCategories (3, object): [\u0027A\u0027, \u0027B\u0027, \u0027C\u0027]\n\u003e\u003e\u003e cat.map({\u0027a\u0027: \u0027first\u0027, \u0027b\u0027: \u0027second\u0027, \u0027c\u0027: \u0027third\u0027}, na_action=None)\n[\u0027first\u0027, \u0027second\u0027, \u0027third\u0027]\nCategories (3, object): [\u0027first\u0027, \u0027second\u0027, \u0027third\u0027]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.max", "label": "max", "shape": "dot", "size": 20, "title": "NAME: max\n------------------------------\nINPUTS: self, skipna, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: The maximum value of the object. Only ordered `Categoricals` have a maximum! Raises ------ TypeError If the `Categorical` is not `ordered`. Returns ------- max : the maximum of this `Categorical`, NA if array is empty...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.memory_usage", "label": "memory_usage", "shape": "dot", "size": 20, "title": "NAME: memory_usage\n------------------------------\nINPUTS: self, deep\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Memory usage of my values Parameters ---------- deep : bool Introspect the data deeply, interrogate `object` dtypes for system-level memory consumption Returns ------- bytes used Notes ----- Memory usage does not include memory consumed by elements that are not components...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.min", "label": "min", "shape": "dot", "size": 20, "title": "NAME: min\n------------------------------\nINPUTS: self, skipna, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: The minimum value of the object. Only ordered `Categoricals` have a minimum! Raises ------ TypeError If the `Categorical` is not `ordered`. Returns ------- min : the minimum of this `Categorical`, NA value if empty...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.notna", "label": "notna", "shape": "dot", "size": 20, "title": "NAME: notna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Inverse of isna Both missing values (-1 in .codes) and NA as a category are detected as null. Returns ------- np.ndarray[bool] of whether my values are not null See Also -------- notna : Top-level notna. notnull : Alias of notna....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.notnull", "label": "notnull", "shape": "dot", "size": 20, "title": "NAME: notnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Inverse of isna Both missing values (-1 in .codes) and NA as a category are detected as null. Returns ------- np.ndarray[bool] of whether my values are not null See Also -------- notna : Top-level notna. notnull : Alias of notna....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.remove_categories", "label": "remove_categories", "shape": "dot", "size": 20, "title": "NAME: remove_categories\n------------------------------\nINPUTS: self, removals\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Remove the specified categories. `removals` must be included in the old categories. Values which were in the removed categories will be set to NaN Parameters ---------- removals : category or list of categories The categories which should be removed. Returns...\n\n\nEXAMPLE:\n\u003e\u003e\u003e c = pd.Categorical([\u0027a\u0027, \u0027c\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e c\n[\u0027a\u0027, \u0027c\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027]\nCategories (4, object): [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.remove_unused_categories", "label": "remove_unused_categories", "shape": "dot", "size": 20, "title": "NAME: remove_unused_categories\n------------------------------\nINPUTS: self\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Remove categories which are not used. Returns ------- Categorical Categorical with unused categories dropped. See Also -------- rename_categories : Rename categories. reorder_categories : Reorder categories. add_categories : Add new categories. remove_categories : Remove the specified categories. set_categories : Set the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e c = pd.Categorical([\u0027a\u0027, \u0027c\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e c\n[\u0027a\u0027, \u0027c\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027]\nCategories (4, object): [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.rename_categories", "label": "rename_categories", "shape": "dot", "size": 20, "title": "NAME: rename_categories\n------------------------------\nINPUTS: self, new_categories\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Rename categories. Parameters ---------- new_categories : list-like, dict-like or callable New categories which will replace old categories. * list-like: all items must be unique and the number of items in the new categories must match the existing number of categories....\n\n\nEXAMPLE:\n\u003e\u003e\u003e c = pd.Categorical([\u0027a\u0027, \u0027a\u0027, \u0027b\u0027])\n\u003e\u003e\u003e c.rename_categories([0, 1])\n[0, 0, 1]\nCategories (2, int64): [0, 1]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.reorder_categories", "label": "reorder_categories", "shape": "dot", "size": 20, "title": "NAME: reorder_categories\n------------------------------\nINPUTS: self, new_categories, ordered\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Reorder categories as specified in new_categories. ``new_categories`` need to include all old categories and no new category items. Parameters ---------- new_categories : Index-like The categories in new order. ordered : bool, optional Whether or not the categorical is treated as...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027a\u0027], dtype=\u0027category\u0027)\n\u003e\u003e\u003e ser = ser.cat.reorder_categories([\u0027c\u0027, \u0027b\u0027, \u0027a\u0027], ordered=True)\n\u003e\u003e\u003e ser\n0   a\n1   b\n2   c\n3   a\ndtype: category\nCategories (3, object): [\u0027c\u0027 \u003c \u0027b\u0027 \u003c \u0027a\u0027]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.searchsorted", "label": "searchsorted", "shape": "dot", "size": 20, "title": "NAME: searchsorted\n------------------------------\nINPUTS: self, value, side, sorter\nOUTPUTS: npt.NDArray[np.intp] | np.intp\n------------------------------\nDESCRIPTION: Find indices where elements should be inserted to maintain order. Find the indices into a sorted array `self` (a) such that, if the corresponding elements in `value` were inserted before the indices, the order of `self` would be preserved. Assuming...\n\n\nEXAMPLE:\n\u003e\u003e\u003e arr = pd.array([1, 2, 3, 5])\n\u003e\u003e\u003e arr.searchsorted([4])\narray([3])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.set_categories", "label": "set_categories", "shape": "dot", "size": 20, "title": "NAME: set_categories\n------------------------------\nINPUTS: self, new_categories, ordered, rename\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Set the categories to the specified new categories. ``new_categories`` can include new categories (which will result in unused categories) or remove old categories (which results in values set to ``NaN``). If ``rename=True``, the categories will simply be renamed (less or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e raw_cat = pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027A\u0027],\n...                           categories=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], ordered=True)\n\u003e\u003e\u003e ser = pd.Series(raw_cat)\n\u003e\u003e\u003e ser\n0   a\n1   b\n2   c\n3   NaN\ndtype: category\nCategories (3, object): [\u0027a\u0027 \u003c \u0027b\u0027 \u003c \u0027c\u0027]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.set_ordered", "label": "set_ordered", "shape": "dot", "size": 20, "title": "NAME: set_ordered\n------------------------------\nINPUTS: self, value\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Set the ordered attribute to the boolean value. Parameters ---------- value : bool Set whether this categorical is ordered (True) or not (False)....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.shift", "label": "shift", "shape": "dot", "size": 20, "title": "NAME: shift\n------------------------------\nINPUTS: self, periods, fill_value\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Shift values by desired number. Newly introduced missing values are filled with ``self.dtype.na_value``. Parameters ---------- periods : int, default 1 The number of periods to shift. Negative values are allowed for shifting backwards. fill_value : object, optional The scalar value...\n\n\nEXAMPLE:\n\u003e\u003e\u003e arr = pd.array([1, 2, 3])\n\u003e\u003e\u003e arr.shift(2)\n\u003cIntegerArray\u003e\n[\u003cNA\u003e, \u003cNA\u003e, 1]\nLength: 3, dtype: Int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.sort_values", "label": "sort_values", "shape": "dot", "size": 20, "title": "NAME: sort_values\n------------------------------\nINPUTS: self, inplace, ascending, na_position\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Sort the Categorical by category value returning a new Categorical by default. While an ordering is applied to the category values, sorting in this context refers more to organizing and grouping together based on matching category values. Thus, this function...\n\n\nEXAMPLE:\n\u003e\u003e\u003e c = pd.Categorical([1, 2, 2, 1, 5])\n\u003e\u003e\u003e c\n[1, 2, 2, 1, 5]\nCategories (3, int64): [1, 2, 5]\n\u003e\u003e\u003e c.sort_values()\n[1, 1, 2, 2, 5]\nCategories (3, int64): [1, 2, 5]\n\u003e\u003e\u003e c.sort_values(ascending=False)\n[5, 2, 2, 1, 1]\nCategories (3, int64): [1, 2, 5]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.take", "label": "take", "shape": "dot", "size": 20, "title": "NAME: take\n------------------------------\nINPUTS: self, indices, allow_fill, fill_value, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Take elements from an array. Parameters ---------- indices : sequence of int or one-dimensional np.ndarray of int Indices to be taken. allow_fill : bool, default False How to handle negative values in `indices`. * False: negative values in `indices` indicate...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.to_list", "label": "to_list", "shape": "dot", "size": 20, "title": "NAME: to_list\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Alias for tolist....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.to_numpy", "label": "to_numpy", "shape": "dot", "size": 20, "title": "NAME: to_numpy\n------------------------------\nINPUTS: self, dtype, copy, na_value\nOUTPUTS: np.ndarray\n------------------------------\nDESCRIPTION: Convert to a NumPy ndarray. This is similar to :meth:`numpy.asarray`, but may provide additional control over how the conversion is done. Parameters ---------- dtype : str or numpy.dtype, optional The dtype to pass to :meth:`numpy.asarray`. copy : bool, default False...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.tolist", "label": "tolist", "shape": "dot", "size": 20, "title": "NAME: tolist\n------------------------------\nINPUTS: self\nOUTPUTS: list\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list Examples -------- \u003e\u003e\u003e arr = pd.array([1, 2, 3]) \u003e\u003e\u003e arr.tolist()...\n\n\nEXAMPLE:\n\u003e\u003e\u003e arr = pd.array([1, 2, 3])\n\u003e\u003e\u003e arr.tolist()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.unique", "label": "unique", "shape": "dot", "size": 20, "title": "NAME: unique\n------------------------------\nINPUTS: self\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return the ``Categorical`` which ``categories`` and ``codes`` are unique. .. versionchanged:: 1.3.0 Previously, unused categories were dropped from the new categories. Returns ------- Categorical See Also -------- pandas.unique CategoricalIndex.unique Series.unique : Return unique values of Series object. Examples -------- \u003e\u003e\u003e...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Categorical(list(\"baabc\")).unique()\n[\u0027b\u0027, \u0027a\u0027, \u0027c\u0027]\nCategories (3, object): [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]\n\u003e\u003e\u003e pd.Categorical(list(\"baab\"), categories=list(\"abc\"), ordered=True).unique()\n[\u0027b\u0027, \u0027a\u0027]\nCategories (3, object): [\u0027a\u0027 \u003c \u0027b\u0027 \u003c \u0027c\u0027]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.value_counts", "label": "value_counts", "shape": "dot", "size": 20, "title": "NAME: value_counts\n------------------------------\nINPUTS: self, dropna\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return a Series containing counts of each category. Every category will have an entry, even those with a count of 0. Parameters ---------- dropna : bool, default True Don\u0027t include counts of NaN. Returns ------- counts : Series See Also...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Categorical.view", "label": "view", "shape": "dot", "size": 20, "title": "NAME: view\n------------------------------\nINPUTS: self, dtype\nOUTPUTS: ArrayLike\n------------------------------\nDESCRIPTION: Return a view on the array. Parameters ---------- dtype : str, np.dtype, or ExtensionDtype, optional Default None. Returns ------- ExtensionArray or np.ndarray A view on the :class:`ExtensionArray`\u0027s data. Examples -------- This gives view on the underlying data of an ``ExtensionArray``...\n\n\nEXAMPLE:\n\u003e\u003e\u003e arr = pd.array([1, 2, 3])\n\u003e\u003e\u003e arr2 = arr.view()\n\u003e\u003e\u003e arr[0] = 2\n\u003e\u003e\u003e arr2\n\u003cIntegerArray\u003e\n[2, 2, 3]\nLength: 3, dtype: Int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalDtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: \nOUTPUTS: type_t[Categorical]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalDtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: CategoricalDtype\n------------------------------\nDESCRIPTION: Construct a CategoricalDtype from a string. Parameters ---------- string : str Must be the string \"category\" in order to be successfully constructed. Returns ------- CategoricalDtype Instance of the dtype. Raises ------ TypeError If a CategoricalDtype cannot be constructed from the...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalDtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalDtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if we match \u0027dtype\u0027. Parameters ---------- dtype : object The object to check. Returns ------- bool Notes ----- The default implementation is True if 1. ``cls.construct_from_string(dtype)`` is an instance of ``cls``. 2. ``dtype`` is an object and is an...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalDtype.reset_cache", "label": "reset_cache", "shape": "dot", "size": 20, "title": "NAME: reset_cache\n------------------------------\nINPUTS: \nOUTPUTS: None\n------------------------------\nDESCRIPTION: clear the cache...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.CategoricalDtype.type", "label": "type", "shape": "dot", "size": 20, "title": "NAME: type\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: the type of CategoricalDtype, this metaclass determines subclass ability...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalDtype.update_dtype", "label": "update_dtype", "shape": "dot", "size": 20, "title": "NAME: update_dtype\n------------------------------\nINPUTS: self, dtype\nOUTPUTS: CategoricalDtype\n------------------------------\nDESCRIPTION: Returns a CategoricalDtype with categories and ordered taken from dtype if specified, otherwise falling back to self if unspecified Parameters ---------- dtype : CategoricalDtype Returns ------- new_dtype : CategoricalDtype...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalDtype.validate_categories", "label": "validate_categories", "shape": "dot", "size": 20, "title": "NAME: validate_categories\n------------------------------\nINPUTS: categories, fastpath\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Validates that we have good categories Parameters ---------- categories : array-like fastpath : bool Whether to skip nan and uniqueness checks Returns ------- categories : Index...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalDtype.validate_ordered", "label": "validate_ordered", "shape": "dot", "size": 20, "title": "NAME: validate_ordered\n------------------------------\nINPUTS: ordered\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Validates that we have a valid ordered parameter. If it is not a boolean, a TypeError will be raised. Parameters ---------- ordered : object The parameter to be verified. Raises ------ TypeError If \u0027ordered\u0027 is not a boolean....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.add_categories", "label": "add_categories", "shape": "dot", "size": 20, "title": "NAME: add_categories\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Add new categories. `new_categories` will be included at the last/highest place in the categories and will be unused directly after this call. Parameters ---------- new_categories : category or list-like of category The new categories to be included. Returns ------- Categorical...\n\n\nEXAMPLE:\n\u003e\u003e\u003e c = pd.Categorical([\u0027c\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e c\n[\u0027c\u0027, \u0027b\u0027, \u0027c\u0027]\nCategories (2, object): [\u0027b\u0027, \u0027c\u0027]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.all", "label": "all", "shape": "dot", "size": 20, "title": "NAME: all\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return whether all elements are Truthy. Parameters ---------- *args Required for compatibility with numpy. **kwargs Required for compatibility with numpy. Returns ------- bool or array-like (if axis is specified) A single element array-like may be converted to bool. See Also...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Index([1, 2, 3]).all()\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.any", "label": "any", "shape": "dot", "size": 20, "title": "NAME: any\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return whether any element is Truthy. Parameters ---------- *args Required for compatibility with numpy. **kwargs Required for compatibility with numpy. Returns ------- bool or array-like (if axis is specified) A single element array-like may be converted to bool. See Also...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([0, 1, 2])\n\u003e\u003e\u003e index.any()\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.append", "label": "append", "shape": "dot", "size": 20, "title": "NAME: append\n------------------------------\nINPUTS: self, other\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Append a collection of Index options together. Parameters ---------- other : Index or list/tuple of indices Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([1, 2, 3]) \u003e\u003e\u003e idx.append(pd.Index([4])) Index([1, 2, 3, 4], dtype=\u0027int64\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.append(pd.Index([4]))\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.argmax", "label": "argmax", "shape": "dot", "size": 20, "title": "NAME: argmax\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the largest value in the Series. If the maximum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.argmin", "label": "argmin", "shape": "dot", "size": 20, "title": "NAME: argmin\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the smallest value in the Series. If the minimum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.argsort", "label": "argsort", "shape": "dot", "size": 20, "title": "NAME: argsort\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the indices that would sort the Categorical. Missing values are sorted at the end. Parameters ---------- ascending : bool, default True Whether the indices should result in an ascending or descending sort. kind : {\u0027quicksort\u0027, \u0027mergesort\u0027, \u0027heapsort\u0027, \u0027stable\u0027}, optional...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Categorical([\u0027b\u0027, \u0027b\u0027, \u0027a\u0027, \u0027c\u0027]).argsort()\narray([2, 0, 1, 3])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.as_ordered", "label": "as_ordered", "shape": "dot", "size": 20, "title": "NAME: as_ordered\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Set the Categorical to be ordered. Returns ------- Categorical Ordered Categorical. Examples -------- For :class:`pandas.Series`: \u003e\u003e\u003e ser = pd.Series([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027a\u0027], dtype=\u0027category\u0027) \u003e\u003e\u003e ser.cat.ordered False \u003e\u003e\u003e ser = ser.cat.as_ordered() \u003e\u003e\u003e ser.cat.ordered True For :class:`pandas.CategoricalIndex`: \u003e\u003e\u003e ci = pd.CategoricalIndex([\u0027a\u0027, \u0027b\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027a\u0027], dtype=\u0027category\u0027)\n\u003e\u003e\u003e ser.cat.ordered\nFalse\n\u003e\u003e\u003e ser = ser.cat.as_ordered()\n\u003e\u003e\u003e ser.cat.ordered\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.as_unordered", "label": "as_unordered", "shape": "dot", "size": 20, "title": "NAME: as_unordered\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Set the Categorical to be unordered. Returns ------- Categorical Unordered Categorical. Examples -------- For :class:`pandas.Series`: \u003e\u003e\u003e raw_cat = pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027a\u0027], ordered=True) \u003e\u003e\u003e ser = pd.Series(raw_cat) \u003e\u003e\u003e ser.cat.ordered True \u003e\u003e\u003e ser = ser.cat.as_unordered() \u003e\u003e\u003e ser.cat.ordered False For :class:`pandas.CategoricalIndex`: \u003e\u003e\u003e...\n\n\nEXAMPLE:\n\u003e\u003e\u003e raw_cat = pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027a\u0027], ordered=True)\n\u003e\u003e\u003e ser = pd.Series(raw_cat)\n\u003e\u003e\u003e ser.cat.ordered\nTrue\n\u003e\u003e\u003e ser = ser.cat.as_unordered()\n\u003e\u003e\u003e ser.cat.ordered\nFalse"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.asof", "label": "asof", "shape": "dot", "size": 20, "title": "NAME: asof\n------------------------------\nINPUTS: self, label\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the label from the index, or, if not present, the previous one. Assuming that the index is sorted, return the passed index label if it is in the index, or return the previous index label if the passed one...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u00272013-12-31\u0027, \u00272014-01-02\u0027, \u00272014-01-03\u0027])\n\u003e\u003e\u003e idx.asof(\u00272014-01-01\u0027)\n\u00272013-12-31\u0027"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.asof_locs", "label": "asof_locs", "shape": "dot", "size": 20, "title": "NAME: asof_locs\n------------------------------\nINPUTS: self, where, mask\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Return the locations (indices) of labels in the index. As in the :meth:`pandas.Index.asof`, if the label (a particular entry in ``where``) is not in the index, the latest index label up to the passed label is chosen and its index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.date_range(\u00272023-06-01\u0027, periods=3, freq=\u0027D\u0027)\n\u003e\u003e\u003e where = pd.DatetimeIndex([\u00272023-05-30 00:12:00\u0027, \u00272023-06-01 00:00:00\u0027,\n...                           \u00272023-06-02 23:59:59\u0027])\n\u003e\u003e\u003e mask = np.ones(3, dtype=bool)\n\u003e\u003e\u003e idx.asof_locs(where, mask)\narray([-1,  0,  1])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.astype", "label": "astype", "shape": "dot", "size": 20, "title": "NAME: astype\n------------------------------\nINPUTS: self, dtype, copy\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Create an Index with values cast to dtypes. The class of a new Index is determined by dtype. When conversion is impossible, a TypeError exception is raised. Parameters ---------- dtype : numpy dtype or pandas type Note that any signed...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx.astype(\u0027float\u0027)\nIndex([1.0, 2.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.copy", "label": "copy", "shape": "dot", "size": 20, "title": "NAME: copy\n------------------------------\nINPUTS: self, name, deep\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make a copy of this object. Name is set on the new object. Parameters ---------- name : Label, optional Set name for new object. deep : bool, default False Returns ------- Index Index refer to new object which is a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e new_idx = idx.copy()\n\u003e\u003e\u003e idx is new_idx\nFalse"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.delete", "label": "delete", "shape": "dot", "size": 20, "title": "NAME: delete\n------------------------------\nINPUTS: self, loc\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make new Index with passed location(-s) deleted. Parameters ---------- loc : int or list of int Location of item(-s) which will be deleted. Use a list of locations to delete more than one value at the same time. Returns -------...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.delete(1)\nIndex([\u0027a\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.diff", "label": "diff", "shape": "dot", "size": 20, "title": "NAME: diff\n------------------------------\nINPUTS: self, periods\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Computes the difference between consecutive values in the Index object. If periods is greater than 1, computes the difference between values that are `periods` number of positions apart. Parameters ---------- periods : int, optional The number of positions between the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import pandas as pd\n\u003e\u003e\u003e idx = pd.Index([10, 20, 30, 40, 50])\n\u003e\u003e\u003e idx.diff()\nIndex([nan, 10.0, 10.0, 10.0, 10.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.difference", "label": "difference", "shape": "dot", "size": 20, "title": "NAME: difference\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a new Index with elements of index not in `other`. This is the set difference of two Index objects. Parameters ---------- other : Index or array-like sort : bool or None, default None Whether to sort the resulting index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([2, 1, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.difference(idx2)\nIndex([1, 2], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx1.difference(idx2, sort=False)\nIndex([2, 1], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.drop", "label": "drop", "shape": "dot", "size": 20, "title": "NAME: drop\n------------------------------\nINPUTS: self, labels, errors\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Make new Index with passed list of labels deleted. Parameters ---------- labels : array-like or scalar errors : {\u0027ignore\u0027, \u0027raise\u0027}, default \u0027raise\u0027 If \u0027ignore\u0027, suppress error and existing labels are dropped. Returns ------- Index Will be same type as self,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.drop([\u0027a\u0027])\nIndex([\u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.drop_duplicates", "label": "drop_duplicates", "shape": "dot", "size": 20, "title": "NAME: drop_duplicates\n------------------------------\nINPUTS: self, keep\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return Index with duplicate values removed. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, ``False``}, default \u0027first\u0027 - \u0027first\u0027 : Drop duplicates except for the first occurrence. - \u0027last\u0027 : Drop duplicates except for the last occurrence. - ``False`` : Drop all...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027lama\u0027, \u0027cow\u0027, \u0027lama\u0027, \u0027beetle\u0027, \u0027lama\u0027, \u0027hippo\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.droplevel", "label": "droplevel", "shape": "dot", "size": 20, "title": "NAME: droplevel\n------------------------------\nINPUTS: self, level\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return index with requested level(s) removed. If resulting index has only 1 level left, the result will be of Index type, not MultiIndex. The original index is not modified inplace. Parameters ---------- level : int, str, or list-like, default 0...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays(\n... [[1, 2], [3, 4], [5, 6]], names=[\u0027x\u0027, \u0027y\u0027, \u0027z\u0027])\n\u003e\u003e\u003e mi\nMultiIndex([(1, 3, 5),\n            (2, 4, 6)],\n           names=[\u0027x\u0027, \u0027y\u0027, \u0027z\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.dropna", "label": "dropna", "shape": "dot", "size": 20, "title": "NAME: dropna\n------------------------------\nINPUTS: self, how\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return Index without NA/NaN values. Parameters ---------- how : {\u0027any\u0027, \u0027all\u0027}, default \u0027any\u0027 If the Index is a MultiIndex, drop the value when any or all levels are NaN. Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([1, np.nan, 3])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, np.nan, 3])\n\u003e\u003e\u003e idx.dropna()\nIndex([1.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.duplicated", "label": "duplicated", "shape": "dot", "size": 20, "title": "NAME: duplicated\n------------------------------\nINPUTS: self, keep\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Indicate duplicate index values. Duplicated values are indicated as ``True`` values in the resulting array. Either all duplicates, all except the first, or all except the last occurrence of duplicates can be indicated. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, False},...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027lama\u0027, \u0027cow\u0027, \u0027lama\u0027, \u0027beetle\u0027, \u0027lama\u0027])\n\u003e\u003e\u003e idx.duplicated()\narray([False, False,  True, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.equals", "label": "equals", "shape": "dot", "size": 20, "title": "NAME: equals\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Determine if two CategoricalIndex objects contain the same elements. Returns ------- bool ``True`` if two :class:`pandas.CategoricalIndex` objects have equal elements, ``False`` otherwise. Examples -------- \u003e\u003e\u003e ci = pd.CategoricalIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e ci2 = pd.CategoricalIndex(pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027a\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ci = pd.CategoricalIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e ci2 = pd.CategoricalIndex(pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027a\u0027, \u0027b\u0027, \u0027c\u0027]))\n\u003e\u003e\u003e ci.equals(ci2)\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.factorize", "label": "factorize", "shape": "dot", "size": 20, "title": "NAME: factorize\n------------------------------\nINPUTS: self, sort, use_na_sentinel\nOUTPUTS: tuple[npt.NDArray[np.intp], Index]\n------------------------------\nDESCRIPTION: Encode the object as an enumerated type or categorical variable. This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct values. `factorize` is available as both a top-level function :func:`pandas.factorize`, and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e codes, uniques = pd.factorize(np.array([\u0027b\u0027, \u0027b\u0027, \u0027a\u0027, \u0027c\u0027, \u0027b\u0027], dtype=\"O\"))\n\u003e\u003e\u003e codes\narray([0, 0, 1, 2, 0])\n\u003e\u003e\u003e uniques\narray([\u0027b\u0027, \u0027a\u0027, \u0027c\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.fillna", "label": "fillna", "shape": "dot", "size": 20, "title": "NAME: fillna\n------------------------------\nINPUTS: self, value, downcast\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Fill NA/NaN values with the specified value. Parameters ---------- value : scalar Scalar value to use to fill holes (e.g. 0). This value cannot be a list-likes. downcast : dict, default is None A dict of item-\u003edtype of what to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([np.nan, np.nan, 3])\n\u003e\u003e\u003e idx.fillna(0)\nIndex([0.0, 0.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.format", "label": "format", "shape": "dot", "size": 20, "title": "NAME: format\n------------------------------\nINPUTS: self, name, formatter, na_rep\nOUTPUTS: list[str_t]\n------------------------------\nDESCRIPTION: Render a string representation of the Index....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.get_indexer", "label": "get_indexer", "shape": "dot", "size": 20, "title": "NAME: get_indexer\n------------------------------\nINPUTS: self, target, method, limit, tolerance\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Compute indexer and mask for new index given the current index. The indexer should be then used as an input to ndarray.take to align the current data to the new index. Parameters ---------- target : Index method : {None, \u0027pad\u0027/\u0027ffill\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([\u0027c\u0027, \u0027a\u0027, \u0027b\u0027])\n\u003e\u003e\u003e index.get_indexer([\u0027a\u0027, \u0027b\u0027, \u0027x\u0027])\narray([ 1,  2, -1])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.get_indexer_for", "label": "get_indexer_for", "shape": "dot", "size": 20, "title": "NAME: get_indexer_for\n------------------------------\nINPUTS: self, target\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Guaranteed return of an indexer even when non-unique. This dispatches to get_indexer or get_indexer_non_unique as appropriate. Returns ------- np.ndarray[np.intp] List of indices. Examples -------- \u003e\u003e\u003e idx = pd.Index([np.nan, \u0027var1\u0027, np.nan]) \u003e\u003e\u003e idx.get_indexer_for([np.nan]) array([0, 2])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([np.nan, \u0027var1\u0027, np.nan])\n\u003e\u003e\u003e idx.get_indexer_for([np.nan])\narray([0, 2])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.get_indexer_non_unique", "label": "get_indexer_non_unique", "shape": "dot", "size": 20, "title": "NAME: get_indexer_non_unique\n------------------------------\nINPUTS: self, target\nOUTPUTS: tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]\n------------------------------\nDESCRIPTION: Compute indexer and mask for new index given the current index. The indexer should be then used as an input to ndarray.take to align the current data to the new index. Parameters ---------- target : Index Returns ------- indexer :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([\u0027c\u0027, \u0027b\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027])\n\u003e\u003e\u003e index.get_indexer_non_unique([\u0027b\u0027, \u0027b\u0027])\n(array([1, 3, 4, 1, 3, 4]), array([], dtype=int64))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.get_level_values", "label": "get_level_values", "shape": "dot", "size": 20, "title": "NAME: get_level_values\n------------------------------\nINPUTS: self, level\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Return an Index of values for requested level. This is primarily useful to get an individual level of values from a MultiIndex, but is provided on Index as well for compatibility. Parameters ---------- level : int or str It is...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abc\u0027))\n\u003e\u003e\u003e idx\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.get_loc", "label": "get_loc", "shape": "dot", "size": 20, "title": "NAME: get_loc\n------------------------------\nINPUTS: self, key\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Get integer location, slice or boolean mask for requested label. Parameters ---------- key : label Returns ------- int if unique index, slice if monotonic index, else mask Examples -------- \u003e\u003e\u003e unique_index = pd.Index(list(\u0027abc\u0027)) \u003e\u003e\u003e unique_index.get_loc(\u0027b\u0027) 1 \u003e\u003e\u003e monotonic_index = pd.Index(list(\u0027abbc\u0027))...\n\n\nEXAMPLE:\n\u003e\u003e\u003e unique_index = pd.Index(list(\u0027abc\u0027))\n\u003e\u003e\u003e unique_index.get_loc(\u0027b\u0027)\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.get_slice_bound", "label": "get_slice_bound", "shape": "dot", "size": 20, "title": "NAME: get_slice_bound\n------------------------------\nINPUTS: self, label, side\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Calculate slice bound that corresponds to given label. Returns leftmost (one-past-the-rightmost if ``side==\u0027right\u0027``) position of given label. Parameters ---------- label : object side : {\u0027left\u0027, \u0027right\u0027} Returns ------- int Index of label. See Also -------- Index.get_loc : Get integer location,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.RangeIndex(5)\n\u003e\u003e\u003e idx.get_slice_bound(3, \u0027left\u0027)\n3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.groupby", "label": "groupby", "shape": "dot", "size": 20, "title": "NAME: groupby\n------------------------------\nINPUTS: self, values\nOUTPUTS: PrettyDict[Hashable, np.ndarray]\n------------------------------\nDESCRIPTION: Group the index labels by a given array of values. Parameters ---------- values : array Values used to determine the groups. Returns ------- dict {group name -\u003e group labels}...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.holds_integer", "label": "holds_integer", "shape": "dot", "size": 20, "title": "NAME: holds_integer\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Whether the type is an integer type. .. deprecated:: 2.0.0 Use `pandas.api.types.infer_dtype` instead...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.identical", "label": "identical", "shape": "dot", "size": 20, "title": "NAME: identical\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Similar to equals, but checks that object attributes and types are also equal. Returns ------- bool If two Index objects have equal elements and same type True, otherwise False. Examples -------- \u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027]) \u003e\u003e\u003e idx2 =...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx2 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx2.identical(idx1)\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.infer_objects", "label": "infer_objects", "shape": "dot", "size": 20, "title": "NAME: infer_objects\n------------------------------\nINPUTS: self, copy\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: If we have an object dtype, try to infer a non-object dtype. Parameters ---------- copy : bool, default True Whether to make a copy in cases where no inference occurs....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.insert", "label": "insert", "shape": "dot", "size": 20, "title": "NAME: insert\n------------------------------\nINPUTS: self, loc, item\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Make new Index inserting new item at location. Follows Python numpy.insert semantics for negative values. Parameters ---------- loc : int item : object Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e idx.insert(1, \u0027x\u0027) Index([\u0027a\u0027, \u0027x\u0027, \u0027b\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.insert(1, \u0027x\u0027)\nIndex([\u0027a\u0027, \u0027x\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.intersection", "label": "intersection", "shape": "dot", "size": 20, "title": "NAME: intersection\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Form the intersection of two Index objects. This returns a new Index with elements common to the index and `other`. Parameters ---------- other : Index or array-like sort : True, False or None, default False Whether to sort the resulting...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.intersection(idx2)\nIndex([3, 4], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.is_", "label": "is_", "shape": "dot", "size": 20, "title": "NAME: is_\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: More flexible, faster check like ``is`` but that works through views. Note: this is *not* the same as ``Index.identical()``, which checks that metadata is also the same. Parameters ---------- other : object Other object to compare against. Returns ------- bool...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx1.is_(idx1.view())\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.is_boolean", "label": "is_boolean", "shape": "dot", "size": 20, "title": "NAME: is_boolean\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of booleans. .. deprecated:: 2.0.0 Use `pandas.api.types.is_bool_dtype` instead. Returns ------- bool Whether or not the Index only consists of booleans. See Also -------- is_integer : Check if the Index only consists of integers (deprecated)....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([True, False, True])\n\u003e\u003e\u003e idx.is_boolean()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.is_categorical", "label": "is_categorical", "shape": "dot", "size": 20, "title": "NAME: is_categorical\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index holds categorical data. .. deprecated:: 2.0.0 Use `isinstance(index.dtype, pd.CategoricalDtype)` instead. Returns ------- bool True if the Index is categorical. See Also -------- CategoricalIndex : Index for categorical data. is_boolean : Check if the Index only consists...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n...                 \"Watermelon\"]).astype(\"category\")\n\u003e\u003e\u003e idx.is_categorical()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.is_floating", "label": "is_floating", "shape": "dot", "size": 20, "title": "NAME: is_floating\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index is a floating type. .. deprecated:: 2.0.0 Use `pandas.api.types.is_float_dtype` instead The Index may consist of only floats, NaNs, or a mix of floats, integers, or NaNs. Returns ------- bool Whether or not the Index only consists...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n\u003e\u003e\u003e idx.is_floating()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.is_integer", "label": "is_integer", "shape": "dot", "size": 20, "title": "NAME: is_integer\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of integers. .. deprecated:: 2.0.0 Use `pandas.api.types.is_integer_dtype` instead. Returns ------- bool Whether or not the Index only consists of integers. See Also -------- is_boolean : Check if the Index only consists of booleans (deprecated)....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx.is_integer()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.is_interval", "label": "is_interval", "shape": "dot", "size": 20, "title": "NAME: is_interval\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index holds Interval objects. .. deprecated:: 2.0.0 Use `isinstance(index.dtype, pd.IntervalDtype)` instead. Returns ------- bool Whether or not the Index holds Interval objects. See Also -------- IntervalIndex : Index for Interval objects. is_boolean : Check if the Index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([pd.Interval(left=0, right=5),\n...                 pd.Interval(left=5, right=10)])\n\u003e\u003e\u003e idx.is_interval()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.is_numeric", "label": "is_numeric", "shape": "dot", "size": 20, "title": "NAME: is_numeric\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of numeric data. .. deprecated:: 2.0.0 Use `pandas.api.types.is_numeric_dtype` instead. Returns ------- bool Whether or not the Index only consists of numeric data. See Also -------- is_boolean : Check if the Index only consists of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n\u003e\u003e\u003e idx.is_numeric()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.is_object", "label": "is_object", "shape": "dot", "size": 20, "title": "NAME: is_object\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index is of the object dtype. .. deprecated:: 2.0.0 Use `pandas.api.types.is_object_dtype` instead. Returns ------- bool Whether or not the Index is of the object dtype. See Also -------- is_boolean : Check if the Index only consists of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\"Apple\", \"Mango\", \"Watermelon\"])\n\u003e\u003e\u003e idx.is_object()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.isin", "label": "isin", "shape": "dot", "size": 20, "title": "NAME: isin\n------------------------------\nINPUTS: self, values, level\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Return a boolean array where the index values are in `values`. Compute boolean array of whether each index value is found in the passed set of values. The length of the returned boolean array matches the length of the index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1,2,3])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.isna", "label": "isna", "shape": "dot", "size": 20, "title": "NAME: isna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get mapped to ``True`` values. Everything else get mapped to ``False`` values. Characters such as empty strings `\u0027\u0027`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.isna()\narray([False, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.isnull", "label": "isnull", "shape": "dot", "size": 20, "title": "NAME: isnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get mapped to ``True`` values. Everything else get mapped to ``False`` values. Characters such as empty strings `\u0027\u0027`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.isna()\narray([False, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.item", "label": "item", "shape": "dot", "size": 20, "title": "NAME: item\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the first element of the underlying data as a Python scalar. Returns ------- scalar The first element of Series or Index. Raises ------ ValueError If the data is not length = 1. Examples -------- \u003e\u003e\u003e s = pd.Series([1]) \u003e\u003e\u003e...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1])\n\u003e\u003e\u003e s.item()\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.join", "label": "join", "shape": "dot", "size": 20, "title": "NAME: join\n------------------------------\nINPUTS: self, other, how, level, return_indexers, sort\nOUTPUTS: Index | tuple[Index, npt.NDArray[np.intp] | None, npt.NDArray[np.intp] | None]\n------------------------------\nDESCRIPTION: Compute join_index and indexers to conform data structures to the new index. Parameters ---------- other : Index how : {\u0027left\u0027, \u0027right\u0027, \u0027inner\u0027, \u0027outer\u0027} level : int or level name, default None return_indexers : bool, default False sort : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx2 = pd.Index([4, 5, 6])\n\u003e\u003e\u003e idx1.join(idx2, how=\u0027outer\u0027)\nIndex([1, 2, 3, 4, 5, 6], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.map", "label": "map", "shape": "dot", "size": 20, "title": "NAME: map\n------------------------------\nINPUTS: self, mapper, na_action\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Map values using input an input mapping or function. Maps the values (their categories, not the codes) of the index to new categories. If the mapping correspondence is one-to-one the result is a :class:`~pandas.CategoricalIndex` which has the same order property...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.CategoricalIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx\nCategoricalIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], categories=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027],\n                  ordered=False, dtype=\u0027category\u0027)\n\u003e\u003e\u003e idx.map(lambda x: x.upper())\nCategoricalIndex([\u0027A\u0027, \u0027B\u0027, \u0027C\u0027], categories=[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027],\n                 ordered=False, dtype=\u0027category\u0027)\n\u003e\u003e\u003e idx.map({\u0027a\u0027: \u0027first\u0027, \u0027b\u0027: \u0027second\u0027, \u0027c\u0027: \u0027third\u0027})\nCategoricalIndex([\u0027first\u0027, \u0027second\u0027, \u0027third\u0027], categories=[\u0027first\u0027,\n                 \u0027second\u0027, \u0027third\u0027], ordered=False, dtype=\u0027category\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.max", "label": "max", "shape": "dot", "size": 20, "title": "NAME: max\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: The maximum value of the object. Only ordered `Categoricals` have a maximum! Raises ------ TypeError If the `Categorical` is not `ordered`. Returns ------- max : the maximum of this `Categorical`, NA if array is empty...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.memory_usage", "label": "memory_usage", "shape": "dot", "size": 20, "title": "NAME: memory_usage\n------------------------------\nINPUTS: self, deep\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Memory usage of the values. Parameters ---------- deep : bool, default False Introspect the data deeply, interrogate `object` dtypes for system-level memory consumption. Returns ------- bytes used See Also -------- numpy.ndarray.nbytes : Total bytes consumed by the elements of the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.memory_usage()\n24"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.min", "label": "min", "shape": "dot", "size": 20, "title": "NAME: min\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: The minimum value of the object. Only ordered `Categoricals` have a minimum! Raises ------ TypeError If the `Categorical` is not `ordered`. Returns ------- min : the minimum of this `Categorical`, NA value if empty...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.notna", "label": "notna", "shape": "dot", "size": 20, "title": "NAME: notna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to ``True``. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values. NA values, such as None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.notna()\narray([ True,  True, False])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.notnull", "label": "notnull", "shape": "dot", "size": 20, "title": "NAME: notnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to ``True``. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values. NA values, such as None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.notna()\narray([ True,  True, False])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.nunique", "label": "nunique", "shape": "dot", "size": 20, "title": "NAME: nunique\n------------------------------\nINPUTS: self, dropna\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return number of unique elements in the object. Excludes NA values by default. Parameters ---------- dropna : bool, default True Don\u0027t include NaN in the count. Returns ------- int See Also -------- DataFrame.nunique: Method nunique for DataFrame. Series.count: Count non-NA/null...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 3, 5, 7, 7])\n\u003e\u003e\u003e s\n0    1\n1    3\n2    5\n3    7\n4    7\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.putmask", "label": "putmask", "shape": "dot", "size": 20, "title": "NAME: putmask\n------------------------------\nINPUTS: self, mask, value\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Return a new Index of the values set with the mask. Returns ------- Index See Also -------- numpy.ndarray.putmask : Changes elements of an array based on conditional and input values. Examples -------- \u003e\u003e\u003e idx1 = pd.Index([1, 2, 3]) \u003e\u003e\u003e idx2...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx2 = pd.Index([5, 6, 7])\n\u003e\u003e\u003e idx1.putmask([True, False, False], idx2)\nIndex([5, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.ravel", "label": "ravel", "shape": "dot", "size": 20, "title": "NAME: ravel\n------------------------------\nINPUTS: self, order\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a view on self. Returns ------- Index See Also -------- numpy.ndarray.ravel : Return a flattened array. Examples -------- \u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e s.index.ravel() Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e s.index.ravel()\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.reindex", "label": "reindex", "shape": "dot", "size": 20, "title": "NAME: reindex\n------------------------------\nINPUTS: self, target, method, level, limit, tolerance\nOUTPUTS: tuple[Index, npt.NDArray[np.intp] | None]\n------------------------------\nDESCRIPTION: Create index with target\u0027s values (move/add/delete values as necessary) Returns ------- new_index : pd.Index Resulting index indexer : np.ndarray[np.intp] or None Indices of output values in original index...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.remove_categories", "label": "remove_categories", "shape": "dot", "size": 20, "title": "NAME: remove_categories\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Remove the specified categories. `removals` must be included in the old categories. Values which were in the removed categories will be set to NaN Parameters ---------- removals : category or list of categories The categories which should be removed. Returns...\n\n\nEXAMPLE:\n\u003e\u003e\u003e c = pd.Categorical([\u0027a\u0027, \u0027c\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e c\n[\u0027a\u0027, \u0027c\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027]\nCategories (4, object): [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.remove_unused_categories", "label": "remove_unused_categories", "shape": "dot", "size": 20, "title": "NAME: remove_unused_categories\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Remove categories which are not used. Returns ------- Categorical Categorical with unused categories dropped. See Also -------- rename_categories : Rename categories. reorder_categories : Reorder categories. add_categories : Add new categories. remove_categories : Remove the specified categories. set_categories : Set the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e c = pd.Categorical([\u0027a\u0027, \u0027c\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e c\n[\u0027a\u0027, \u0027c\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027]\nCategories (4, object): [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.rename", "label": "rename", "shape": "dot", "size": 20, "title": "NAME: rename\n------------------------------\nINPUTS: self, name, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Alter Index or MultiIndex name. Able to set new names without level. Defaults to returning new index. Length of names must match number of levels in MultiIndex. Parameters ---------- name : label or list of labels Name(s) to set. inplace...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027A\u0027, \u0027C\u0027, \u0027A\u0027, \u0027B\u0027], name=\u0027score\u0027)\n\u003e\u003e\u003e idx.rename(\u0027grade\u0027)\nIndex([\u0027A\u0027, \u0027C\u0027, \u0027A\u0027, \u0027B\u0027], dtype=\u0027object\u0027, name=\u0027grade\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.rename_categories", "label": "rename_categories", "shape": "dot", "size": 20, "title": "NAME: rename_categories\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Rename categories. Parameters ---------- new_categories : list-like, dict-like or callable New categories which will replace old categories. * list-like: all items must be unique and the number of items in the new categories must match the existing number of categories....\n\n\nEXAMPLE:\n\u003e\u003e\u003e c = pd.Categorical([\u0027a\u0027, \u0027a\u0027, \u0027b\u0027])\n\u003e\u003e\u003e c.rename_categories([0, 1])\n[0, 0, 1]\nCategories (2, int64): [0, 1]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.reorder_categories", "label": "reorder_categories", "shape": "dot", "size": 20, "title": "NAME: reorder_categories\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Reorder categories as specified in new_categories. ``new_categories`` need to include all old categories and no new category items. Parameters ---------- new_categories : Index-like The categories in new order. ordered : bool, optional Whether or not the categorical is treated as...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027a\u0027], dtype=\u0027category\u0027)\n\u003e\u003e\u003e ser = ser.cat.reorder_categories([\u0027c\u0027, \u0027b\u0027, \u0027a\u0027], ordered=True)\n\u003e\u003e\u003e ser\n0   a\n1   b\n2   c\n3   a\ndtype: category\nCategories (3, object): [\u0027c\u0027 \u003c \u0027b\u0027 \u003c \u0027a\u0027]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.repeat", "label": "repeat", "shape": "dot", "size": 20, "title": "NAME: repeat\n------------------------------\nINPUTS: self, repeats, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Repeat elements of a Index. Returns a new Index where each element of the current Index is repeated consecutively a given number of times. Parameters ---------- repeats : int or array of ints The number of repetitions for each element....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.repeat(2)\nIndex([\u0027a\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027c\u0027, \u0027c\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.repeat([1, 2, 3])\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027c\u0027, \u0027c\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.round", "label": "round", "shape": "dot", "size": 20, "title": "NAME: round\n------------------------------\nINPUTS: self, decimals\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Round each value in the Index to the given number of decimals. Parameters ---------- decimals : int, optional Number of decimal places to round to. If decimals is negative, it specifies the number of positions to the left of the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import pandas as pd\n\u003e\u003e\u003e idx = pd.Index([10.1234, 20.5678, 30.9123, 40.4567, 50.7890])\n\u003e\u003e\u003e idx.round(decimals=2)\nIndex([10.12, 20.57, 30.91, 40.46, 50.79], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.searchsorted", "label": "searchsorted", "shape": "dot", "size": 20, "title": "NAME: searchsorted\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Find indices where elements should be inserted to maintain order. Find the indices into a sorted array `self` (a) such that, if the corresponding elements in `value` were inserted before the indices, the order of `self` would be preserved. Assuming...\n\n\nEXAMPLE:\n\u003e\u003e\u003e arr = pd.array([1, 2, 3, 5])\n\u003e\u003e\u003e arr.searchsorted([4])\narray([3])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.set_categories", "label": "set_categories", "shape": "dot", "size": 20, "title": "NAME: set_categories\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Set the categories to the specified new categories. ``new_categories`` can include new categories (which will result in unused categories) or remove old categories (which results in values set to ``NaN``). If ``rename=True``, the categories will simply be renamed (less or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e raw_cat = pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027A\u0027],\n...                           categories=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], ordered=True)\n\u003e\u003e\u003e ser = pd.Series(raw_cat)\n\u003e\u003e\u003e ser\n0   a\n1   b\n2   c\n3   NaN\ndtype: category\nCategories (3, object): [\u0027a\u0027 \u003c \u0027b\u0027 \u003c \u0027c\u0027]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.set_names", "label": "set_names", "shape": "dot", "size": 20, "title": "NAME: set_names\n------------------------------\nINPUTS: self, names, level, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Set Index or MultiIndex name. Able to set new names partially and by level. Parameters ---------- names : label or list of label or dict-like for MultiIndex Name(s) to set. .. versionchanged:: 1.3.0 level : int, label or list of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx.set_names(\u0027quarter\u0027)\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027, name=\u0027quarter\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.shift", "label": "shift", "shape": "dot", "size": 20, "title": "NAME: shift\n------------------------------\nINPUTS: self, periods, freq\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Shift index by desired number of time frequency increments. This method is for shifting the values of datetime-like indexes by a specified time increment a given number of times. Parameters ---------- periods : int, default 1 Number of periods (or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e month_starts = pd.date_range(\u00271/1/2011\u0027, periods=5, freq=\u0027MS\u0027)\n\u003e\u003e\u003e month_starts\nDatetimeIndex([\u00272011-01-01\u0027, \u00272011-02-01\u0027, \u00272011-03-01\u0027, \u00272011-04-01\u0027,\n               \u00272011-05-01\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=\u0027MS\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.slice_indexer", "label": "slice_indexer", "shape": "dot", "size": 20, "title": "NAME: slice_indexer\n------------------------------\nINPUTS: self, start, end, step\nOUTPUTS: slice\n------------------------------\nDESCRIPTION: Compute the slice indexer for input labels and step. Index needs to be ordered and unique. Parameters ---------- start : label, default None If None, defaults to the beginning. end : label, default None If None, defaults to the end....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abcd\u0027))\n\u003e\u003e\u003e idx.slice_indexer(start=\u0027b\u0027, end=\u0027c\u0027)\nslice(1, 3, None)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.slice_locs", "label": "slice_locs", "shape": "dot", "size": 20, "title": "NAME: slice_locs\n------------------------------\nINPUTS: self, start, end, step\nOUTPUTS: tuple[int, int]\n------------------------------\nDESCRIPTION: Compute slice locations for input labels. Parameters ---------- start : label, default None If None, defaults to the beginning. end : label, default None If None, defaults to the end. step : int, defaults None If None, defaults to 1....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abcd\u0027))\n\u003e\u003e\u003e idx.slice_locs(start=\u0027b\u0027, end=\u0027c\u0027)\n(1, 3)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.sort", "label": "sort", "shape": "dot", "size": 20, "title": "NAME: sort\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Use sort_values instead....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.sort_values", "label": "sort_values", "shape": "dot", "size": 20, "title": "NAME: sort_values\n------------------------------\nINPUTS: self, return_indexer, ascending, na_position, key\nOUTPUTS: Self | tuple[Self, np.ndarray]\n------------------------------\nDESCRIPTION: Return a sorted copy of the index. Return a sorted copy of the index, and optionally return the indices that sorted the index itself. Parameters ---------- return_indexer : bool, default False Should the indices that would sort the index be...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([10, 100, 1, 1000])\n\u003e\u003e\u003e idx\nIndex([10, 100, 1, 1000], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.sortlevel", "label": "sortlevel", "shape": "dot", "size": 20, "title": "NAME: sortlevel\n------------------------------\nINPUTS: self, level, ascending, sort_remaining, na_position\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: For internal compatibility with the Index API. Sort the Index. This is for compat with MultiIndex Parameters ---------- ascending : bool, default True False to sort in descending order na_position : {\u0027first\u0027 or \u0027last\u0027}, default \u0027first\u0027 Argument \u0027first\u0027 puts NaNs...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.str", "label": "str", "shape": "dot", "size": 20, "title": "NAME: str\n------------------------------\nINPUTS: data\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Vectorized string functions for Series and Index. NAs stay NA unless handled otherwise by a particular method. Patterned after Python\u0027s string methods, with some inspiration from R\u0027s stringr package. Examples -------- \u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"]) \u003e\u003e\u003e s 0 A_Str_Series dtype:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"])\n\u003e\u003e\u003e s\n0    A_Str_Series\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.symmetric_difference", "label": "symmetric_difference", "shape": "dot", "size": 20, "title": "NAME: symmetric_difference\n------------------------------\nINPUTS: self, other, result_name, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Compute the symmetric difference of two Index objects. Parameters ---------- other : Index or array-like result_name : str sort : bool or None, default None Whether to sort the resulting index. By default, the values are attempted to be sorted,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([2, 3, 4, 5])\n\u003e\u003e\u003e idx1.symmetric_difference(idx2)\nIndex([1, 5], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.take", "label": "take", "shape": "dot", "size": 20, "title": "NAME: take\n------------------------------\nINPUTS: self, indices, axis, allow_fill, fill_value, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a new Index of the values selected by the indices. For internal compatibility with numpy arrays. Parameters ---------- indices : array-like Indices to be taken. axis : int, optional The axis over which to select values, always 0. allow_fill...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.take([2, 2, 1, 2])\nIndex([\u0027c\u0027, \u0027c\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.to_flat_index", "label": "to_flat_index", "shape": "dot", "size": 20, "title": "NAME: to_flat_index\n------------------------------\nINPUTS: self\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Identity method. This is implemented for compatibility with subclass implementations when chaining. Returns ------- pd.Index Caller. See Also -------- MultiIndex.to_flat_index : Subclass implementation....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.to_frame", "label": "to_frame", "shape": "dot", "size": 20, "title": "NAME: to_frame\n------------------------------\nINPUTS: self, index, name\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Create a DataFrame with a column containing the Index. Parameters ---------- index : bool, default True Set the index of the returned DataFrame as the original Index. name : object, defaults to index.name The passed name should substitute for the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027Ant\u0027, \u0027Bear\u0027, \u0027Cow\u0027], name=\u0027animal\u0027)\n\u003e\u003e\u003e idx.to_frame()\n       animal\nanimal\nAnt       Ant\nBear     Bear\nCow       Cow"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.to_list", "label": "to_list", "shape": "dot", "size": 20, "title": "NAME: to_list\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list See Also -------- numpy.ndarray.tolist : Return the array as an...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.to_list()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.to_numpy", "label": "to_numpy", "shape": "dot", "size": 20, "title": "NAME: to_numpy\n------------------------------\nINPUTS: self, dtype, copy, na_value, kwargs\nOUTPUTS: np.ndarray\n------------------------------\nDESCRIPTION: A NumPy ndarray representing the values in this Series or Index. Parameters ---------- dtype : str or numpy.dtype, optional The dtype to pass to :meth:`numpy.asarray`. copy : bool, default False Whether to ensure that the returned value is not a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series(pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027]))\n\u003e\u003e\u003e ser.to_numpy()\narray([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.to_series", "label": "to_series", "shape": "dot", "size": 20, "title": "NAME: to_series\n------------------------------\nINPUTS: self, index, name\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Create a Series with both index and values equal to the index keys. Useful with map for returning an indexer based on an index. Parameters ---------- index : Index, optional Index of resulting Series. If None, defaults to original index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027Ant\u0027, \u0027Bear\u0027, \u0027Cow\u0027], name=\u0027animal\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.tolist", "label": "tolist", "shape": "dot", "size": 20, "title": "NAME: tolist\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list Examples -------- \u003e\u003e\u003e arr = pd.array([1, 2, 3]) \u003e\u003e\u003e arr.tolist()...\n\n\nEXAMPLE:\n\u003e\u003e\u003e arr = pd.array([1, 2, 3])\n\u003e\u003e\u003e arr.tolist()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.transpose", "label": "transpose", "shape": "dot", "size": 20, "title": "NAME: transpose\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return the transpose, which is by definition self. Returns ------- %(klass)s...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.union", "label": "union", "shape": "dot", "size": 20, "title": "NAME: union\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Form the union of two Index objects. If the Index objects are incompatible, both Index objects will be cast to dtype(\u0027object\u0027) first. Parameters ---------- other : Index or array-like sort : bool or None, default None Whether to sort the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.union(idx2)\nIndex([1, 2, 3, 4, 5, 6], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.unique", "label": "unique", "shape": "dot", "size": 20, "title": "NAME: unique\n------------------------------\nINPUTS: self, level\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return unique values in the index. Unique values are returned in order of appearance, this does NOT sort. Parameters ---------- level : int or hashable, optional Only return values from specified level (for MultiIndex). If int, gets the level by...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 1, 2, 3, 3])\n\u003e\u003e\u003e idx.unique()\nIndex([1, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.value_counts", "label": "value_counts", "shape": "dot", "size": 20, "title": "NAME: value_counts\n------------------------------\nINPUTS: self, normalize, sort, ascending, bins, dropna\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return a Series containing counts of unique values. The resulting object will be in descending order so that the first element is the most frequently-occurring element. Excludes NA values by default. Parameters ---------- normalize : bool, default False If True...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([3, 1, 2, 3, 4, np.nan])\n\u003e\u003e\u003e index.value_counts()\n3.0    2\n1.0    1\n2.0    1\n4.0    1\nName: count, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.view", "label": "view", "shape": "dot", "size": 20, "title": "NAME: view\n------------------------------\nINPUTS: self, cls\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.CategoricalIndex.where", "label": "where", "shape": "dot", "size": 20, "title": "NAME: where\n------------------------------\nINPUTS: self, cond, other\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Replace values where the condition is False. The replacement is taken from other. Parameters ---------- cond : bool array-like with the same length as self Condition to select the values on. other : scalar, or array-like, default None Replacement if...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.where(idx.isin([\u0027car\u0027, \u0027train\u0027]), \u0027other\u0027)\nIndex([\u0027car\u0027, \u0027other\u0027, \u0027train\u0027, \u0027other\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.abs", "label": "abs", "shape": "dot", "size": 20, "title": "NAME: abs\n------------------------------\nINPUTS: self\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a Series/DataFrame with absolute numeric value of each element. This function only applies to elements that are all numeric. Returns ------- abs Series/DataFrame containing the absolute value of each element. See Also -------- numpy.absolute : Calculate the absolute value...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([-1.10, 2, -3.33, 4])\n\u003e\u003e\u003e s.abs()\n0    1.10\n1    2.00\n2    3.33\n3    4.00\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.add", "label": "add", "shape": "dot", "size": 20, "title": "NAME: add\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Addition of dataframe and other, element-wise (binary operator `add`). Equivalent to ``dataframe + other``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `radd`. Among flexible wrappers (`add`, `sub`, `mul`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.add_prefix", "label": "add_prefix", "shape": "dot", "size": 20, "title": "NAME: add_prefix\n------------------------------\nINPUTS: self, prefix, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Prefix labels with string `prefix`. For Series, the row labels are prefixed. For DataFrame, the column labels are prefixed. Parameters ---------- prefix : str The string to add before each label. axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027, None},...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3, 4])\n\u003e\u003e\u003e s\n0    1\n1    2\n2    3\n3    4\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.add_suffix", "label": "add_suffix", "shape": "dot", "size": 20, "title": "NAME: add_suffix\n------------------------------\nINPUTS: self, suffix, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Suffix labels with string `suffix`. For Series, the row labels are suffixed. For DataFrame, the column labels are suffixed. Parameters ---------- suffix : str The string to add after each label. axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027, None},...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3, 4])\n\u003e\u003e\u003e s\n0    1\n1    2\n2    3\n3    4\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.agg", "label": "agg", "shape": "dot", "size": 20, "title": "NAME: agg\n------------------------------\nINPUTS: self, func, axis, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Aggregate using one or more operations over the specified axis. Parameters ---------- func : function, str, list or dict Function to use for aggregating the data. If a function, must either work when passed a DataFrame or when passed to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[1, 2, 3],\n...                    [4, 5, 6],\n...                    [7, 8, 9],\n...                    [np.nan, np.nan, np.nan]],\n...                   columns=[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.aggregate", "label": "aggregate", "shape": "dot", "size": 20, "title": "NAME: aggregate\n------------------------------\nINPUTS: self, func, axis, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Aggregate using one or more operations over the specified axis. Parameters ---------- func : function, str, list or dict Function to use for aggregating the data. If a function, must either work when passed a DataFrame or when passed to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[1, 2, 3],\n...                    [4, 5, 6],\n...                    [7, 8, 9],\n...                    [np.nan, np.nan, np.nan]],\n...                   columns=[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.align", "label": "align", "shape": "dot", "size": 20, "title": "NAME: align\n------------------------------\nINPUTS: self, other, join, axis, level, copy, fill_value, method, limit, fill_axis, broadcast_axis\nOUTPUTS: tuple[Self, NDFrameT]\n------------------------------\nDESCRIPTION: Align two objects on their axes with the specified join method. Join method is specified for each axis Index. Parameters ---------- other : DataFrame or Series join : {\u0027outer\u0027, \u0027inner\u0027, \u0027left\u0027, \u0027right\u0027}, default \u0027outer\u0027 Type of alignment to be performed....\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(\n...     [[1, 2, 3, 4], [6, 7, 8, 9]], columns=[\"D\", \"B\", \"E\", \"A\"], index=[1, 2]\n... )\n\u003e\u003e\u003e other = pd.DataFrame(\n...     [[10, 20, 30, 40], [60, 70, 80, 90], [600, 700, 800, 900]],\n...     columns=[\"A\", \"B\", \"C\", \"D\"],\n...     index=[2, 3, 4],\n... )\n\u003e\u003e\u003e df\n   D  B  E  A\n1  1  2  3  4\n2  6  7  8  9\n\u003e\u003e\u003e other\n    A    B    C    D\n2   10   20   30   40\n3   60   70   80   90\n4  600  700  800  900"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.all", "label": "all", "shape": "dot", "size": 20, "title": "NAME: all\n------------------------------\nINPUTS: self, axis, bool_only, skipna, kwargs\nOUTPUTS: Series | bool\n------------------------------\nDESCRIPTION: Return whether all elements are True, potentially over an axis. Returns True unless there at least one element within a series or along a Dataframe axis that is False or equivalent (e.g. zero or empty). Parameters ---------- axis : {0...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Series([True, True]).all()\nTrue\n\u003e\u003e\u003e pd.Series([True, False]).all()\nFalse\n\u003e\u003e\u003e pd.Series([], dtype=\"float64\").all()\nTrue\n\u003e\u003e\u003e pd.Series([np.nan]).all()\nTrue\n\u003e\u003e\u003e pd.Series([np.nan]).all(skipna=False)\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.any", "label": "any", "shape": "dot", "size": 20, "title": "NAME: any\n------------------------------\nINPUTS: self, axis, bool_only, skipna, kwargs\nOUTPUTS: Series | bool\n------------------------------\nDESCRIPTION: Return whether any element is True, potentially over an axis. Returns False unless there is at least one element within a series or along a Dataframe axis that is True or equivalent (e.g. non-zero or non-empty). Parameters ---------- axis :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Series([False, False]).any()\nFalse\n\u003e\u003e\u003e pd.Series([True, False]).any()\nTrue\n\u003e\u003e\u003e pd.Series([], dtype=\"float64\").any()\nFalse\n\u003e\u003e\u003e pd.Series([np.nan]).any()\nFalse\n\u003e\u003e\u003e pd.Series([np.nan]).any(skipna=False)\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.apply", "label": "apply", "shape": "dot", "size": 20, "title": "NAME: apply\n------------------------------\nINPUTS: self, func, axis, raw, result_type, args, by_row, engine, engine_kwargs, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Apply a function along an axis of the DataFrame. Objects passed to the function are Series objects whose index is either the DataFrame\u0027s index (``axis=0``) or the DataFrame\u0027s columns (``axis=1``). By default (``result_type=None``), the final return type is inferred from...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[4, 9]] * 3, columns=[\u0027A\u0027, \u0027B\u0027])\n\u003e\u003e\u003e df\n   A  B\n0  4  9\n1  4  9\n2  4  9"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.applymap", "label": "applymap", "shape": "dot", "size": 20, "title": "NAME: applymap\n------------------------------\nINPUTS: self, func, na_action, kwargs\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Apply a function to a Dataframe elementwise. .. deprecated:: 2.1.0 DataFrame.applymap has been deprecated. Use DataFrame.map instead. This method applies a function that accepts and returns a scalar to every element of a DataFrame. Parameters ---------- func : callable Python...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[1, 2.12], [3.356, 4.567]])\n\u003e\u003e\u003e df\n       0      1\n0  1.000  2.120\n1  3.356  4.567"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.asfreq", "label": "asfreq", "shape": "dot", "size": 20, "title": "NAME: asfreq\n------------------------------\nINPUTS: self, freq, method, how, normalize, fill_value\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Convert time series to specified frequency. Returns the original data conformed to a new index with the specified frequency. If the index of this Series/DataFrame is a :class:`~pandas.PeriodIndex`, the new index is the result of transforming the original index with...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.date_range(\u00271/1/2000\u0027, periods=4, freq=\u0027min\u0027)\n\u003e\u003e\u003e series = pd.Series([0.0, None, 2.0, 3.0], index=index)\n\u003e\u003e\u003e df = pd.DataFrame({\u0027s\u0027: series})\n\u003e\u003e\u003e df\n                       s\n2000-01-01 00:00:00    0.0\n2000-01-01 00:01:00    NaN\n2000-01-01 00:02:00    2.0\n2000-01-01 00:03:00    3.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.asof", "label": "asof", "shape": "dot", "size": 20, "title": "NAME: asof\n------------------------------\nINPUTS: self, where, subset\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the last row(s) without any NaNs before `where`. The last row (for each element in `where`, if list) without any NaN is taken. In case of a :class:`~pandas.DataFrame`, the last row without NaN considering only the subset of columns...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, np.nan, 4], index=[10, 20, 30, 40])\n\u003e\u003e\u003e s\n10    1.0\n20    2.0\n30    NaN\n40    4.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.assign", "label": "assign", "shape": "dot", "size": 20, "title": "NAME: assign\n------------------------------\nINPUTS: self, kwargs\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Assign new columns to a DataFrame. Returns a new object with all original columns in addition to new ones. Existing columns that are re-assigned will be overwritten. Parameters ---------- **kwargs : dict of {str: callable or Series} The column names...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027temp_c\u0027: [17.0, 25.0]},\n...                   index=[\u0027Portland\u0027, \u0027Berkeley\u0027])\n\u003e\u003e\u003e df\n          temp_c\nPortland    17.0\nBerkeley    25.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.astype", "label": "astype", "shape": "dot", "size": 20, "title": "NAME: astype\n------------------------------\nINPUTS: self, dtype, copy, errors\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Cast a pandas object to a specified dtype ``dtype``. Parameters ---------- dtype : str, data type, Series or Mapping of column name -\u003e data type Use a str, numpy.dtype, pandas.ExtensionDtype or Python type to cast entire pandas object to the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e d = {\u0027col1\u0027: [1, 2], \u0027col2\u0027: [3, 4]}\n\u003e\u003e\u003e df = pd.DataFrame(data=d)\n\u003e\u003e\u003e df.dtypes\ncol1    int64\ncol2    int64\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.at_time", "label": "at_time", "shape": "dot", "size": 20, "title": "NAME: at_time\n------------------------------\nINPUTS: self, time, asof, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Select values at particular time of day (e.g., 9:30AM). Parameters ---------- time : datetime.time or str The values to select. axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 For `Series` this parameter is unused and defaults to 0....\n\n\nEXAMPLE:\n\u003e\u003e\u003e i = pd.date_range(\u00272018-04-09\u0027, periods=4, freq=\u002712h\u0027)\n\u003e\u003e\u003e ts = pd.DataFrame({\u0027A\u0027: [1, 2, 3, 4]}, index=i)\n\u003e\u003e\u003e ts\n                     A\n2018-04-09 00:00:00  1\n2018-04-09 12:00:00  2\n2018-04-10 00:00:00  3\n2018-04-10 12:00:00  4"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.backfill", "label": "backfill", "shape": "dot", "size": 20, "title": "NAME: backfill\n------------------------------\nINPUTS: self, axis, inplace, limit, downcast\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Fill NA/NaN values by using the next valid observation to fill the gap. .. deprecated:: 2.0 Series/DataFrame.backfill is deprecated. Use Series/DataFrame.bfill instead. Returns ------- Series/DataFrame or None Object with missing values filled or None if ``inplace=True``. Examples -------- Please see...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.between_time", "label": "between_time", "shape": "dot", "size": 20, "title": "NAME: between_time\n------------------------------\nINPUTS: self, start_time, end_time, inclusive, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Select values between particular times of the day (e.g., 9:00-9:30 AM). By setting ``start_time`` to be later than ``end_time``, you can get the times that are *not* between the two times. Parameters ---------- start_time : datetime.time or str Initial time...\n\n\nEXAMPLE:\n\u003e\u003e\u003e i = pd.date_range(\u00272018-04-09\u0027, periods=4, freq=\u00271D20min\u0027)\n\u003e\u003e\u003e ts = pd.DataFrame({\u0027A\u0027: [1, 2, 3, 4]}, index=i)\n\u003e\u003e\u003e ts\n                     A\n2018-04-09 00:00:00  1\n2018-04-10 00:20:00  2\n2018-04-11 00:40:00  3\n2018-04-12 01:00:00  4"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.bfill", "label": "bfill", "shape": "dot", "size": 20, "title": "NAME: bfill\n------------------------------\nINPUTS: self, axis, inplace, limit, limit_area, downcast\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Fill NA/NaN values by using the next valid observation to fill the gap. Parameters ---------- axis : {0 or \u0027index\u0027} for Series, {0 or \u0027index\u0027, 1 or \u0027columns\u0027} for DataFrame Axis along which to fill missing values. For `Series` this...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, None, None, 2])\n\u003e\u003e\u003e s.bfill()\n0    1.0\n1    2.0\n2    2.0\n3    2.0\ndtype: float64\n\u003e\u003e\u003e s.bfill(limit=1)\n0    1.0\n1    NaN\n2    2.0\n3    2.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.bool", "label": "bool", "shape": "dot", "size": 20, "title": "NAME: bool\n------------------------------\nINPUTS: self\nOUTPUTS: bool_t\n------------------------------\nDESCRIPTION: Return the bool of a single element Series or DataFrame. .. deprecated:: 2.1.0 bool is deprecated and will be removed in future version of pandas. For ``Series`` use ``pandas.Series.item``. This must be a boolean scalar value, either True or False....\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Series([True]).bool()  # doctest: +SKIP\nTrue\n\u003e\u003e\u003e pd.Series([False]).bool()  # doctest: +SKIP\nFalse"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.boxplot", "label": "boxplot", "shape": "dot", "size": 20, "title": "NAME: boxplot\n------------------------------\nINPUTS: self, column, by, ax, fontsize, rot, grid, figsize, layout, return_type, backend, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Make a box plot from DataFrame columns. Make a box-and-whisker plot from DataFrame columns, optionally grouped by some other columns. A box plot is a method for graphically depicting groups of numerical data through their quartiles. The box extends from...\n\n\nEXAMPLE:\n\u003e\u003e\u003e np.random.seed(1234)\n    \u003e\u003e\u003e df = pd.DataFrame(np.random.randn(10, 4),\n    ...                   columns=[\u0027Col1\u0027, \u0027Col2\u0027, \u0027Col3\u0027, \u0027Col4\u0027])\n    \u003e\u003e\u003e boxplot = df.boxplot(column=[\u0027Col1\u0027, \u0027Col2\u0027, \u0027Col3\u0027])  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.clip", "label": "clip", "shape": "dot", "size": 20, "title": "NAME: clip\n------------------------------\nINPUTS: self, lower, upper, axis, inplace, kwargs\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Trim values at input threshold(s). Assigns values outside boundary to boundary values. Thresholds can be singular values or array like, and in the latter case the clipping is performed element-wise in the specified axis. Parameters ---------- lower : float or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e data = {\u0027col_0\u0027: [9, -3, 0, -1, 5], \u0027col_1\u0027: [-2, -7, 6, 8, -5]}\n\u003e\u003e\u003e df = pd.DataFrame(data)\n\u003e\u003e\u003e df\n   col_0  col_1\n0      9     -2\n1     -3     -7\n2      0      6\n3     -1      8\n4      5     -5"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.combine", "label": "combine", "shape": "dot", "size": 20, "title": "NAME: combine\n------------------------------\nINPUTS: self, other, func, fill_value, overwrite\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Perform column-wise combine with another DataFrame. Combines a DataFrame with `other` DataFrame using `func` to element-wise combine columns. The row and column indexes of the resulting DataFrame will be the union of the two. Parameters ---------- other : DataFrame The...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df1 = pd.DataFrame({\u0027A\u0027: [0, 0], \u0027B\u0027: [4, 4]})\n\u003e\u003e\u003e df2 = pd.DataFrame({\u0027A\u0027: [1, 1], \u0027B\u0027: [3, 3]})\n\u003e\u003e\u003e take_smaller = lambda s1, s2: s1 if s1.sum() \u003c s2.sum() else s2\n\u003e\u003e\u003e df1.combine(df2, take_smaller)\n   A  B\n0  0  3\n1  0  3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.combine_first", "label": "combine_first", "shape": "dot", "size": 20, "title": "NAME: combine_first\n------------------------------\nINPUTS: self, other\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Update null elements with value in the same location in `other`. Combine two DataFrame objects by filling null values in one DataFrame with non-null values from other DataFrame. The row and column indexes of the resulting DataFrame will be the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df1 = pd.DataFrame({\u0027A\u0027: [None, 0], \u0027B\u0027: [None, 4]})\n\u003e\u003e\u003e df2 = pd.DataFrame({\u0027A\u0027: [1, 1], \u0027B\u0027: [3, 3]})\n\u003e\u003e\u003e df1.combine_first(df2)\n     A    B\n0  1.0  3.0\n1  0.0  4.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.compare", "label": "compare", "shape": "dot", "size": 20, "title": "NAME: compare\n------------------------------\nINPUTS: self, other, align_axis, keep_shape, keep_equal, result_names\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Compare to another DataFrame and show the differences. Parameters ---------- other : DataFrame Object to compare with. align_axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 1 Determine which axis to align the comparison on. * 0, or \u0027index\u0027 :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(\n...     {\n...         \"col1\": [\"a\", \"a\", \"b\", \"b\", \"a\"],\n...         \"col2\": [1.0, 2.0, 3.0, np.nan, 5.0],\n...         \"col3\": [1.0, 2.0, 3.0, 4.0, 5.0]\n...     },\n...     columns=[\"col1\", \"col2\", \"col3\"],\n... )\n\u003e\u003e\u003e df\n  col1  col2  col3\n0    a   1.0   1.0\n1    a   2.0   2.0\n2    b   3.0   3.0\n3    b   NaN   4.0\n4    a   5.0   5.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.convert_dtypes", "label": "convert_dtypes", "shape": "dot", "size": 20, "title": "NAME: convert_dtypes\n------------------------------\nINPUTS: self, infer_objects, convert_string, convert_integer, convert_boolean, convert_floating, dtype_backend\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Convert columns to the best possible dtypes using dtypes supporting ``pd.NA``. Parameters ---------- infer_objects : bool, default True Whether object dtypes should be converted to the best possible types. convert_string : bool, default True Whether object dtypes should be converted...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(\n...     {\n...         \"a\": pd.Series([1, 2, 3], dtype=np.dtype(\"int32\")),\n...         \"b\": pd.Series([\"x\", \"y\", \"z\"], dtype=np.dtype(\"O\")),\n...         \"c\": pd.Series([True, False, np.nan], dtype=np.dtype(\"O\")),\n...         \"d\": pd.Series([\"h\", \"i\", np.nan], dtype=np.dtype(\"O\")),\n...         \"e\": pd.Series([10, np.nan, 20], dtype=np.dtype(\"float\")),\n...         \"f\": pd.Series([np.nan, 100.5, 200], dtype=np.dtype(\"float\")),\n...     }\n... )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.copy", "label": "copy", "shape": "dot", "size": 20, "title": "NAME: copy\n------------------------------\nINPUTS: self, deep\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make a copy of this object\u0027s indices and data. When ``deep=True`` (default), a new object will be created with a copy of the calling object\u0027s data and indices. Modifications to the data or indices of the copy will not be...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2], index=[\"a\", \"b\"])\n\u003e\u003e\u003e s\na    1\nb    2\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.corr", "label": "corr", "shape": "dot", "size": 20, "title": "NAME: corr\n------------------------------\nINPUTS: self, method, min_periods, numeric_only\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Compute pairwise correlation of columns, excluding NA/null values. Parameters ---------- method : {\u0027pearson\u0027, \u0027kendall\u0027, \u0027spearman\u0027} or callable Method of correlation: * pearson : standard correlation coefficient * kendall : Kendall Tau correlation coefficient * spearman : Spearman rank correlation *...\n\n\nEXAMPLE:\n\u003e\u003e\u003e def histogram_intersection(a, b):\n...     v = np.minimum(a, b).sum().round(decimals=1)\n...     return v\n\u003e\u003e\u003e df = pd.DataFrame([(.2, .3), (.0, .6), (.6, .0), (.2, .1)],\n...                   columns=[\u0027dogs\u0027, \u0027cats\u0027])\n\u003e\u003e\u003e df.corr(method=histogram_intersection)\n      dogs  cats\ndogs   1.0   0.3\ncats   0.3   1.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.corrwith", "label": "corrwith", "shape": "dot", "size": 20, "title": "NAME: corrwith\n------------------------------\nINPUTS: self, other, axis, drop, method, numeric_only\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Compute pairwise correlation. Pairwise correlation is computed between rows or columns of DataFrame with rows or columns of Series or DataFrame. DataFrames are first aligned along both axes before computing the correlations. Parameters ---------- other : DataFrame, Series Object with...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = [\"a\", \"b\", \"c\", \"d\", \"e\"]\n\u003e\u003e\u003e columns = [\"one\", \"two\", \"three\", \"four\"]\n\u003e\u003e\u003e df1 = pd.DataFrame(np.arange(20).reshape(5, 4), index=index, columns=columns)\n\u003e\u003e\u003e df2 = pd.DataFrame(np.arange(16).reshape(4, 4), index=index[:4], columns=columns)\n\u003e\u003e\u003e df1.corrwith(df2)\none      1.0\ntwo      1.0\nthree    1.0\nfour     1.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.count", "label": "count", "shape": "dot", "size": 20, "title": "NAME: count\n------------------------------\nINPUTS: self, axis, numeric_only\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Count non-NA cells for each column or row. The values `None`, `NaN`, `NaT`, ``pandas.NA`` are considered NA. Parameters ---------- axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 If 0 or \u0027index\u0027 counts are generated for each column. If...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"Person\":\n...                    [\"John\", \"Myla\", \"Lewis\", \"John\", \"Myla\"],\n...                    \"Age\": [24., np.nan, 21., 33, 26],\n...                    \"Single\": [False, True, True, True, False]})\n\u003e\u003e\u003e df\n   Person   Age  Single\n0    John  24.0   False\n1    Myla   NaN    True\n2   Lewis  21.0    True\n3    John  33.0    True\n4    Myla  26.0   False"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.cov", "label": "cov", "shape": "dot", "size": 20, "title": "NAME: cov\n------------------------------\nINPUTS: self, min_periods, ddof, numeric_only\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Compute pairwise covariance of columns, excluding NA/null values. Compute the pairwise covariance among the series of a DataFrame. The returned data frame is the `covariance matrix \u003chttps://en.wikipedia.org/wiki/Covariance_matrix\u003e`__ of the columns of the DataFrame. Both NA and null values are automatically...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([(1, 2), (0, 3), (2, 0), (1, 1)],\n...                   columns=[\u0027dogs\u0027, \u0027cats\u0027])\n\u003e\u003e\u003e df.cov()\n          dogs      cats\ndogs  0.666667 -1.000000\ncats -1.000000  1.666667"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.cummax", "label": "cummax", "shape": "dot", "size": 20, "title": "NAME: cummax\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return cumulative maximum over a DataFrame or Series axis. Returns a DataFrame or Series of the same size containing the cumulative maximum. Parameters ---------- axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 The index or the name of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([2, np.nan, 5, -1, 0])\n\u003e\u003e\u003e s\n0    2.0\n1    NaN\n2    5.0\n3   -1.0\n4    0.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.cummin", "label": "cummin", "shape": "dot", "size": 20, "title": "NAME: cummin\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return cumulative minimum over a DataFrame or Series axis. Returns a DataFrame or Series of the same size containing the cumulative minimum. Parameters ---------- axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 The index or the name of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([2, np.nan, 5, -1, 0])\n\u003e\u003e\u003e s\n0    2.0\n1    NaN\n2    5.0\n3   -1.0\n4    0.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.cumprod", "label": "cumprod", "shape": "dot", "size": 20, "title": "NAME: cumprod\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return cumulative product over a DataFrame or Series axis. Returns a DataFrame or Series of the same size containing the cumulative product. Parameters ---------- axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 The index or the name of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([2, np.nan, 5, -1, 0])\n\u003e\u003e\u003e s\n0    2.0\n1    NaN\n2    5.0\n3   -1.0\n4    0.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.cumsum", "label": "cumsum", "shape": "dot", "size": 20, "title": "NAME: cumsum\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return cumulative sum over a DataFrame or Series axis. Returns a DataFrame or Series of the same size containing the cumulative sum. Parameters ---------- axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 The index or the name of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([2, np.nan, 5, -1, 0])\n\u003e\u003e\u003e s\n0    2.0\n1    NaN\n2    5.0\n3   -1.0\n4    0.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.describe", "label": "describe", "shape": "dot", "size": 20, "title": "NAME: describe\n------------------------------\nINPUTS: self, percentiles, include, exclude\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Generate descriptive statistics. Descriptive statistics include those that summarize the central tendency, dispersion and shape of a dataset\u0027s distribution, excluding ``NaN`` values. Analyzes both numeric and object series, as well as ``DataFrame`` column sets of mixed data types. The output...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.describe()\ncount    3.0\nmean     2.0\nstd      1.0\nmin      1.0\n25%      1.5\n50%      2.0\n75%      2.5\nmax      3.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.diff", "label": "diff", "shape": "dot", "size": 20, "title": "NAME: diff\n------------------------------\nINPUTS: self, periods, axis\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: First discrete difference of element. Calculates the difference of a DataFrame element compared with another element in the DataFrame (default is element in previous row). Parameters ---------- periods : int, default 1 Periods to shift for calculating difference, accepts negative...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027a\u0027: [1, 2, 3, 4, 5, 6],\n...                    \u0027b\u0027: [1, 1, 2, 3, 5, 8],\n...                    \u0027c\u0027: [1, 4, 9, 16, 25, 36]})\n\u003e\u003e\u003e df\n   a  b   c\n0  1  1   1\n1  2  1   4\n2  3  2   9\n3  4  3  16\n4  5  5  25\n5  6  8  36"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.div", "label": "div", "shape": "dot", "size": 20, "title": "NAME: div\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Floating division of dataframe and other, element-wise (binary operator `truediv`). Equivalent to ``dataframe / other``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `rtruediv`. Among flexible wrappers (`add`, `sub`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.divide", "label": "divide", "shape": "dot", "size": 20, "title": "NAME: divide\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Floating division of dataframe and other, element-wise (binary operator `truediv`). Equivalent to ``dataframe / other``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `rtruediv`. Among flexible wrappers (`add`, `sub`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.dot", "label": "dot", "shape": "dot", "size": 20, "title": "NAME: dot\n------------------------------\nINPUTS: self, other\nOUTPUTS: DataFrame | Series\n------------------------------\nDESCRIPTION: Compute the matrix multiplication between the DataFrame and other. This method computes the matrix product between the DataFrame and the values of an other Series, DataFrame or a numpy array. It can also be called using ``self @ other``. Parameters...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[0, 1, -2, -1], [1, 1, 1, 1]])\n\u003e\u003e\u003e s = pd.Series([1, 1, 2, 1])\n\u003e\u003e\u003e df.dot(s)\n0    -4\n1     5\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.drop", "label": "drop", "shape": "dot", "size": 20, "title": "NAME: drop\n------------------------------\nINPUTS: self, labels, axis, index, columns, level, inplace, errors\nOUTPUTS: DataFrame | None\n------------------------------\nDESCRIPTION: Drop specified labels from rows or columns. Remove rows or columns by specifying label names and corresponding axis, or by directly specifying index or column names. When using a multi-index, labels on different levels can be removed by specifying the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(np.arange(12).reshape(3, 4),\n...                   columns=[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027, \u0027D\u0027])\n\u003e\u003e\u003e df\n   A  B   C   D\n0  0  1   2   3\n1  4  5   6   7\n2  8  9  10  11"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.drop_duplicates", "label": "drop_duplicates", "shape": "dot", "size": 20, "title": "NAME: drop_duplicates\n------------------------------\nINPUTS: self, subset, keep, inplace, ignore_index\nOUTPUTS: DataFrame | None\n------------------------------\nDESCRIPTION: Return DataFrame with duplicate rows removed. Considering certain columns is optional. Indexes, including time indexes are ignored. Parameters ---------- subset : column label or sequence of labels, optional Only consider certain columns for identifying duplicates, by default use all of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\n...     \u0027brand\u0027: [\u0027Yum Yum\u0027, \u0027Yum Yum\u0027, \u0027Indomie\u0027, \u0027Indomie\u0027, \u0027Indomie\u0027],\n...     \u0027style\u0027: [\u0027cup\u0027, \u0027cup\u0027, \u0027cup\u0027, \u0027pack\u0027, \u0027pack\u0027],\n...     \u0027rating\u0027: [4, 4, 3.5, 15, 5]\n... })\n\u003e\u003e\u003e df\n    brand style  rating\n0  Yum Yum   cup     4.0\n1  Yum Yum   cup     4.0\n2  Indomie   cup     3.5\n3  Indomie  pack    15.0\n4  Indomie  pack     5.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.droplevel", "label": "droplevel", "shape": "dot", "size": 20, "title": "NAME: droplevel\n------------------------------\nINPUTS: self, level, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return Series/DataFrame with requested index / column level(s) removed. Parameters ---------- level : int, str, or list-like If a string is given, must be the name of a level If list-like, elements must be names or positional indexes of levels....\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([\n...     [1, 2, 3, 4],\n...     [5, 6, 7, 8],\n...     [9, 10, 11, 12]\n... ]).set_index([0, 1]).rename_axis([\u0027a\u0027, \u0027b\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.dropna", "label": "dropna", "shape": "dot", "size": 20, "title": "NAME: dropna\n------------------------------\nINPUTS: self, axis, how, thresh, subset, inplace, ignore_index\nOUTPUTS: DataFrame | None\n------------------------------\nDESCRIPTION: Remove missing values. See the :ref:`User Guide \u003cmissing_data\u003e` for more on which values are considered missing, and how to work with missing data. Parameters ---------- axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 Determine if rows or columns...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"name\": [\u0027Alfred\u0027, \u0027Batman\u0027, \u0027Catwoman\u0027],\n...                    \"toy\": [np.nan, \u0027Batmobile\u0027, \u0027Bullwhip\u0027],\n...                    \"born\": [pd.NaT, pd.Timestamp(\"1940-04-25\"),\n...                             pd.NaT]})\n\u003e\u003e\u003e df\n       name        toy       born\n0    Alfred        NaN        NaT\n1    Batman  Batmobile 1940-04-25\n2  Catwoman   Bullwhip        NaT"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.duplicated", "label": "duplicated", "shape": "dot", "size": 20, "title": "NAME: duplicated\n------------------------------\nINPUTS: self, subset, keep\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return boolean Series denoting duplicate rows. Considering certain columns is optional. Parameters ---------- subset : column label or sequence of labels, optional Only consider certain columns for identifying duplicates, by default use all of the columns. keep : {\u0027first\u0027, \u0027last\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\n...     \u0027brand\u0027: [\u0027Yum Yum\u0027, \u0027Yum Yum\u0027, \u0027Indomie\u0027, \u0027Indomie\u0027, \u0027Indomie\u0027],\n...     \u0027style\u0027: [\u0027cup\u0027, \u0027cup\u0027, \u0027cup\u0027, \u0027pack\u0027, \u0027pack\u0027],\n...     \u0027rating\u0027: [4, 4, 3.5, 15, 5]\n... })\n\u003e\u003e\u003e df\n    brand style  rating\n0  Yum Yum   cup     4.0\n1  Yum Yum   cup     4.0\n2  Indomie   cup     3.5\n3  Indomie  pack    15.0\n4  Indomie  pack     5.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.eq", "label": "eq", "shape": "dot", "size": 20, "title": "NAME: eq\n------------------------------\nINPUTS: self, other, axis, level\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Equal to of dataframe and other, element-wise (binary operator `eq`). Among flexible wrappers (`eq`, `ne`, `le`, `lt`, `ge`, `gt`) to comparison operators. Equivalent to `==`, `!=`, `\u003c=`, `\u003c`, `\u003e=`, `\u003e` with support to choose axis (rows or columns) and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027cost\u0027: [250, 150, 100],\n...                    \u0027revenue\u0027: [100, 250, 300]},\n...                   index=[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027])\n\u003e\u003e\u003e df\n   cost  revenue\nA   250      100\nB   150      250\nC   100      300"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.equals", "label": "equals", "shape": "dot", "size": 20, "title": "NAME: equals\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool_t\n------------------------------\nDESCRIPTION: Test whether two objects contain the same elements. This function allows two Series or DataFrames to be compared against each other to see if they have the same shape and elements. NaNs in the same location are considered equal. The...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({1: [10], 2: [20]})\n\u003e\u003e\u003e df\n    1   2\n0  10  20"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.eval", "label": "eval", "shape": "dot", "size": 20, "title": "NAME: eval\n------------------------------\nINPUTS: self, expr, inplace, kwargs\nOUTPUTS: Any | None\n------------------------------\nDESCRIPTION: Evaluate a string describing operations on DataFrame columns. Operates on columns only, not specific rows or elements. This allows `eval` to run arbitrary code, which can make you vulnerable to code injection if you pass user input to this function....\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: range(1, 6), \u0027B\u0027: range(10, 0, -2)})\n\u003e\u003e\u003e df\n   A   B\n0  1  10\n1  2   8\n2  3   6\n3  4   4\n4  5   2\n\u003e\u003e\u003e df.eval(\u0027A + B\u0027)\n0    11\n1    10\n2     9\n3     8\n4     7\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.ewm", "label": "ewm", "shape": "dot", "size": 20, "title": "NAME: ewm\n------------------------------\nINPUTS: self, com, span, halflife, alpha, min_periods, adjust, ignore_na, axis, times, method\nOUTPUTS: ExponentialMovingWindow\n------------------------------\nDESCRIPTION: Provide exponentially weighted (EW) calculations. Exactly one of ``com``, ``span``, ``halflife``, or ``alpha`` must be provided if ``times`` is not provided. If ``times`` is provided, ``halflife`` and one of ``com``, ``span`` or ``alpha`` may be provided. Parameters ---------- com :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027B\u0027: [0, 1, 2, np.nan, 4]})\n\u003e\u003e\u003e df\n     B\n0  0.0\n1  1.0\n2  2.0\n3  NaN\n4  4.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.expanding", "label": "expanding", "shape": "dot", "size": 20, "title": "NAME: expanding\n------------------------------\nINPUTS: self, min_periods, axis, method\nOUTPUTS: Expanding\n------------------------------\nDESCRIPTION: Provide expanding window calculations. Parameters ---------- min_periods : int, default 1 Minimum number of observations in window required to have a value; otherwise, result is ``np.nan``. axis : int or str, default 0 If ``0`` or ``\u0027index\u0027``, roll across the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"B\": [0, 1, 2, np.nan, 4]})\n\u003e\u003e\u003e df\n     B\n0  0.0\n1  1.0\n2  2.0\n3  NaN\n4  4.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.explode", "label": "explode", "shape": "dot", "size": 20, "title": "NAME: explode\n------------------------------\nINPUTS: self, column, ignore_index\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Transform each element of a list-like to a row, replicating index values. Parameters ---------- column : IndexLabel Column(s) to explode. For multiple columns, specify a non-empty list with each element be str or tuple, and all specified columns their list-like...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [[0, 1, 2], \u0027foo\u0027, [], [3, 4]],\n...                    \u0027B\u0027: 1,\n...                    \u0027C\u0027: [[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], np.nan, [], [\u0027d\u0027, \u0027e\u0027]]})\n\u003e\u003e\u003e df\n           A  B          C\n0  [0, 1, 2]  1  [a, b, c]\n1        foo  1        NaN\n2         []  1         []\n3     [3, 4]  1     [d, e]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.ffill", "label": "ffill", "shape": "dot", "size": 20, "title": "NAME: ffill\n------------------------------\nINPUTS: self, axis, inplace, limit, limit_area, downcast\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Fill NA/NaN values by propagating the last valid observation to next valid. Parameters ---------- axis : {0 or \u0027index\u0027} for Series, {0 or \u0027index\u0027, 1 or \u0027columns\u0027} for DataFrame Axis along which to fill missing values. For `Series` this parameter...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[np.nan, 2, np.nan, 0],\n...                    [3, 4, np.nan, 1],\n...                    [np.nan, np.nan, np.nan, np.nan],\n...                    [np.nan, 3, np.nan, 4]],\n...                   columns=list(\"ABCD\"))\n\u003e\u003e\u003e df\n     A    B   C    D\n0  NaN  2.0 NaN  0.0\n1  3.0  4.0 NaN  1.0\n2  NaN  NaN NaN  NaN\n3  NaN  3.0 NaN  4.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.fillna", "label": "fillna", "shape": "dot", "size": 20, "title": "NAME: fillna\n------------------------------\nINPUTS: self, value, method, axis, inplace, limit, downcast\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Fill NA/NaN values using the specified method. Parameters ---------- value : scalar, dict, Series, or DataFrame Value to use to fill holes (e.g. 0), alternately a dict/Series/DataFrame of values specifying which value to use for each index (for a Series)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[np.nan, 2, np.nan, 0],\n...                    [3, 4, np.nan, 1],\n...                    [np.nan, np.nan, np.nan, np.nan],\n...                    [np.nan, 3, np.nan, 4]],\n...                   columns=list(\"ABCD\"))\n\u003e\u003e\u003e df\n     A    B   C    D\n0  NaN  2.0 NaN  0.0\n1  3.0  4.0 NaN  1.0\n2  NaN  NaN NaN  NaN\n3  NaN  3.0 NaN  4.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.filter", "label": "filter", "shape": "dot", "size": 20, "title": "NAME: filter\n------------------------------\nINPUTS: self, items, like, regex, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Subset the dataframe rows or columns according to the specified index labels. Note that this routine does not filter a dataframe on its contents. The filter is applied to the labels of the index. Parameters ---------- items : list-like Keep...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(np.array(([1, 2, 3], [4, 5, 6])),\n...                   index=[\u0027mouse\u0027, \u0027rabbit\u0027],\n...                   columns=[\u0027one\u0027, \u0027two\u0027, \u0027three\u0027])\n\u003e\u003e\u003e df\n        one  two  three\nmouse     1    2      3\nrabbit    4    5      6"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.first", "label": "first", "shape": "dot", "size": 20, "title": "NAME: first\n------------------------------\nINPUTS: self, offset\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Select initial periods of time series data based on a date offset. .. deprecated:: 2.1 :meth:`.first` is deprecated and will be removed in a future version. Please create a mask and filter using `.loc` instead. For a DataFrame with a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e i = pd.date_range(\u00272018-04-09\u0027, periods=4, freq=\u00272D\u0027)\n\u003e\u003e\u003e ts = pd.DataFrame({\u0027A\u0027: [1, 2, 3, 4]}, index=i)\n\u003e\u003e\u003e ts\n            A\n2018-04-09  1\n2018-04-11  2\n2018-04-13  3\n2018-04-15  4"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.first_valid_index", "label": "first_valid_index", "shape": "dot", "size": 20, "title": "NAME: first_valid_index\n------------------------------\nINPUTS: self\nOUTPUTS: Hashable | None\n------------------------------\nDESCRIPTION: Return index for first non-NA value or None, if no non-NA value is found. Returns ------- type of index Examples -------- For Series: \u003e\u003e\u003e s = pd.Series([None, 3, 4]) \u003e\u003e\u003e s.first_valid_index() 1 \u003e\u003e\u003e s.last_valid_index() 2 \u003e\u003e\u003e s = pd.Series([None, None])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([None, 3, 4])\n\u003e\u003e\u003e s.first_valid_index()\n1\n\u003e\u003e\u003e s.last_valid_index()\n2"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.floordiv", "label": "floordiv", "shape": "dot", "size": 20, "title": "NAME: floordiv\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Integer division of dataframe and other, element-wise (binary operator `floordiv`). Equivalent to ``dataframe // other``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `rfloordiv`. Among flexible wrappers (`add`, `sub`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.from_dict", "label": "from_dict", "shape": "dot", "size": 20, "title": "NAME: from_dict\n------------------------------\nINPUTS: data, orient, dtype, columns\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Construct DataFrame from dict of array-like or dicts. Creates DataFrame object from dictionary by columns or by index allowing dtype specification. Parameters ---------- data : dict Of the form {field : array-like} or {field : dict}. orient : {\u0027columns\u0027, \u0027index\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e data = {\u0027col_1\u0027: [3, 2, 1, 0], \u0027col_2\u0027: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027]}\n\u003e\u003e\u003e pd.DataFrame.from_dict(data)\n   col_1 col_2\n0      3     a\n1      2     b\n2      1     c\n3      0     d"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.from_records", "label": "from_records", "shape": "dot", "size": 20, "title": "NAME: from_records\n------------------------------\nINPUTS: data, index, exclude, columns, coerce_float, nrows\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Convert structured or record ndarray to DataFrame. Creates a DataFrame object from a structured ndarray, sequence of tuples or dicts, or DataFrame. Parameters ---------- data : structured ndarray, sequence of tuples or dicts, or DataFrame Structured input data. .. deprecated::...\n\n\nEXAMPLE:\n\u003e\u003e\u003e data = np.array([(3, \u0027a\u0027), (2, \u0027b\u0027), (1, \u0027c\u0027), (0, \u0027d\u0027)],\n...                 dtype=[(\u0027col_1\u0027, \u0027i4\u0027), (\u0027col_2\u0027, \u0027U1\u0027)])\n\u003e\u003e\u003e pd.DataFrame.from_records(data)\n   col_1 col_2\n0      3     a\n1      2     b\n2      1     c\n3      0     d"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.ge", "label": "ge", "shape": "dot", "size": 20, "title": "NAME: ge\n------------------------------\nINPUTS: self, other, axis, level\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Greater than or equal to of dataframe and other, element-wise (binary operator `ge`). Among flexible wrappers (`eq`, `ne`, `le`, `lt`, `ge`, `gt`) to comparison operators. Equivalent to `==`, `!=`, `\u003c=`, `\u003c`, `\u003e=`, `\u003e` with support to choose axis (rows...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027cost\u0027: [250, 150, 100],\n...                    \u0027revenue\u0027: [100, 250, 300]},\n...                   index=[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027])\n\u003e\u003e\u003e df\n   cost  revenue\nA   250      100\nB   150      250\nC   100      300"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.get", "label": "get", "shape": "dot", "size": 20, "title": "NAME: get\n------------------------------\nINPUTS: self, key, default\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Get item from object for given key (ex: DataFrame column). Returns default value if not found. Parameters ---------- key : object Returns ------- same type as items contained in object Examples -------- \u003e\u003e\u003e df = pd.DataFrame( ... [ ... [24.3,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(\n...     [\n...         [24.3, 75.7, \"high\"],\n...         [31, 87.8, \"high\"],\n...         [22, 71.6, \"medium\"],\n...         [35, 95, \"medium\"],\n...     ],\n...     columns=[\"temp_celsius\", \"temp_fahrenheit\", \"windspeed\"],\n...     index=pd.date_range(start=\"2014-02-12\", end=\"2014-02-15\", freq=\"D\"),\n... )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.groupby", "label": "groupby", "shape": "dot", "size": 20, "title": "NAME: groupby\n------------------------------\nINPUTS: self, by, axis, level, as_index, sort, group_keys, observed, dropna\nOUTPUTS: DataFrameGroupBy\n------------------------------\nDESCRIPTION: Group DataFrame using a mapper or by a Series of columns. A groupby operation involves some combination of splitting the object, applying a function, and combining the results. This can be used to group large amounts of data and compute...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027Animal\u0027: [\u0027Falcon\u0027, \u0027Falcon\u0027,\n...                               \u0027Parrot\u0027, \u0027Parrot\u0027],\n...                    \u0027Max Speed\u0027: [380., 370., 24., 26.]})\n\u003e\u003e\u003e df\n   Animal  Max Speed\n0  Falcon      380.0\n1  Falcon      370.0\n2  Parrot       24.0\n3  Parrot       26.0\n\u003e\u003e\u003e df.groupby([\u0027Animal\u0027]).mean()\n        Max Speed\nAnimal\nFalcon      375.0\nParrot       25.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.gt", "label": "gt", "shape": "dot", "size": 20, "title": "NAME: gt\n------------------------------\nINPUTS: self, other, axis, level\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Greater than of dataframe and other, element-wise (binary operator `gt`). Among flexible wrappers (`eq`, `ne`, `le`, `lt`, `ge`, `gt`) to comparison operators. Equivalent to `==`, `!=`, `\u003c=`, `\u003c`, `\u003e=`, `\u003e` with support to choose axis (rows or columns) and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027cost\u0027: [250, 150, 100],\n...                    \u0027revenue\u0027: [100, 250, 300]},\n...                   index=[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027])\n\u003e\u003e\u003e df\n   cost  revenue\nA   250      100\nB   150      250\nC   100      300"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.head", "label": "head", "shape": "dot", "size": 20, "title": "NAME: head\n------------------------------\nINPUTS: self, n\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return the first `n` rows. This function returns the first `n` rows for the object based on position. It is useful for quickly testing if your object has the right type of data in it. For negative values of `n`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027animal\u0027: [\u0027alligator\u0027, \u0027bee\u0027, \u0027falcon\u0027, \u0027lion\u0027,\n...                    \u0027monkey\u0027, \u0027parrot\u0027, \u0027shark\u0027, \u0027whale\u0027, \u0027zebra\u0027]})\n\u003e\u003e\u003e df\n      animal\n0  alligator\n1        bee\n2     falcon\n3       lion\n4     monkey\n5     parrot\n6      shark\n7      whale\n8      zebra"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.hist", "label": "hist", "shape": "dot", "size": 20, "title": "NAME: hist\n------------------------------\nINPUTS: data, column, by, grid, xlabelsize, xrot, ylabelsize, yrot, ax, sharex, sharey, figsize, layout, bins, backend, legend, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Make a histogram of the DataFrame\u0027s columns. A `histogram`_ is a representation of the distribution of data. This function calls :meth:`matplotlib.pyplot.hist`, on each series in the DataFrame, resulting in one histogram per column. .. _histogram: https://en.wikipedia.org/wiki/Histogram Parameters ---------- data :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e data = {\u0027length\u0027: [1.5, 0.5, 1.2, 0.9, 3],\n    ...         \u0027width\u0027: [0.7, 0.2, 0.15, 0.2, 1.1]}\n    \u003e\u003e\u003e index = [\u0027pig\u0027, \u0027rabbit\u0027, \u0027duck\u0027, \u0027chicken\u0027, \u0027horse\u0027]\n    \u003e\u003e\u003e df = pd.DataFrame(data, index=index)\n    \u003e\u003e\u003e hist = df.hist(bins=3)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.idxmax", "label": "idxmax", "shape": "dot", "size": 20, "title": "NAME: idxmax\n------------------------------\nINPUTS: self, axis, skipna, numeric_only\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return index of first occurrence of maximum over requested axis. NA/null values are excluded. Parameters ---------- axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 The axis to use. 0 or \u0027index\u0027 for row-wise, 1 or \u0027columns\u0027 for column-wise....\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027consumption\u0027: [10.51, 103.11, 55.48],\n...                     \u0027co2_emissions\u0027: [37.2, 19.66, 1712]},\n...                   index=[\u0027Pork\u0027, \u0027Wheat Products\u0027, \u0027Beef\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.idxmin", "label": "idxmin", "shape": "dot", "size": 20, "title": "NAME: idxmin\n------------------------------\nINPUTS: self, axis, skipna, numeric_only\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return index of first occurrence of minimum over requested axis. NA/null values are excluded. Parameters ---------- axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 The axis to use. 0 or \u0027index\u0027 for row-wise, 1 or \u0027columns\u0027 for column-wise....\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027consumption\u0027: [10.51, 103.11, 55.48],\n...                     \u0027co2_emissions\u0027: [37.2, 19.66, 1712]},\n...                   index=[\u0027Pork\u0027, \u0027Wheat Products\u0027, \u0027Beef\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.infer_objects", "label": "infer_objects", "shape": "dot", "size": 20, "title": "NAME: infer_objects\n------------------------------\nINPUTS: self, copy\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Attempt to infer better dtypes for object columns. Attempts soft conversion of object-dtyped columns, leaving non-object and unconvertible columns unchanged. The inference rules are the same as during normal Series/DataFrame construction. Parameters ---------- copy : bool, default True Whether to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"A\": [\"a\", 1, 2, 3]})\n\u003e\u003e\u003e df = df.iloc[1:]\n\u003e\u003e\u003e df\n   A\n1  1\n2  2\n3  3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.info", "label": "info", "shape": "dot", "size": 20, "title": "NAME: info\n------------------------------\nINPUTS: self, verbose, buf, max_cols, memory_usage, show_counts\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Print a concise summary of a DataFrame. This method prints information about a DataFrame including the index dtype and columns, non-null values and memory usage. Parameters ---------- verbose : bool, optional Whether to print the full summary. By default, the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e int_values = [1, 2, 3, 4, 5]\n\u003e\u003e\u003e text_values = [\u0027alpha\u0027, \u0027beta\u0027, \u0027gamma\u0027, \u0027delta\u0027, \u0027epsilon\u0027]\n\u003e\u003e\u003e float_values = [0.0, 0.25, 0.5, 0.75, 1.0]\n\u003e\u003e\u003e df = pd.DataFrame({\"int_col\": int_values, \"text_col\": text_values,\n...                   \"float_col\": float_values})\n\u003e\u003e\u003e df\n    int_col text_col  float_col\n0        1    alpha       0.00\n1        2     beta       0.25\n2        3    gamma       0.50\n3        4    delta       0.75\n4        5  epsilon       1.00"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.insert", "label": "insert", "shape": "dot", "size": 20, "title": "NAME: insert\n------------------------------\nINPUTS: self, loc, column, value, allow_duplicates\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Insert column into DataFrame at specified location. Raises a ValueError if `column` is already contained in the DataFrame, unless `allow_duplicates` is set to True. Parameters ---------- loc : int Insertion index. Must verify 0 \u003c= loc \u003c= len(columns). column :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027col1\u0027: [1, 2], \u0027col2\u0027: [3, 4]})\n\u003e\u003e\u003e df\n   col1  col2\n0     1     3\n1     2     4\n\u003e\u003e\u003e df.insert(1, \"newcol\", [99, 99])\n\u003e\u003e\u003e df\n   col1  newcol  col2\n0     1      99     3\n1     2      99     4\n\u003e\u003e\u003e df.insert(0, \"col1\", [100, 100], allow_duplicates=True)\n\u003e\u003e\u003e df\n   col1  col1  newcol  col2\n0   100     1      99     3\n1   100     2      99     4"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.interpolate", "label": "interpolate", "shape": "dot", "size": 20, "title": "NAME: interpolate\n------------------------------\nINPUTS: self, method, axis, limit, inplace, limit_direction, limit_area, downcast, kwargs\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Fill NaN values using an interpolation method. Please note that only ``method=\u0027linear\u0027`` is supported for DataFrame/Series with a MultiIndex. Parameters ---------- method : str, default \u0027linear\u0027 Interpolation technique to use. One of: * \u0027linear\u0027: Ignore the index and treat the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([0, 1, np.nan, 3])\n\u003e\u003e\u003e s\n0    0.0\n1    1.0\n2    NaN\n3    3.0\ndtype: float64\n\u003e\u003e\u003e s.interpolate()\n0    0.0\n1    1.0\n2    2.0\n3    3.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.isetitem", "label": "isetitem", "shape": "dot", "size": 20, "title": "NAME: isetitem\n------------------------------\nINPUTS: self, loc, value\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Set the given value in the column with position `loc`. This is a positional analogue to ``__setitem__``. Parameters ---------- loc : int or sequence of ints Index position for the column. value : scalar or arraylike Value(s) for the column....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.isin", "label": "isin", "shape": "dot", "size": 20, "title": "NAME: isin\n------------------------------\nINPUTS: self, values\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Whether each element in the DataFrame is contained in values. Parameters ---------- values : iterable, Series, DataFrame or dict The result will only be true at a location if all the labels match. If `values` is a Series, that\u0027s the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027num_legs\u0027: [2, 4], \u0027num_wings\u0027: [2, 0]},\n...                   index=[\u0027falcon\u0027, \u0027dog\u0027])\n\u003e\u003e\u003e df\n        num_legs  num_wings\nfalcon         2          2\ndog            4          0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.isna", "label": "isna", "shape": "dot", "size": 20, "title": "NAME: isna\n------------------------------\nINPUTS: self\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as None or :attr:`numpy.NaN`, gets mapped to True values. Everything else gets mapped to False values. Characters such as empty strings ``\u0027\u0027`` or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(dict(age=[5, 6, np.nan],\n...                        born=[pd.NaT, pd.Timestamp(\u00271939-05-27\u0027),\n...                              pd.Timestamp(\u00271940-04-25\u0027)],\n...                        name=[\u0027Alfred\u0027, \u0027Batman\u0027, \u0027\u0027],\n...                        toy=[None, \u0027Batmobile\u0027, \u0027Joker\u0027]))\n\u003e\u003e\u003e df\n   age       born    name        toy\n0  5.0        NaT  Alfred       None\n1  6.0 1939-05-27  Batman  Batmobile\n2  NaN 1940-04-25              Joker"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.isnull", "label": "isnull", "shape": "dot", "size": 20, "title": "NAME: isnull\n------------------------------\nINPUTS: self\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: DataFrame.isnull is an alias for DataFrame.isna. Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as None or :attr:`numpy.NaN`, gets mapped to True values. Everything else gets mapped to False values. Characters...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(dict(age=[5, 6, np.nan],\n...                        born=[pd.NaT, pd.Timestamp(\u00271939-05-27\u0027),\n...                              pd.Timestamp(\u00271940-04-25\u0027)],\n...                        name=[\u0027Alfred\u0027, \u0027Batman\u0027, \u0027\u0027],\n...                        toy=[None, \u0027Batmobile\u0027, \u0027Joker\u0027]))\n\u003e\u003e\u003e df\n   age       born    name        toy\n0  5.0        NaT  Alfred       None\n1  6.0 1939-05-27  Batman  Batmobile\n2  NaN 1940-04-25              Joker"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.items", "label": "items", "shape": "dot", "size": 20, "title": "NAME: items\n------------------------------\nINPUTS: self\nOUTPUTS: Iterable[tuple[Hashable, Series]]\n------------------------------\nDESCRIPTION: Iterate over (column name, Series) pairs. Iterates over the DataFrame columns, returning a tuple with the column name and the content as a Series. Yields ------ label : object The column names for the DataFrame being iterated over. content :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027species\u0027: [\u0027bear\u0027, \u0027bear\u0027, \u0027marsupial\u0027],\n...                   \u0027population\u0027: [1864, 22000, 80000]},\n...                   index=[\u0027panda\u0027, \u0027polar\u0027, \u0027koala\u0027])\n\u003e\u003e\u003e df\n        species   population\npanda   bear      1864\npolar   bear      22000\nkoala   marsupial 80000\n\u003e\u003e\u003e for label, content in df.items():\n...     print(f\u0027label: {label}\u0027)\n...     print(f\u0027content: {content}\u0027, sep=\u0027\\n\u0027)\n...\nlabel: species\ncontent:\npanda         bear\npolar         bear\nkoala    marsupial\nName: species, dtype: object\nlabel: population\ncontent:\npanda     1864\npolar    22000\nkoala    80000\nName: population, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.iterrows", "label": "iterrows", "shape": "dot", "size": 20, "title": "NAME: iterrows\n------------------------------\nINPUTS: self\nOUTPUTS: Iterable[tuple[Hashable, Series]]\n------------------------------\nDESCRIPTION: Iterate over DataFrame rows as (index, Series) pairs. Yields ------ index : label or tuple of label The index of the row. A tuple for a `MultiIndex`. data : Series The data of the row as a Series. See Also...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[1, 1.5]], columns=[\u0027int\u0027, \u0027float\u0027])\n\u003e\u003e\u003e row = next(df.iterrows())[1]\n\u003e\u003e\u003e row\nint      1.0\nfloat    1.5\nName: 0, dtype: float64\n\u003e\u003e\u003e print(row[\u0027int\u0027].dtype)\nfloat64\n\u003e\u003e\u003e print(df[\u0027int\u0027].dtype)\nint64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.itertuples", "label": "itertuples", "shape": "dot", "size": 20, "title": "NAME: itertuples\n------------------------------\nINPUTS: self, index, name\nOUTPUTS: Iterable[tuple[Any, ...]]\n------------------------------\nDESCRIPTION: Iterate over DataFrame rows as namedtuples. Parameters ---------- index : bool, default True If True, return the index as the first element of the tuple. name : str or None, default \"Pandas\" The name of the returned namedtuples or None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027num_legs\u0027: [4, 2], \u0027num_wings\u0027: [0, 2]},\n...                   index=[\u0027dog\u0027, \u0027hawk\u0027])\n\u003e\u003e\u003e df\n      num_legs  num_wings\ndog          4          0\nhawk         2          2\n\u003e\u003e\u003e for row in df.itertuples():\n...     print(row)\n...\nPandas(Index=\u0027dog\u0027, num_legs=4, num_wings=0)\nPandas(Index=\u0027hawk\u0027, num_legs=2, num_wings=2)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.join", "label": "join", "shape": "dot", "size": 20, "title": "NAME: join\n------------------------------\nINPUTS: self, other, on, how, lsuffix, rsuffix, sort, validate\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Join columns of another DataFrame. Join columns with `other` DataFrame either on index or on a key column. Efficiently join multiple DataFrame objects by index at once by passing a list. Parameters ---------- other : DataFrame, Series, or a list...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027key\u0027: [\u0027K0\u0027, \u0027K1\u0027, \u0027K2\u0027, \u0027K3\u0027, \u0027K4\u0027, \u0027K5\u0027],\n...                    \u0027A\u0027: [\u0027A0\u0027, \u0027A1\u0027, \u0027A2\u0027, \u0027A3\u0027, \u0027A4\u0027, \u0027A5\u0027]})"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.keys", "label": "keys", "shape": "dot", "size": 20, "title": "NAME: keys\n------------------------------\nINPUTS: self\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Get the \u0027info axis\u0027 (see Indexing for more). This is index for Series, columns for DataFrame. Returns ------- Index Info axis. Examples -------- \u003e\u003e\u003e d = pd.DataFrame(data={\u0027A\u0027: [1, 2, 3], \u0027B\u0027: [0, 4, 8]}, ... index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e d...\n\n\nEXAMPLE:\n\u003e\u003e\u003e d = pd.DataFrame(data={\u0027A\u0027: [1, 2, 3], \u0027B\u0027: [0, 4, 8]},\n...                  index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e d\n   A  B\na  1  0\nb  2  4\nc  3  8\n\u003e\u003e\u003e d.keys()\nIndex([\u0027A\u0027, \u0027B\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.kurt", "label": "kurt", "shape": "dot", "size": 20, "title": "NAME: kurt\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return unbiased kurtosis over requested axis. Kurtosis obtained using Fisher\u0027s definition of kurtosis (kurtosis of normal == 0.0). Normalized by N-1. Parameters ---------- axis : {index (0), columns (1)} Axis for the function to be applied on. For `Series` this...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 2, 3], index=[\u0027cat\u0027, \u0027dog\u0027, \u0027dog\u0027, \u0027mouse\u0027])\n            \u003e\u003e\u003e s\n            cat    1\n            dog    2\n            dog    2\n            mouse  3\n            dtype: int64\n            \u003e\u003e\u003e s.kurt()\n            1.5"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.kurtosis", "label": "kurtosis", "shape": "dot", "size": 20, "title": "NAME: kurtosis\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return unbiased kurtosis over requested axis. Kurtosis obtained using Fisher\u0027s definition of kurtosis (kurtosis of normal == 0.0). Normalized by N-1. Parameters ---------- axis : {index (0), columns (1)} Axis for the function to be applied on. For `Series` this...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 2, 3], index=[\u0027cat\u0027, \u0027dog\u0027, \u0027dog\u0027, \u0027mouse\u0027])\n            \u003e\u003e\u003e s\n            cat    1\n            dog    2\n            dog    2\n            mouse  3\n            dtype: int64\n            \u003e\u003e\u003e s.kurt()\n            1.5"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.last", "label": "last", "shape": "dot", "size": 20, "title": "NAME: last\n------------------------------\nINPUTS: self, offset\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Select final periods of time series data based on a date offset. .. deprecated:: 2.1 :meth:`.last` is deprecated and will be removed in a future version. Please create a mask and filter using `.loc` instead. For a DataFrame with a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e i = pd.date_range(\u00272018-04-09\u0027, periods=4, freq=\u00272D\u0027)\n\u003e\u003e\u003e ts = pd.DataFrame({\u0027A\u0027: [1, 2, 3, 4]}, index=i)\n\u003e\u003e\u003e ts\n            A\n2018-04-09  1\n2018-04-11  2\n2018-04-13  3\n2018-04-15  4"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.last_valid_index", "label": "last_valid_index", "shape": "dot", "size": 20, "title": "NAME: last_valid_index\n------------------------------\nINPUTS: self\nOUTPUTS: Hashable | None\n------------------------------\nDESCRIPTION: Return index for last non-NA value or None, if no non-NA value is found. Returns ------- type of index Examples -------- For Series: \u003e\u003e\u003e s = pd.Series([None, 3, 4]) \u003e\u003e\u003e s.first_valid_index() 1 \u003e\u003e\u003e s.last_valid_index() 2 \u003e\u003e\u003e s = pd.Series([None, None])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([None, 3, 4])\n\u003e\u003e\u003e s.first_valid_index()\n1\n\u003e\u003e\u003e s.last_valid_index()\n2"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.le", "label": "le", "shape": "dot", "size": 20, "title": "NAME: le\n------------------------------\nINPUTS: self, other, axis, level\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Less than or equal to of dataframe and other, element-wise (binary operator `le`). Among flexible wrappers (`eq`, `ne`, `le`, `lt`, `ge`, `gt`) to comparison operators. Equivalent to `==`, `!=`, `\u003c=`, `\u003c`, `\u003e=`, `\u003e` with support to choose axis (rows...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027cost\u0027: [250, 150, 100],\n...                    \u0027revenue\u0027: [100, 250, 300]},\n...                   index=[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027])\n\u003e\u003e\u003e df\n   cost  revenue\nA   250      100\nB   150      250\nC   100      300"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.lt", "label": "lt", "shape": "dot", "size": 20, "title": "NAME: lt\n------------------------------\nINPUTS: self, other, axis, level\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Less than of dataframe and other, element-wise (binary operator `lt`). Among flexible wrappers (`eq`, `ne`, `le`, `lt`, `ge`, `gt`) to comparison operators. Equivalent to `==`, `!=`, `\u003c=`, `\u003c`, `\u003e=`, `\u003e` with support to choose axis (rows or columns) and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027cost\u0027: [250, 150, 100],\n...                    \u0027revenue\u0027: [100, 250, 300]},\n...                   index=[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027])\n\u003e\u003e\u003e df\n   cost  revenue\nA   250      100\nB   150      250\nC   100      300"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.map", "label": "map", "shape": "dot", "size": 20, "title": "NAME: map\n------------------------------\nINPUTS: self, func, na_action, kwargs\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Apply a function to a Dataframe elementwise. .. versionadded:: 2.1.0 DataFrame.applymap was deprecated and renamed to DataFrame.map. This method applies a function that accepts and returns a scalar to every element of a DataFrame. Parameters ---------- func : callable Python...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[1, 2.12], [3.356, 4.567]])\n\u003e\u003e\u003e df\n       0      1\n0  1.000  2.120\n1  3.356  4.567"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.mask", "label": "mask", "shape": "dot", "size": 20, "title": "NAME: mask\n------------------------------\nINPUTS: self, cond, other, inplace, axis, level\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Replace values where the condition is True. Parameters ---------- cond : bool Series/DataFrame, array-like, or callable Where `cond` is False, keep the original value. Where True, replace with corresponding value from `other`. If `cond` is callable, it is computed on...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(range(5))\n\u003e\u003e\u003e s.where(s \u003e 0)\n0    NaN\n1    1.0\n2    2.0\n3    3.0\n4    4.0\ndtype: float64\n\u003e\u003e\u003e s.mask(s \u003e 0)\n0    0.0\n1    NaN\n2    NaN\n3    NaN\n4    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.max", "label": "max", "shape": "dot", "size": 20, "title": "NAME: max\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the maximum of the values over the requested axis. If you want the *index* of the maximum, use ``idxmax``. This is the equivalent of the ``numpy.ndarray`` method ``argmax``. Parameters ---------- axis : {index (0), columns (1)} Axis for the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.MultiIndex.from_arrays([\n...     [\u0027warm\u0027, \u0027warm\u0027, \u0027cold\u0027, \u0027cold\u0027],\n...     [\u0027dog\u0027, \u0027falcon\u0027, \u0027fish\u0027, \u0027spider\u0027]],\n...     names=[\u0027blooded\u0027, \u0027animal\u0027])\n\u003e\u003e\u003e s = pd.Series([4, 2, 0, 8], name=\u0027legs\u0027, index=idx)\n\u003e\u003e\u003e s\nblooded  animal\nwarm     dog       4\n         falcon    2\ncold     fish      0\n         spider    8\nName: legs, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.mean", "label": "mean", "shape": "dot", "size": 20, "title": "NAME: mean\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the mean of the values over the requested axis. Parameters ---------- axis : {index (0), columns (1)} Axis for the function to be applied on. For `Series` this parameter is unused and defaults to 0. For DataFrames, specifying ``axis=None``...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n            \u003e\u003e\u003e s.mean()\n            2.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.median", "label": "median", "shape": "dot", "size": 20, "title": "NAME: median\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the median of the values over the requested axis. Parameters ---------- axis : {index (0), columns (1)} Axis for the function to be applied on. For `Series` this parameter is unused and defaults to 0. For DataFrames, specifying ``axis=None``...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n            \u003e\u003e\u003e s.median()\n            2.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.melt", "label": "melt", "shape": "dot", "size": 20, "title": "NAME: melt\n------------------------------\nINPUTS: self, id_vars, value_vars, var_name, value_name, col_level, ignore_index\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Unpivot a DataFrame from wide to long format, optionally leaving identifiers set. This function is useful to massage a DataFrame into a format where one or more columns are identifier variables (`id_vars`), while all other columns, considered measured variables (`value_vars`),...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: {0: \u0027a\u0027, 1: \u0027b\u0027, 2: \u0027c\u0027},\n...                    \u0027B\u0027: {0: 1, 1: 3, 2: 5},\n...                    \u0027C\u0027: {0: 2, 1: 4, 2: 6}})\n\u003e\u003e\u003e df\n   A  B  C\n0  a  1  2\n1  b  3  4\n2  c  5  6"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.memory_usage", "label": "memory_usage", "shape": "dot", "size": 20, "title": "NAME: memory_usage\n------------------------------\nINPUTS: self, index, deep\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return the memory usage of each column in bytes. The memory usage can optionally include the contribution of the index and elements of `object` dtype. This value is displayed in `DataFrame.info` by default. This can be suppressed by setting ``pandas.options.display.memory_usage``...\n\n\nEXAMPLE:\n\u003e\u003e\u003e dtypes = [\u0027int64\u0027, \u0027float64\u0027, \u0027complex128\u0027, \u0027object\u0027, \u0027bool\u0027]\n\u003e\u003e\u003e data = dict([(t, np.ones(shape=5000, dtype=int).astype(t))\n...              for t in dtypes])\n\u003e\u003e\u003e df = pd.DataFrame(data)\n\u003e\u003e\u003e df.head()\n   int64  float64            complex128  object  bool\n0      1      1.0              1.0+0.0j       1  True\n1      1      1.0              1.0+0.0j       1  True\n2      1      1.0              1.0+0.0j       1  True\n3      1      1.0              1.0+0.0j       1  True\n4      1      1.0              1.0+0.0j       1  True"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.merge", "label": "merge", "shape": "dot", "size": 20, "title": "NAME: merge\n------------------------------\nINPUTS: self, right, how, on, left_on, right_on, left_index, right_index, sort, suffixes, copy, indicator, validate\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Merge DataFrame or named Series objects with a database-style join. A named Series object is treated as a DataFrame with a single named column. The join is done on columns or indexes. If joining columns on columns, the DataFrame indexes...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df1 = pd.DataFrame({\u0027lkey\u0027: [\u0027foo\u0027, \u0027bar\u0027, \u0027baz\u0027, \u0027foo\u0027],\n...                     \u0027value\u0027: [1, 2, 3, 5]})\n\u003e\u003e\u003e df2 = pd.DataFrame({\u0027rkey\u0027: [\u0027foo\u0027, \u0027bar\u0027, \u0027baz\u0027, \u0027foo\u0027],\n...                     \u0027value\u0027: [5, 6, 7, 8]})\n\u003e\u003e\u003e df1\n    lkey value\n0   foo      1\n1   bar      2\n2   baz      3\n3   foo      5\n\u003e\u003e\u003e df2\n    rkey value\n0   foo      5\n1   bar      6\n2   baz      7\n3   foo      8"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.min", "label": "min", "shape": "dot", "size": 20, "title": "NAME: min\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the minimum of the values over the requested axis. If you want the *index* of the minimum, use ``idxmin``. This is the equivalent of the ``numpy.ndarray`` method ``argmin``. Parameters ---------- axis : {index (0), columns (1)} Axis for the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.MultiIndex.from_arrays([\n...     [\u0027warm\u0027, \u0027warm\u0027, \u0027cold\u0027, \u0027cold\u0027],\n...     [\u0027dog\u0027, \u0027falcon\u0027, \u0027fish\u0027, \u0027spider\u0027]],\n...     names=[\u0027blooded\u0027, \u0027animal\u0027])\n\u003e\u003e\u003e s = pd.Series([4, 2, 0, 8], name=\u0027legs\u0027, index=idx)\n\u003e\u003e\u003e s\nblooded  animal\nwarm     dog       4\n         falcon    2\ncold     fish      0\n         spider    8\nName: legs, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.mod", "label": "mod", "shape": "dot", "size": 20, "title": "NAME: mod\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Modulo of dataframe and other, element-wise (binary operator `mod`). Equivalent to ``dataframe % other``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `rmod`. Among flexible wrappers (`add`, `sub`, `mul`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.mode", "label": "mode", "shape": "dot", "size": 20, "title": "NAME: mode\n------------------------------\nINPUTS: self, axis, numeric_only, dropna\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get the mode(s) of each element along the selected axis. The mode of a set of values is the value that appears most often. It can be multiple values. Parameters ---------- axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([(\u0027bird\u0027, 2, 2),\n...                    (\u0027mammal\u0027, 4, np.nan),\n...                    (\u0027arthropod\u0027, 8, 0),\n...                    (\u0027bird\u0027, 2, np.nan)],\n...                   index=(\u0027falcon\u0027, \u0027horse\u0027, \u0027spider\u0027, \u0027ostrich\u0027),\n...                   columns=(\u0027species\u0027, \u0027legs\u0027, \u0027wings\u0027))\n\u003e\u003e\u003e df\n           species  legs  wings\nfalcon        bird     2    2.0\nhorse       mammal     4    NaN\nspider   arthropod     8    0.0\nostrich       bird     2    NaN"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.mul", "label": "mul", "shape": "dot", "size": 20, "title": "NAME: mul\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Multiplication of dataframe and other, element-wise (binary operator `mul`). Equivalent to ``dataframe * other``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `rmul`. Among flexible wrappers (`add`, `sub`, `mul`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.multiply", "label": "multiply", "shape": "dot", "size": 20, "title": "NAME: multiply\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Multiplication of dataframe and other, element-wise (binary operator `mul`). Equivalent to ``dataframe * other``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `rmul`. Among flexible wrappers (`add`, `sub`, `mul`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.ne", "label": "ne", "shape": "dot", "size": 20, "title": "NAME: ne\n------------------------------\nINPUTS: self, other, axis, level\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Not equal to of dataframe and other, element-wise (binary operator `ne`). Among flexible wrappers (`eq`, `ne`, `le`, `lt`, `ge`, `gt`) to comparison operators. Equivalent to `==`, `!=`, `\u003c=`, `\u003c`, `\u003e=`, `\u003e` with support to choose axis (rows or columns)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027cost\u0027: [250, 150, 100],\n...                    \u0027revenue\u0027: [100, 250, 300]},\n...                   index=[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027])\n\u003e\u003e\u003e df\n   cost  revenue\nA   250      100\nB   150      250\nC   100      300"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.nlargest", "label": "nlargest", "shape": "dot", "size": 20, "title": "NAME: nlargest\n------------------------------\nINPUTS: self, n, columns, keep\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Return the first `n` rows ordered by `columns` in descending order. Return the first `n` rows with the largest values in `columns`, in descending order. The columns that are not specified are returned as well, but not used for ordering....\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027population\u0027: [59000000, 65000000, 434000,\n...                                   434000, 434000, 337000, 11300,\n...                                   11300, 11300],\n...                    \u0027GDP\u0027: [1937894, 2583560 , 12011, 4520, 12128,\n...                            17036, 182, 38, 311],\n...                    \u0027alpha-2\u0027: [\"IT\", \"FR\", \"MT\", \"MV\", \"BN\",\n...                                \"IS\", \"NR\", \"TV\", \"AI\"]},\n...                   index=[\"Italy\", \"France\", \"Malta\",\n...                          \"Maldives\", \"Brunei\", \"Iceland\",\n...                          \"Nauru\", \"Tuvalu\", \"Anguilla\"])\n\u003e\u003e\u003e df\n          population      GDP alpha-2\nItaly       59000000  1937894      IT\nFrance      65000000  2583560      FR\nMalta         434000    12011      MT\nMaldives      434000     4520      MV\nBrunei        434000    12128      BN\nIceland       337000    17036      IS\nNauru          11300      182      NR\nTuvalu         11300       38      TV\nAnguilla       11300      311      AI"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.notna", "label": "notna", "shape": "dot", "size": 20, "title": "NAME: notna\n------------------------------\nINPUTS: self\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to True. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values (unless you set ``pandas.options.mode.use_inf_as_na =...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(dict(age=[5, 6, np.nan],\n...                        born=[pd.NaT, pd.Timestamp(\u00271939-05-27\u0027),\n...                              pd.Timestamp(\u00271940-04-25\u0027)],\n...                        name=[\u0027Alfred\u0027, \u0027Batman\u0027, \u0027\u0027],\n...                        toy=[None, \u0027Batmobile\u0027, \u0027Joker\u0027]))\n\u003e\u003e\u003e df\n   age       born    name        toy\n0  5.0        NaT  Alfred       None\n1  6.0 1939-05-27  Batman  Batmobile\n2  NaN 1940-04-25              Joker"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.notnull", "label": "notnull", "shape": "dot", "size": 20, "title": "NAME: notnull\n------------------------------\nINPUTS: self\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: DataFrame.notnull is an alias for DataFrame.notna. Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to True. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(dict(age=[5, 6, np.nan],\n...                        born=[pd.NaT, pd.Timestamp(\u00271939-05-27\u0027),\n...                              pd.Timestamp(\u00271940-04-25\u0027)],\n...                        name=[\u0027Alfred\u0027, \u0027Batman\u0027, \u0027\u0027],\n...                        toy=[None, \u0027Batmobile\u0027, \u0027Joker\u0027]))\n\u003e\u003e\u003e df\n   age       born    name        toy\n0  5.0        NaT  Alfred       None\n1  6.0 1939-05-27  Batman  Batmobile\n2  NaN 1940-04-25              Joker"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.nsmallest", "label": "nsmallest", "shape": "dot", "size": 20, "title": "NAME: nsmallest\n------------------------------\nINPUTS: self, n, columns, keep\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Return the first `n` rows ordered by `columns` in ascending order. Return the first `n` rows with the smallest values in `columns`, in ascending order. The columns that are not specified are returned as well, but not used for ordering....\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027population\u0027: [59000000, 65000000, 434000,\n...                                   434000, 434000, 337000, 337000,\n...                                   11300, 11300],\n...                    \u0027GDP\u0027: [1937894, 2583560 , 12011, 4520, 12128,\n...                            17036, 182, 38, 311],\n...                    \u0027alpha-2\u0027: [\"IT\", \"FR\", \"MT\", \"MV\", \"BN\",\n...                                \"IS\", \"NR\", \"TV\", \"AI\"]},\n...                   index=[\"Italy\", \"France\", \"Malta\",\n...                          \"Maldives\", \"Brunei\", \"Iceland\",\n...                          \"Nauru\", \"Tuvalu\", \"Anguilla\"])\n\u003e\u003e\u003e df\n          population      GDP alpha-2\nItaly       59000000  1937894      IT\nFrance      65000000  2583560      FR\nMalta         434000    12011      MT\nMaldives      434000     4520      MV\nBrunei        434000    12128      BN\nIceland       337000    17036      IS\nNauru         337000      182      NR\nTuvalu         11300       38      TV\nAnguilla       11300      311      AI"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.nunique", "label": "nunique", "shape": "dot", "size": 20, "title": "NAME: nunique\n------------------------------\nINPUTS: self, axis, dropna\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Count number of distinct elements in specified axis. Return Series with number of distinct elements. Can ignore NaN values. Parameters ---------- axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 The axis to use. 0 or \u0027index\u0027 for row-wise,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [4, 5, 6], \u0027B\u0027: [4, 1, 1]})\n\u003e\u003e\u003e df.nunique()\nA    3\nB    2\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.pad", "label": "pad", "shape": "dot", "size": 20, "title": "NAME: pad\n------------------------------\nINPUTS: self, axis, inplace, limit, downcast\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Fill NA/NaN values by propagating the last valid observation to next valid. .. deprecated:: 2.0 Series/DataFrame.pad is deprecated. Use Series/DataFrame.ffill instead. Returns ------- Series/DataFrame or None Object with missing values filled or None if ``inplace=True``. Examples -------- Please see examples...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.pct_change", "label": "pct_change", "shape": "dot", "size": 20, "title": "NAME: pct_change\n------------------------------\nINPUTS: self, periods, fill_method, limit, freq, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Fractional change between the current and a prior element. Computes the fractional change from the immediately previous row by default. This is useful in comparing the fraction of change in a time series of elements. .. note:: Despite the name...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([90, 91, 85])\n\u003e\u003e\u003e s\n0    90\n1    91\n2    85\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.pipe", "label": "pipe", "shape": "dot", "size": 20, "title": "NAME: pipe\n------------------------------\nINPUTS: self, func, args, kwargs\nOUTPUTS: T\n------------------------------\nDESCRIPTION: Apply chainable functions that expect Series or DataFrames. Parameters ---------- func : function Function to apply to the Series/DataFrame. ``args``, and ``kwargs`` are passed into ``func``. Alternatively a ``(callable, data_keyword)`` tuple where ``data_keyword`` is a string indicating the keyword of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e data = [[8000, 1000], [9500, np.nan], [5000, 2000]]\n\u003e\u003e\u003e df = pd.DataFrame(data, columns=[\u0027Salary\u0027, \u0027Others\u0027])\n\u003e\u003e\u003e df\n   Salary  Others\n0    8000  1000.0\n1    9500     NaN\n2    5000  2000.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.pivot", "label": "pivot", "shape": "dot", "size": 20, "title": "NAME: pivot\n------------------------------\nINPUTS: self, columns, index, values\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Return reshaped DataFrame organized by given index / column values. Reshape data (produce a \"pivot\" table) based on column values. Uses unique values from specified `index` / `columns` to form axes of the resulting DataFrame. This function does not support...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027foo\u0027: [\u0027one\u0027, \u0027one\u0027, \u0027one\u0027, \u0027two\u0027, \u0027two\u0027,\n...                            \u0027two\u0027],\n...                    \u0027bar\u0027: [\u0027A\u0027, \u0027B\u0027, \u0027C\u0027, \u0027A\u0027, \u0027B\u0027, \u0027C\u0027],\n...                    \u0027baz\u0027: [1, 2, 3, 4, 5, 6],\n...                    \u0027zoo\u0027: [\u0027x\u0027, \u0027y\u0027, \u0027z\u0027, \u0027q\u0027, \u0027w\u0027, \u0027t\u0027]})\n\u003e\u003e\u003e df\n    foo   bar  baz  zoo\n0   one   A    1    x\n1   one   B    2    y\n2   one   C    3    z\n3   two   A    4    q\n4   two   B    5    w\n5   two   C    6    t"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.pivot_table", "label": "pivot_table", "shape": "dot", "size": 20, "title": "NAME: pivot_table\n------------------------------\nINPUTS: self, values, index, columns, aggfunc, fill_value, margins, dropna, margins_name, observed, sort\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Create a spreadsheet-style pivot table as a DataFrame. The levels in the pivot table will be stored in MultiIndex objects (hierarchical indexes) on the index and columns of the result DataFrame. Parameters ---------- values : list-like or scalar, optional Column...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"A\": [\"foo\", \"foo\", \"foo\", \"foo\", \"foo\",\n...                          \"bar\", \"bar\", \"bar\", \"bar\"],\n...                    \"B\": [\"one\", \"one\", \"one\", \"two\", \"two\",\n...                          \"one\", \"one\", \"two\", \"two\"],\n...                    \"C\": [\"small\", \"large\", \"large\", \"small\",\n...                          \"small\", \"large\", \"small\", \"small\",\n...                          \"large\"],\n...                    \"D\": [1, 2, 2, 3, 3, 4, 5, 6, 7],\n...                    \"E\": [2, 4, 5, 5, 6, 6, 8, 9, 9]})\n\u003e\u003e\u003e df\n     A    B      C  D  E\n0  foo  one  small  1  2\n1  foo  one  large  2  4\n2  foo  one  large  2  5\n3  foo  two  small  3  5\n4  foo  two  small  3  6\n5  bar  one  large  4  6\n6  bar  one  small  5  8\n7  bar  two  small  6  9\n8  bar  two  large  7  9"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.DataFrame.plot", "label": "plot", "shape": "dot", "size": 20, "title": "NAME: plot\n------------------------------\nINPUTS: data\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Make plots of Series or DataFrame. Uses the backend specified by the option ``plotting.backend``. By default, matplotlib is used. Parameters ---------- data : Series or DataFrame The object for which the method is called. x : label or position, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([1, 2, 3, 3])\n    \u003e\u003e\u003e plot = ser.plot(kind=\u0027hist\u0027, title=\"My plot\")"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.pop", "label": "pop", "shape": "dot", "size": 20, "title": "NAME: pop\n------------------------------\nINPUTS: self, item\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return item and drop from frame. Raise KeyError if not found. Parameters ---------- item : label Label of column to be popped. Returns ------- Series Examples -------- \u003e\u003e\u003e df = pd.DataFrame([(\u0027falcon\u0027, \u0027bird\u0027, 389.0), ... (\u0027parrot\u0027, \u0027bird\u0027, 24.0), ... (\u0027lion\u0027, \u0027mammal\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([(\u0027falcon\u0027, \u0027bird\u0027, 389.0),\n...                    (\u0027parrot\u0027, \u0027bird\u0027, 24.0),\n...                    (\u0027lion\u0027, \u0027mammal\u0027, 80.5),\n...                    (\u0027monkey\u0027, \u0027mammal\u0027, np.nan)],\n...                   columns=(\u0027name\u0027, \u0027class\u0027, \u0027max_speed\u0027))\n\u003e\u003e\u003e df\n     name   class  max_speed\n0  falcon    bird      389.0\n1  parrot    bird       24.0\n2    lion  mammal       80.5\n3  monkey  mammal        NaN"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.pow", "label": "pow", "shape": "dot", "size": 20, "title": "NAME: pow\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Exponential power of dataframe and other, element-wise (binary operator `pow`). Equivalent to ``dataframe ** other``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `rpow`. Among flexible wrappers (`add`, `sub`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.prod", "label": "prod", "shape": "dot", "size": 20, "title": "NAME: prod\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, min_count, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the product of the values over the requested axis. Parameters ---------- axis : {index (0), columns (1)} Axis for the function to be applied on. For `Series` this parameter is unused and defaults to 0. .. warning:: The behavior...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Series([], dtype=\"float64\").prod()\n1.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.product", "label": "product", "shape": "dot", "size": 20, "title": "NAME: product\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, min_count, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the product of the values over the requested axis. Parameters ---------- axis : {index (0), columns (1)} Axis for the function to be applied on. For `Series` this parameter is unused and defaults to 0. .. warning:: The behavior...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Series([], dtype=\"float64\").prod()\n1.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.quantile", "label": "quantile", "shape": "dot", "size": 20, "title": "NAME: quantile\n------------------------------\nINPUTS: self, q, axis, numeric_only, interpolation, method\nOUTPUTS: Series | DataFrame\n------------------------------\nDESCRIPTION: Return values at the given quantile over requested axis. Parameters ---------- q : float or array-like, default 0.5 (50% quantile) Value between 0 \u003c= q \u003c= 1, the quantile(s) to compute. axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(np.array([[1, 1], [2, 10], [3, 100], [4, 100]]),\n...                   columns=[\u0027a\u0027, \u0027b\u0027])\n\u003e\u003e\u003e df.quantile(.1)\na    1.3\nb    3.7\nName: 0.1, dtype: float64\n\u003e\u003e\u003e df.quantile([.1, .5])\n       a     b\n0.1  1.3   3.7\n0.5  2.5  55.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.query", "label": "query", "shape": "dot", "size": 20, "title": "NAME: query\n------------------------------\nINPUTS: self, expr, inplace, kwargs\nOUTPUTS: DataFrame | None\n------------------------------\nDESCRIPTION: Query the columns of a DataFrame with a boolean expression. Parameters ---------- expr : str The query string to evaluate. You can refer to variables in the environment by prefixing them with an \u0027@\u0027 character like ``@a + b``. You...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: range(1, 6),\n...                    \u0027B\u0027: range(10, 0, -2),\n...                    \u0027C C\u0027: range(10, 5, -1)})\n\u003e\u003e\u003e df\n   A   B  C C\n0  1  10   10\n1  2   8    9\n2  3   6    8\n3  4   4    7\n4  5   2    6\n\u003e\u003e\u003e df.query(\u0027A \u003e B\u0027)\n   A  B  C C\n4  5  2    6"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.radd", "label": "radd", "shape": "dot", "size": 20, "title": "NAME: radd\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Addition of dataframe and other, element-wise (binary operator `radd`). Equivalent to ``other + dataframe``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `add`. Among flexible wrappers (`add`, `sub`, `mul`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.rank", "label": "rank", "shape": "dot", "size": 20, "title": "NAME: rank\n------------------------------\nINPUTS: self, axis, method, numeric_only, na_option, ascending, pct\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Compute numerical data ranks (1 through n) along axis. By default, equal values are assigned a rank that is the average of the ranks of those values. Parameters ---------- axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 Index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(data={\u0027Animal\u0027: [\u0027cat\u0027, \u0027penguin\u0027, \u0027dog\u0027,\n...                                    \u0027spider\u0027, \u0027snake\u0027],\n...                         \u0027Number_legs\u0027: [4, 2, 4, 8, np.nan]})\n\u003e\u003e\u003e df\n    Animal  Number_legs\n0      cat          4.0\n1  penguin          2.0\n2      dog          4.0\n3   spider          8.0\n4    snake          NaN"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.rdiv", "label": "rdiv", "shape": "dot", "size": 20, "title": "NAME: rdiv\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Floating division of dataframe and other, element-wise (binary operator `rtruediv`). Equivalent to ``other / dataframe``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `truediv`. Among flexible wrappers (`add`, `sub`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.reindex", "label": "reindex", "shape": "dot", "size": 20, "title": "NAME: reindex\n------------------------------\nINPUTS: self, labels, index, columns, axis, method, copy, level, fill_value, limit, tolerance\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Conform DataFrame to new index with optional filling logic. Places NA/NaN in locations having no value in the previous index. A new object is produced unless the new index is equivalent to the current one and ``copy=False``. Parameters ---------- labels...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = [\u0027Firefox\u0027, \u0027Chrome\u0027, \u0027Safari\u0027, \u0027IE10\u0027, \u0027Konqueror\u0027]\n\u003e\u003e\u003e df = pd.DataFrame({\u0027http_status\u0027: [200, 200, 404, 404, 301],\n...                   \u0027response_time\u0027: [0.04, 0.02, 0.07, 0.08, 1.0]},\n...                   index=index)\n\u003e\u003e\u003e df\n           http_status  response_time\nFirefox            200           0.04\nChrome             200           0.02\nSafari             404           0.07\nIE10               404           0.08\nKonqueror          301           1.00"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.reindex_like", "label": "reindex_like", "shape": "dot", "size": 20, "title": "NAME: reindex_like\n------------------------------\nINPUTS: self, other, method, copy, limit, tolerance\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return an object with matching indices as other object. Conform the object to the same index on all axes. Optional filling logic, placing NaN in locations having no value in the previous index. A new object is produced unless the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df1 = pd.DataFrame([[24.3, 75.7, \u0027high\u0027],\n...                     [31, 87.8, \u0027high\u0027],\n...                     [22, 71.6, \u0027medium\u0027],\n...                     [35, 95, \u0027medium\u0027]],\n...                    columns=[\u0027temp_celsius\u0027, \u0027temp_fahrenheit\u0027,\n...                             \u0027windspeed\u0027],\n...                    index=pd.date_range(start=\u00272014-02-12\u0027,\n...                                        end=\u00272014-02-15\u0027, freq=\u0027D\u0027))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.rename", "label": "rename", "shape": "dot", "size": 20, "title": "NAME: rename\n------------------------------\nINPUTS: self, mapper, index, columns, axis, copy, inplace, level, errors\nOUTPUTS: DataFrame | None\n------------------------------\nDESCRIPTION: Rename columns or index labels. Function / dict values must be unique (1-to-1). Labels not contained in a dict / Series will be left as-is. Extra labels listed don\u0027t throw an error. See the :ref:`user guide \u003cbasics.rename\u003e` for more. Parameters...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]})\n\u003e\u003e\u003e df.rename(columns={\"A\": \"a\", \"B\": \"c\"})\n   a  c\n0  1  4\n1  2  5\n2  3  6"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.rename_axis", "label": "rename_axis", "shape": "dot", "size": 20, "title": "NAME: rename_axis\n------------------------------\nINPUTS: self, mapper, index, columns, axis, copy, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Set the name of the axis for the index or columns. Parameters ---------- mapper : scalar, list-like, optional Value to set the axis name attribute. index, columns : scalar, list-like, dict-like or function, optional A scalar, list-like, dict-like or functions...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\"dog\", \"cat\", \"monkey\"])\n\u003e\u003e\u003e s\n0       dog\n1       cat\n2    monkey\ndtype: object\n\u003e\u003e\u003e s.rename_axis(\"animal\")\nanimal\n0    dog\n1    cat\n2    monkey\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.reorder_levels", "label": "reorder_levels", "shape": "dot", "size": 20, "title": "NAME: reorder_levels\n------------------------------\nINPUTS: self, order, axis\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Rearrange index levels using input order. May not drop or duplicate levels. Parameters ---------- order : list of int or list of str List representing new level order. Reference level by number (position) or by key (label). axis : {0...\n\n\nEXAMPLE:\n\u003e\u003e\u003e data = {\n...     \"class\": [\"Mammals\", \"Mammals\", \"Reptiles\"],\n...     \"diet\": [\"Omnivore\", \"Carnivore\", \"Carnivore\"],\n...     \"species\": [\"Humans\", \"Dogs\", \"Snakes\"],\n... }\n\u003e\u003e\u003e df = pd.DataFrame(data, columns=[\"class\", \"diet\", \"species\"])\n\u003e\u003e\u003e df = df.set_index([\"class\", \"diet\"])\n\u003e\u003e\u003e df\n                                  species\nclass      diet\nMammals    Omnivore                Humans\n           Carnivore                 Dogs\nReptiles   Carnivore               Snakes"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.replace", "label": "replace", "shape": "dot", "size": 20, "title": "NAME: replace\n------------------------------\nINPUTS: self, to_replace, value, inplace, limit, regex, method\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Replace values given in `to_replace` with `value`. Values of the Series/DataFrame are replaced with other values dynamically. This differs from updating with ``.loc`` or ``.iloc``, which require you to specify a location to update with some value. Parameters ---------- to_replace...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3, 4, 5])\n\u003e\u003e\u003e s.replace(1, 5)\n0    5\n1    2\n2    3\n3    4\n4    5\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.resample", "label": "resample", "shape": "dot", "size": 20, "title": "NAME: resample\n------------------------------\nINPUTS: self, rule, axis, closed, label, convention, kind, on, level, origin, offset, group_keys\nOUTPUTS: Resampler\n------------------------------\nDESCRIPTION: Resample time-series data. Convenience method for frequency conversion and resampling of time series. The object must have a datetime-like index (`DatetimeIndex`, `PeriodIndex`, or `TimedeltaIndex`), or the caller must pass the label of a datetime-like series/index to the ``on``/``level`` keyword parameter....\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.date_range(\u00271/1/2000\u0027, periods=9, freq=\u0027min\u0027)\n\u003e\u003e\u003e series = pd.Series(range(9), index=index)\n\u003e\u003e\u003e series\n2000-01-01 00:00:00    0\n2000-01-01 00:01:00    1\n2000-01-01 00:02:00    2\n2000-01-01 00:03:00    3\n2000-01-01 00:04:00    4\n2000-01-01 00:05:00    5\n2000-01-01 00:06:00    6\n2000-01-01 00:07:00    7\n2000-01-01 00:08:00    8\nFreq: min, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.reset_index", "label": "reset_index", "shape": "dot", "size": 20, "title": "NAME: reset_index\n------------------------------\nINPUTS: self, level, drop, inplace, col_level, col_fill, allow_duplicates, names\nOUTPUTS: DataFrame | None\n------------------------------\nDESCRIPTION: Reset the index, or a level of it. Reset the index of the DataFrame, and use the default one instead. If the DataFrame has a MultiIndex, this method can remove one or more levels. Parameters ---------- level : int, str,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([(\u0027bird\u0027, 389.0),\n...                    (\u0027bird\u0027, 24.0),\n...                    (\u0027mammal\u0027, 80.5),\n...                    (\u0027mammal\u0027, np.nan)],\n...                   index=[\u0027falcon\u0027, \u0027parrot\u0027, \u0027lion\u0027, \u0027monkey\u0027],\n...                   columns=(\u0027class\u0027, \u0027max_speed\u0027))\n\u003e\u003e\u003e df\n         class  max_speed\nfalcon    bird      389.0\nparrot    bird       24.0\nlion    mammal       80.5\nmonkey  mammal        NaN"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.rfloordiv", "label": "rfloordiv", "shape": "dot", "size": 20, "title": "NAME: rfloordiv\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Integer division of dataframe and other, element-wise (binary operator `rfloordiv`). Equivalent to ``other // dataframe``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `floordiv`. Among flexible wrappers (`add`, `sub`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.rmod", "label": "rmod", "shape": "dot", "size": 20, "title": "NAME: rmod\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Modulo of dataframe and other, element-wise (binary operator `rmod`). Equivalent to ``other % dataframe``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `mod`. Among flexible wrappers (`add`, `sub`, `mul`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.rmul", "label": "rmul", "shape": "dot", "size": 20, "title": "NAME: rmul\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Multiplication of dataframe and other, element-wise (binary operator `rmul`). Equivalent to ``other * dataframe``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `mul`. Among flexible wrappers (`add`, `sub`, `mul`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.rolling", "label": "rolling", "shape": "dot", "size": 20, "title": "NAME: rolling\n------------------------------\nINPUTS: self, window, min_periods, center, win_type, on, axis, closed, step, method\nOUTPUTS: Window | Rolling\n------------------------------\nDESCRIPTION: Provide rolling window calculations. Parameters ---------- window : int, timedelta, str, offset, or BaseIndexer subclass Size of the moving window. If an integer, the fixed number of observations used for each window. If a timedelta, str, or offset, the time...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027B\u0027: [0, 1, 2, np.nan, 4]})\n\u003e\u003e\u003e df\n     B\n0  0.0\n1  1.0\n2  2.0\n3  NaN\n4  4.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.round", "label": "round", "shape": "dot", "size": 20, "title": "NAME: round\n------------------------------\nINPUTS: self, decimals, args, kwargs\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Round a DataFrame to a variable number of decimal places. Parameters ---------- decimals : int, dict, Series Number of decimal places to round each column to. If an int is given, round each column to the same number of places....\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([(.21, .32), (.01, .67), (.66, .03), (.21, .18)],\n...                   columns=[\u0027dogs\u0027, \u0027cats\u0027])\n\u003e\u003e\u003e df\n    dogs  cats\n0  0.21  0.32\n1  0.01  0.67\n2  0.66  0.03\n3  0.21  0.18"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.rpow", "label": "rpow", "shape": "dot", "size": 20, "title": "NAME: rpow\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Exponential power of dataframe and other, element-wise (binary operator `rpow`). Equivalent to ``other ** dataframe``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `pow`. Among flexible wrappers (`add`, `sub`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.rsub", "label": "rsub", "shape": "dot", "size": 20, "title": "NAME: rsub\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Subtraction of dataframe and other, element-wise (binary operator `rsub`). Equivalent to ``other - dataframe``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `sub`. Among flexible wrappers (`add`, `sub`, `mul`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.rtruediv", "label": "rtruediv", "shape": "dot", "size": 20, "title": "NAME: rtruediv\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Floating division of dataframe and other, element-wise (binary operator `rtruediv`). Equivalent to ``other / dataframe``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `truediv`. Among flexible wrappers (`add`, `sub`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.sample", "label": "sample", "shape": "dot", "size": 20, "title": "NAME: sample\n------------------------------\nINPUTS: self, n, frac, replace, weights, random_state, axis, ignore_index\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a random sample of items from an axis of object. You can use `random_state` for reproducibility. Parameters ---------- n : int, optional Number of items from axis to return. Cannot be used with `frac`. Default = 1 if `frac`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027num_legs\u0027: [2, 4, 8, 0],\n...                    \u0027num_wings\u0027: [2, 0, 0, 0],\n...                    \u0027num_specimen_seen\u0027: [10, 2, 1, 8]},\n...                   index=[\u0027falcon\u0027, \u0027dog\u0027, \u0027spider\u0027, \u0027fish\u0027])\n\u003e\u003e\u003e df\n        num_legs  num_wings  num_specimen_seen\nfalcon         2          2                 10\ndog            4          0                  2\nspider         8          0                  1\nfish           0          0                  8"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.select_dtypes", "label": "select_dtypes", "shape": "dot", "size": 20, "title": "NAME: select_dtypes\n------------------------------\nINPUTS: self, include, exclude\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a subset of the DataFrame\u0027s columns based on the column dtypes. Parameters ---------- include, exclude : scalar or list-like A selection of dtypes or strings to be included/excluded. At least one of these parameters must be supplied. Returns -------...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027a\u0027: [1, 2] * 3,\n...                    \u0027b\u0027: [True, False] * 3,\n...                    \u0027c\u0027: [1.0, 2.0] * 3})\n\u003e\u003e\u003e df\n        a      b  c\n0       1   True  1.0\n1       2  False  2.0\n2       1   True  1.0\n3       2  False  2.0\n4       1   True  1.0\n5       2  False  2.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.sem", "label": "sem", "shape": "dot", "size": 20, "title": "NAME: sem\n------------------------------\nINPUTS: self, axis, skipna, ddof, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return unbiased standard error of the mean over requested axis. Normalized by N-1 by default. This can be changed using the ddof argument Parameters ---------- axis : {index (0), columns (1)} For `Series` this parameter is unused and defaults to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n            \u003e\u003e\u003e s.sem().round(6)\n            0.57735"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.set_axis", "label": "set_axis", "shape": "dot", "size": 20, "title": "NAME: set_axis\n------------------------------\nINPUTS: self, labels, axis, copy\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Assign desired index to given axis. Indexes for column or row labels can be changed by assigning a list-like or Index. Parameters ---------- labels : list-like, Index The values for the new index. axis : {0 or \u0027index\u0027, 1 or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"A\": [1, 2, 3], \"B\": [4, 5, 6]})"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.set_flags", "label": "set_flags", "shape": "dot", "size": 20, "title": "NAME: set_flags\n------------------------------\nINPUTS: self, copy, allows_duplicate_labels\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a new object with updated flags. Parameters ---------- copy : bool, default False Specify if a copy of the object should be made. .. note:: The `copy` keyword will change behavior in pandas 3.0. `Copy-on-Write \u003chttps://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html\u003e`__ will be enabled...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"A\": [1, 2]})\n\u003e\u003e\u003e df.flags.allows_duplicate_labels\nTrue\n\u003e\u003e\u003e df2 = df.set_flags(allows_duplicate_labels=False)\n\u003e\u003e\u003e df2.flags.allows_duplicate_labels\nFalse"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.set_index", "label": "set_index", "shape": "dot", "size": 20, "title": "NAME: set_index\n------------------------------\nINPUTS: self, keys, drop, append, inplace, verify_integrity\nOUTPUTS: DataFrame | None\n------------------------------\nDESCRIPTION: Set the DataFrame index using existing columns. Set the DataFrame index (row labels) using one or more existing columns or arrays (of the correct length). The index can replace the existing index or expand on it. Parameters ---------- keys :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027month\u0027: [1, 4, 7, 10],\n...                    \u0027year\u0027: [2012, 2014, 2013, 2014],\n...                    \u0027sale\u0027: [55, 40, 84, 31]})\n\u003e\u003e\u003e df\n   month  year  sale\n0      1  2012    55\n1      4  2014    40\n2      7  2013    84\n3     10  2014    31"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.shift", "label": "shift", "shape": "dot", "size": 20, "title": "NAME: shift\n------------------------------\nINPUTS: self, periods, freq, axis, fill_value, suffix\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Shift index by desired number of periods with an optional time `freq`. When `freq` is not passed, shift the index without realigning the data. If `freq` is passed (in this case, the index must be date or datetime, or it...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"Col1\": [10, 20, 15, 30, 45],\n...                    \"Col2\": [13, 23, 18, 33, 48],\n...                    \"Col3\": [17, 27, 22, 37, 52]},\n...                   index=pd.date_range(\"2020-01-01\", \"2020-01-05\"))\n\u003e\u003e\u003e df\n            Col1  Col2  Col3\n2020-01-01    10    13    17\n2020-01-02    20    23    27\n2020-01-03    15    18    22\n2020-01-04    30    33    37\n2020-01-05    45    48    52"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.skew", "label": "skew", "shape": "dot", "size": 20, "title": "NAME: skew\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return unbiased skew over requested axis. Normalized by N-1. Parameters ---------- axis : {index (0), columns (1)} Axis for the function to be applied on. For `Series` this parameter is unused and defaults to 0. For DataFrames, specifying ``axis=None`` will...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n            \u003e\u003e\u003e s.skew()\n            0.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.sort_index", "label": "sort_index", "shape": "dot", "size": 20, "title": "NAME: sort_index\n------------------------------\nINPUTS: self, axis, level, ascending, inplace, kind, na_position, sort_remaining, ignore_index, key\nOUTPUTS: DataFrame | None\n------------------------------\nDESCRIPTION: Sort object by labels (along an axis). Returns a new DataFrame sorted by label if `inplace` argument is ``False``, otherwise updates the original DataFrame and returns None. Parameters ---------- axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 The...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([1, 2, 3, 4, 5], index=[100, 29, 234, 1, 150],\n...                   columns=[\u0027A\u0027])\n\u003e\u003e\u003e df.sort_index()\n     A\n1    4\n29   2\n100  1\n150  5\n234  3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.sort_values", "label": "sort_values", "shape": "dot", "size": 20, "title": "NAME: sort_values\n------------------------------\nINPUTS: self, by, axis, ascending, inplace, kind, na_position, ignore_index, key\nOUTPUTS: DataFrame | None\n------------------------------\nDESCRIPTION: Sort by the values along either axis. Parameters ---------- by : str or list of str Name or list of names to sort by. - if `axis` is 0 or `\u0027index\u0027` then `by` may contain index levels and/or column labels....\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\n...     \u0027col1\u0027: [\u0027A\u0027, \u0027A\u0027, \u0027B\u0027, np.nan, \u0027D\u0027, \u0027C\u0027],\n...     \u0027col2\u0027: [2, 1, 9, 8, 7, 4],\n...     \u0027col3\u0027: [0, 1, 9, 4, 2, 3],\n...     \u0027col4\u0027: [\u0027a\u0027, \u0027B\u0027, \u0027c\u0027, \u0027D\u0027, \u0027e\u0027, \u0027F\u0027]\n... })\n\u003e\u003e\u003e df\n  col1  col2  col3 col4\n0    A     2     0    a\n1    A     1     1    B\n2    B     9     9    c\n3  NaN     8     4    D\n4    D     7     2    e\n5    C     4     3    F"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.DataFrame.sparse", "label": "sparse", "shape": "dot", "size": 20, "title": "NAME: sparse\n------------------------------\nINPUTS: data\nOUTPUTS: None\n------------------------------\nDESCRIPTION: DataFrame accessor for sparse data. Examples -------- \u003e\u003e\u003e df = pd.DataFrame({\"a\": [1, 2, 0, 0], ... \"b\": [3, 0, 0, 4]}, dtype=\"Sparse[int]\") \u003e\u003e\u003e df.sparse.density 0.5...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"a\": [1, 2, 0, 0],\n...                   \"b\": [3, 0, 0, 4]}, dtype=\"Sparse[int]\")\n\u003e\u003e\u003e df.sparse.density\n0.5"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.squeeze", "label": "squeeze", "shape": "dot", "size": 20, "title": "NAME: squeeze\n------------------------------\nINPUTS: self, axis\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Squeeze 1 dimensional axis objects into scalars. Series or DataFrames with a single element are squeezed to a scalar. DataFrames with a single column or a single row are squeezed to a Series. Otherwise the object is unchanged. This method...\n\n\nEXAMPLE:\n\u003e\u003e\u003e primes = pd.Series([2, 3, 5, 7])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.stack", "label": "stack", "shape": "dot", "size": 20, "title": "NAME: stack\n------------------------------\nINPUTS: self, level, dropna, sort, future_stack\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Stack the prescribed level(s) from columns to index. Return a reshaped DataFrame or Series having a multi-level index with one or more new inner-most levels compared to the current DataFrame. The new inner-most levels are created by pivoting the columns...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df_single_level_cols = pd.DataFrame([[0, 1], [2, 3]],\n...                                     index=[\u0027cat\u0027, \u0027dog\u0027],\n...                                     columns=[\u0027weight\u0027, \u0027height\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.std", "label": "std", "shape": "dot", "size": 20, "title": "NAME: std\n------------------------------\nINPUTS: self, axis, skipna, ddof, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return sample standard deviation over requested axis. Normalized by N-1 by default. This can be changed using the ddof argument. Parameters ---------- axis : {index (0), columns (1)} For `Series` this parameter is unused and defaults to 0. .. warning::...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027person_id\u0027: [0, 1, 2, 3],\n...                    \u0027age\u0027: [21, 25, 62, 43],\n...                    \u0027height\u0027: [1.61, 1.87, 1.49, 2.01]}\n...                   ).set_index(\u0027person_id\u0027)\n\u003e\u003e\u003e df\n           age  height\nperson_id\n0           21    1.61\n1           25    1.87\n2           62    1.49\n3           43    2.01"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.sub", "label": "sub", "shape": "dot", "size": 20, "title": "NAME: sub\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Subtraction of dataframe and other, element-wise (binary operator `sub`). Equivalent to ``dataframe - other``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `rsub`. Among flexible wrappers (`add`, `sub`, `mul`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.subtract", "label": "subtract", "shape": "dot", "size": 20, "title": "NAME: subtract\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Subtraction of dataframe and other, element-wise (binary operator `sub`). Equivalent to ``dataframe - other``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `rsub`. Among flexible wrappers (`add`, `sub`, `mul`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.sum", "label": "sum", "shape": "dot", "size": 20, "title": "NAME: sum\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, min_count, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the sum of the values over the requested axis. This is equivalent to the method ``numpy.sum``. Parameters ---------- axis : {index (0), columns (1)} Axis for the function to be applied on. For `Series` this parameter is unused and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.MultiIndex.from_arrays([\n...     [\u0027warm\u0027, \u0027warm\u0027, \u0027cold\u0027, \u0027cold\u0027],\n...     [\u0027dog\u0027, \u0027falcon\u0027, \u0027fish\u0027, \u0027spider\u0027]],\n...     names=[\u0027blooded\u0027, \u0027animal\u0027])\n\u003e\u003e\u003e s = pd.Series([4, 2, 0, 8], name=\u0027legs\u0027, index=idx)\n\u003e\u003e\u003e s\nblooded  animal\nwarm     dog       4\n         falcon    2\ncold     fish      0\n         spider    8\nName: legs, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.swapaxes", "label": "swapaxes", "shape": "dot", "size": 20, "title": "NAME: swapaxes\n------------------------------\nINPUTS: self, axis1, axis2, copy\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Interchange axes and swap values axes appropriately. .. deprecated:: 2.1.0 ``swapaxes`` is deprecated and will be removed. Please use ``transpose`` instead. Returns ------- same as input Examples -------- Please see examples for :meth:`DataFrame.transpose`....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.swaplevel", "label": "swaplevel", "shape": "dot", "size": 20, "title": "NAME: swaplevel\n------------------------------\nINPUTS: self, i, j, axis\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Swap levels i and j in a :class:`MultiIndex`. Default is to swap the two innermost levels of the index. Parameters ---------- i, j : int or str Levels of the indices to be swapped. Can pass level name as string....\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(\n...     {\"Grade\": [\"A\", \"B\", \"A\", \"C\"]},\n...     index=[\n...         [\"Final exam\", \"Final exam\", \"Coursework\", \"Coursework\"],\n...         [\"History\", \"Geography\", \"History\", \"Geography\"],\n...         [\"January\", \"February\", \"March\", \"April\"],\n...     ],\n... )\n\u003e\u003e\u003e df\n                                    Grade\nFinal exam  History     January      A\n            Geography   February     B\nCoursework  History     March        A\n            Geography   April        C"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.tail", "label": "tail", "shape": "dot", "size": 20, "title": "NAME: tail\n------------------------------\nINPUTS: self, n\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return the last `n` rows. This function returns last `n` rows from the object based on position. It is useful for quickly verifying data, for example, after sorting or appending rows. For negative values of `n`, this function returns all...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027animal\u0027: [\u0027alligator\u0027, \u0027bee\u0027, \u0027falcon\u0027, \u0027lion\u0027,\n...                    \u0027monkey\u0027, \u0027parrot\u0027, \u0027shark\u0027, \u0027whale\u0027, \u0027zebra\u0027]})\n\u003e\u003e\u003e df\n      animal\n0  alligator\n1        bee\n2     falcon\n3       lion\n4     monkey\n5     parrot\n6      shark\n7      whale\n8      zebra"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.take", "label": "take", "shape": "dot", "size": 20, "title": "NAME: take\n------------------------------\nINPUTS: self, indices, axis, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return the elements in the given *positional* indices along an axis. This means that we are not indexing according to actual values in the index attribute of the object. We are indexing according to the actual position of the element...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([(\u0027falcon\u0027, \u0027bird\u0027, 389.0),\n...                    (\u0027parrot\u0027, \u0027bird\u0027, 24.0),\n...                    (\u0027lion\u0027, \u0027mammal\u0027, 80.5),\n...                    (\u0027monkey\u0027, \u0027mammal\u0027, np.nan)],\n...                   columns=[\u0027name\u0027, \u0027class\u0027, \u0027max_speed\u0027],\n...                   index=[0, 2, 3, 1])\n\u003e\u003e\u003e df\n     name   class  max_speed\n0  falcon    bird      389.0\n2  parrot    bird       24.0\n3    lion  mammal       80.5\n1  monkey  mammal        NaN"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_clipboard", "label": "to_clipboard", "shape": "dot", "size": 20, "title": "NAME: to_clipboard\n------------------------------\nINPUTS: self, excel, sep, kwargs\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Copy object to the system clipboard. Write a text representation of object to the system clipboard. This can be pasted into Excel, for example. Parameters ---------- excel : bool, default True Produce output in a csv format for easy pasting...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], columns=[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_csv", "label": "to_csv", "shape": "dot", "size": 20, "title": "NAME: to_csv\n------------------------------\nINPUTS: self, path_or_buf, sep, na_rep, float_format, columns, header, index, index_label, mode, encoding, compression, quoting, quotechar, lineterminator, chunksize, date_format, doublequote, escapechar, decimal, errors, storage_options\nOUTPUTS: str | None\n------------------------------\nDESCRIPTION: Write object to a comma-separated values (csv) file. Parameters ---------- path_or_buf : str, path object, file-like object, or None, default None String, path object (implementing os.PathLike[str]), or file-like object implementing a write() function. If None, the result is returned as...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027name\u0027: [\u0027Raphael\u0027, \u0027Donatello\u0027],\n...                    \u0027mask\u0027: [\u0027red\u0027, \u0027purple\u0027],\n...                    \u0027weapon\u0027: [\u0027sai\u0027, \u0027bo staff\u0027]})\n\u003e\u003e\u003e df.to_csv(\u0027out.csv\u0027, index=False)  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_dict", "label": "to_dict", "shape": "dot", "size": 20, "title": "NAME: to_dict\n------------------------------\nINPUTS: self, orient, into, index\nOUTPUTS: MutableMappingT | list[MutableMappingT]\n------------------------------\nDESCRIPTION: Convert the DataFrame to a dictionary. The type of the key-value pairs can be customized with the parameters (see below). Parameters ---------- orient : str {\u0027dict\u0027, \u0027list\u0027, \u0027series\u0027, \u0027split\u0027, \u0027tight\u0027, \u0027records\u0027, \u0027index\u0027} Determines the type of the values of the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027col1\u0027: [1, 2],\n...                    \u0027col2\u0027: [0.5, 0.75]},\n...                   index=[\u0027row1\u0027, \u0027row2\u0027])\n\u003e\u003e\u003e df\n      col1  col2\nrow1     1  0.50\nrow2     2  0.75\n\u003e\u003e\u003e df.to_dict()\n{\u0027col1\u0027: {\u0027row1\u0027: 1, \u0027row2\u0027: 2}, \u0027col2\u0027: {\u0027row1\u0027: 0.5, \u0027row2\u0027: 0.75}}"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_excel", "label": "to_excel", "shape": "dot", "size": 20, "title": "NAME: to_excel\n------------------------------\nINPUTS: self, excel_writer, sheet_name, na_rep, float_format, columns, header, index, index_label, startrow, startcol, engine, merge_cells, inf_rep, freeze_panes, storage_options, engine_kwargs\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Write object to an Excel sheet. To write a single object to an Excel .xlsx file it is only necessary to specify a target file name. To write to multiple sheets it is necessary to create an `ExcelWriter` object with...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df1 = pd.DataFrame([[\u0027a\u0027, \u0027b\u0027], [\u0027c\u0027, \u0027d\u0027]],\n...                    index=[\u0027row 1\u0027, \u0027row 2\u0027],\n...                    columns=[\u0027col 1\u0027, \u0027col 2\u0027])\n\u003e\u003e\u003e df1.to_excel(\"output.xlsx\")  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_feather", "label": "to_feather", "shape": "dot", "size": 20, "title": "NAME: to_feather\n------------------------------\nINPUTS: self, path, kwargs\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Write a DataFrame to the binary Feather format. Parameters ---------- path : str, path object, file-like object String, path object (implementing ``os.PathLike[str]``), or file-like object implementing a binary ``write()`` function. If a string or a path, it will be used...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[1, 2, 3], [4, 5, 6]])\n\u003e\u003e\u003e df.to_feather(\"file.feather\")  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_gbq", "label": "to_gbq", "shape": "dot", "size": 20, "title": "NAME: to_gbq\n------------------------------\nINPUTS: self, destination_table, project_id, chunksize, reauth, if_exists, auth_local_webserver, table_schema, location, progress_bar, credentials\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Write a DataFrame to a Google BigQuery table. .. deprecated:: 2.2.0 Please use ``pandas_gbq.to_gbq`` instead. This function requires the `pandas-gbq package \u003chttps://pandas-gbq.readthedocs.io\u003e`__. See the `How to authenticate with Google BigQuery \u003chttps://pandas-gbq.readthedocs.io/en/latest/howto/authentication.html\u003e`__ guide for authentication instructions. Parameters ---------- destination_table : str...\n\n\nEXAMPLE:\n\u003e\u003e\u003e project_id = \"my-project\"\n\u003e\u003e\u003e table_id = \u0027my_dataset.my_table\u0027\n\u003e\u003e\u003e df = pd.DataFrame({\n...                   \"my_string\": [\"a\", \"b\", \"c\"],\n...                   \"my_int64\": [1, 2, 3],\n...                   \"my_float64\": [4.0, 5.0, 6.0],\n...                   \"my_bool1\": [True, False, True],\n...                   \"my_bool2\": [False, True, False],\n...                   \"my_dates\": pd.date_range(\"now\", periods=3),\n...                   }\n...                   )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_hdf", "label": "to_hdf", "shape": "dot", "size": 20, "title": "NAME: to_hdf\n------------------------------\nINPUTS: self, path_or_buf, key, mode, complevel, complib, append, format, index, min_itemsize, nan_rep, dropna, data_columns, errors, encoding\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Write the contained data to an HDF5 file using HDFStore. Hierarchical Data Format (HDF) is self-describing, allowing an application to interpret the structure and contents of a file with no outside information. One HDF file can hold a mix of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [1, 2, 3], \u0027B\u0027: [4, 5, 6]},\n...                   index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])  # doctest: +SKIP\n\u003e\u003e\u003e df.to_hdf(\u0027data.h5\u0027, key=\u0027df\u0027, mode=\u0027w\u0027)  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_html", "label": "to_html", "shape": "dot", "size": 20, "title": "NAME: to_html\n------------------------------\nINPUTS: self, buf, columns, col_space, header, index, na_rep, formatters, float_format, sparsify, index_names, justify, max_rows, max_cols, show_dimensions, decimal, bold_rows, classes, escape, notebook, border, table_id, render_links, encoding\nOUTPUTS: str | None\n------------------------------\nDESCRIPTION: Render a DataFrame as an HTML table. Parameters ---------- buf : str, Path or StringIO-like, optional, default None Buffer to write to. If None, the output is returned as a string. columns : array-like, optional, default None The subset of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(data={\u0027col1\u0027: [1, 2], \u0027col2\u0027: [4, 3]})\n\u003e\u003e\u003e html_string = \u0027\u0027\u0027\u003ctable border=\"1\" class=\"dataframe\"\u003e\n...   \u003cthead\u003e\n...     \u003ctr style=\"text-align: right;\"\u003e\n...       \u003cth\u003e\u003c/th\u003e\n...       \u003cth\u003ecol1\u003c/th\u003e\n...       \u003cth\u003ecol2\u003c/th\u003e\n...     \u003c/tr\u003e\n...   \u003c/thead\u003e\n...   \u003ctbody\u003e\n...     \u003ctr\u003e\n...       \u003cth\u003e0\u003c/th\u003e\n...       \u003ctd\u003e1\u003c/td\u003e\n...       \u003ctd\u003e4\u003c/td\u003e\n...     \u003c/tr\u003e\n...     \u003ctr\u003e\n...       \u003cth\u003e1\u003c/th\u003e\n...       \u003ctd\u003e2\u003c/td\u003e\n...       \u003ctd\u003e3\u003c/td\u003e\n...     \u003c/tr\u003e\n...   \u003c/tbody\u003e\n... \u003c/table\u003e\u0027\u0027\u0027\n\u003e\u003e\u003e assert html_string == df.to_html()"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_json", "label": "to_json", "shape": "dot", "size": 20, "title": "NAME: to_json\n------------------------------\nINPUTS: self, path_or_buf, orient, date_format, double_precision, force_ascii, date_unit, default_handler, lines, compression, index, indent, storage_options, mode\nOUTPUTS: str | None\n------------------------------\nDESCRIPTION: Convert the object to a JSON string. Note NaN\u0027s and None will be converted to null and datetime objects will be converted to UNIX timestamps. Parameters ---------- path_or_buf : str, path object, file-like object, or None, default None String, path...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from json import loads, dumps\n\u003e\u003e\u003e df = pd.DataFrame(\n...     [[\"a\", \"b\"], [\"c\", \"d\"]],\n...     index=[\"row 1\", \"row 2\"],\n...     columns=[\"col 1\", \"col 2\"],\n... )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_latex", "label": "to_latex", "shape": "dot", "size": 20, "title": "NAME: to_latex\n------------------------------\nINPUTS: self, buf, columns, header, index, na_rep, formatters, float_format, sparsify, index_names, bold_rows, column_format, longtable, escape, encoding, decimal, multicolumn, multicolumn_format, multirow, caption, label, position\nOUTPUTS: str | None\n------------------------------\nDESCRIPTION: Render object to a LaTeX tabular, longtable, or nested table. Requires ``\\usepackage{{booktabs}}``. The output can be copy/pasted into a main LaTeX document or read from an external file with ``\\input{{table.tex}}``. .. versionchanged:: 2.0.0 Refactored to use the Styler implementation via...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(dict(name=[\u0027Raphael\u0027, \u0027Donatello\u0027],\n...                        age=[26, 45],\n...                        height=[181.23, 177.65]))\n\u003e\u003e\u003e print(df.to_latex(index=False,\n...                   formatters={\"name\": str.upper},\n...                   float_format=\"{:.1f}\".format,\n... ))  # doctest: +SKIP\n\\begin{tabular}{lrr}\n\\toprule\nname \u0026 age \u0026 height \\\\\n\\midrule\nRAPHAEL \u0026 26 \u0026 181.2 \\\\\nDONATELLO \u0026 45 \u0026 177.7 \\\\\n\\bottomrule\n\\end{tabular}"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_markdown", "label": "to_markdown", "shape": "dot", "size": 20, "title": "NAME: to_markdown\n------------------------------\nINPUTS: self, buf, mode, index, storage_options, kwargs\nOUTPUTS: str | None\n------------------------------\nDESCRIPTION: Print DataFrame in Markdown-friendly format. Parameters ---------- buf : str, Path or StringIO-like, optional, default None Buffer to write to. If None, the output is returned as a string. mode : str, optional Mode in which file is opened, \"wt\"...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(\n        ...     data={\"animal_1\": [\"elk\", \"pig\"], \"animal_2\": [\"dog\", \"quetzal\"]}\n        ... )\n        \u003e\u003e\u003e print(df.to_markdown())\n        |    | animal_1   | animal_2   |\n        |---:|:-----------|:-----------|\n        |  0 | elk        | dog        |\n        |  1 | pig        | quetzal    |"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_numpy", "label": "to_numpy", "shape": "dot", "size": 20, "title": "NAME: to_numpy\n------------------------------\nINPUTS: self, dtype, copy, na_value\nOUTPUTS: np.ndarray\n------------------------------\nDESCRIPTION: Convert the DataFrame to a NumPy array. By default, the dtype of the returned array will be the common NumPy dtype of all types in the DataFrame. For example, if the dtypes are ``float16`` and ``float32``, the results dtype will...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.DataFrame({\"A\": [1, 2], \"B\": [3, 4]}).to_numpy()\narray([[1, 3],\n       [2, 4]])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_orc", "label": "to_orc", "shape": "dot", "size": 20, "title": "NAME: to_orc\n------------------------------\nINPUTS: self, path, engine, index, engine_kwargs\nOUTPUTS: bytes | None\n------------------------------\nDESCRIPTION: Write a DataFrame to the ORC format. .. versionadded:: 1.5.0 Parameters ---------- path : str, file-like object or None, default None If a string, it will be used as Root Directory path when writing a partitioned dataset. By file-like object,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(data={\u0027col1\u0027: [1, 2], \u0027col2\u0027: [4, 3]})\n\u003e\u003e\u003e df.to_orc(\u0027df.orc\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e pd.read_orc(\u0027df.orc\u0027)  # doctest: +SKIP\n   col1  col2\n0     1     4\n1     2     3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_parquet", "label": "to_parquet", "shape": "dot", "size": 20, "title": "NAME: to_parquet\n------------------------------\nINPUTS: self, path, engine, compression, index, partition_cols, storage_options, kwargs\nOUTPUTS: bytes | None\n------------------------------\nDESCRIPTION: Write a DataFrame to the binary parquet format. This function writes the dataframe as a `parquet file \u003chttps://parquet.apache.org/\u003e`_. You can choose different parquet backends, and have the option of compression. See :ref:`the user guide \u003cio.parquet\u003e` for more details. Parameters ----------...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(data={\u0027col1\u0027: [1, 2], \u0027col2\u0027: [3, 4]})\n\u003e\u003e\u003e df.to_parquet(\u0027df.parquet.gzip\u0027,\n...               compression=\u0027gzip\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e pd.read_parquet(\u0027df.parquet.gzip\u0027)  # doctest: +SKIP\n   col1  col2\n0     1     3\n1     2     4"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_period", "label": "to_period", "shape": "dot", "size": 20, "title": "NAME: to_period\n------------------------------\nINPUTS: self, freq, axis, copy\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Convert DataFrame from DatetimeIndex to PeriodIndex. Convert DataFrame from DatetimeIndex to PeriodIndex with desired frequency (inferred from index if not passed). Parameters ---------- freq : str, default Frequency of the PeriodIndex. axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.to_datetime(\n...     [\n...         \"2001-03-31 00:00:00\",\n...         \"2002-05-31 00:00:00\",\n...         \"2003-08-31 00:00:00\",\n...     ]\n... )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_pickle", "label": "to_pickle", "shape": "dot", "size": 20, "title": "NAME: to_pickle\n------------------------------\nINPUTS: self, path, compression, protocol, storage_options\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Pickle (serialize) object to file. Parameters ---------- path : str, path object, or file-like object String, path object (implementing ``os.PathLike[str]``), or file-like object implementing a binary ``write()`` function. File path where the pickled object will be stored. compression : str...\n\n\nEXAMPLE:\n\u003e\u003e\u003e original_df = pd.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})  # doctest: +SKIP\n\u003e\u003e\u003e original_df  # doctest: +SKIP\n   foo  bar\n0    0    5\n1    1    6\n2    2    7\n3    3    8\n4    4    9\n\u003e\u003e\u003e original_df.to_pickle(\"./dummy.pkl\")  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_records", "label": "to_records", "shape": "dot", "size": 20, "title": "NAME: to_records\n------------------------------\nINPUTS: self, index, column_dtypes, index_dtypes\nOUTPUTS: np.rec.recarray\n------------------------------\nDESCRIPTION: Convert DataFrame to a NumPy record array. Index will be included as the first field of the record array if requested. Parameters ---------- index : bool, default True Include index in resulting record array, stored in \u0027index\u0027 field or using...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [1, 2], \u0027B\u0027: [0.5, 0.75]},\n...                   index=[\u0027a\u0027, \u0027b\u0027])\n\u003e\u003e\u003e df\n   A     B\na  1  0.50\nb  2  0.75\n\u003e\u003e\u003e df.to_records()\nrec.array([(\u0027a\u0027, 1, 0.5 ), (\u0027b\u0027, 2, 0.75)],\n          dtype=[(\u0027index\u0027, \u0027O\u0027), (\u0027A\u0027, \u0027\u003ci8\u0027), (\u0027B\u0027, \u0027\u003cf8\u0027)])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_sql", "label": "to_sql", "shape": "dot", "size": 20, "title": "NAME: to_sql\n------------------------------\nINPUTS: self, name, con, schema, if_exists, index, index_label, chunksize, dtype, method\nOUTPUTS: int | None\n------------------------------\nDESCRIPTION: Write records stored in a DataFrame to a SQL database. Databases supported by SQLAlchemy [1]_ are supported. Tables can be newly created, appended to, or overwritten. Parameters ---------- name : str Name of SQL table. con : sqlalchemy.engine.(Engine or Connection)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from sqlalchemy import create_engine\n\u003e\u003e\u003e engine = create_engine(\u0027sqlite://\u0027, echo=False)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_stata", "label": "to_stata", "shape": "dot", "size": 20, "title": "NAME: to_stata\n------------------------------\nINPUTS: self, path, convert_dates, write_index, byteorder, time_stamp, data_label, variable_labels, version, convert_strl, compression, storage_options, value_labels\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Export DataFrame object to Stata dta format. Writes the DataFrame to a Stata dataset file. \"dta\" files contain a Stata dataset. Parameters ---------- path : str, path object, or buffer String, path object (implementing ``os.PathLike[str]``), or file-like object implementing a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027animal\u0027: [\u0027falcon\u0027, \u0027parrot\u0027, \u0027falcon\u0027,\n...                               \u0027parrot\u0027],\n...                    \u0027speed\u0027: [350, 18, 361, 15]})\n\u003e\u003e\u003e df.to_stata(\u0027animals.dta\u0027)  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_string", "label": "to_string", "shape": "dot", "size": 20, "title": "NAME: to_string\n------------------------------\nINPUTS: self, buf, columns, col_space, header, index, na_rep, formatters, float_format, sparsify, index_names, justify, max_rows, max_cols, show_dimensions, decimal, line_width, min_rows, max_colwidth, encoding\nOUTPUTS: str | None\n------------------------------\nDESCRIPTION: Render a DataFrame to a console-friendly tabular output. Parameters ---------- buf : str, Path or StringIO-like, optional, default None Buffer to write to. If None, the output is returned as a string. columns : array-like, optional, default None The subset...\n\n\nEXAMPLE:\n\u003e\u003e\u003e d = {\u0027col1\u0027: [1, 2, 3], \u0027col2\u0027: [4, 5, 6]}\n\u003e\u003e\u003e df = pd.DataFrame(d)\n\u003e\u003e\u003e print(df.to_string())\n   col1  col2\n0     1     4\n1     2     5\n2     3     6"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_timestamp", "label": "to_timestamp", "shape": "dot", "size": 20, "title": "NAME: to_timestamp\n------------------------------\nINPUTS: self, freq, how, axis, copy\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Cast to DatetimeIndex of timestamps, at *beginning* of period. Parameters ---------- freq : str, default frequency of PeriodIndex Desired frequency. how : {\u0027s\u0027, \u0027e\u0027, \u0027start\u0027, \u0027end\u0027} Convention for converting period to timestamp; start of period vs. end. axis : {0...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.PeriodIndex([\u00272023\u0027, \u00272024\u0027], freq=\u0027Y\u0027)\n\u003e\u003e\u003e d = {\u0027col1\u0027: [1, 2], \u0027col2\u0027: [3, 4]}\n\u003e\u003e\u003e df1 = pd.DataFrame(data=d, index=idx)\n\u003e\u003e\u003e df1\n      col1   col2\n2023     1      3\n2024     2      4"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_xarray", "label": "to_xarray", "shape": "dot", "size": 20, "title": "NAME: to_xarray\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return an xarray object from the pandas object. Returns ------- xarray.DataArray or xarray.Dataset Data in the pandas structure converted to Dataset if the object is a DataFrame, or a DataArray if the object is a Series. See Also -------- DataFrame.to_hdf...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([(\u0027falcon\u0027, \u0027bird\u0027, 389.0, 2),\n...                    (\u0027parrot\u0027, \u0027bird\u0027, 24.0, 2),\n...                    (\u0027lion\u0027, \u0027mammal\u0027, 80.5, 4),\n...                    (\u0027monkey\u0027, \u0027mammal\u0027, np.nan, 4)],\n...                   columns=[\u0027name\u0027, \u0027class\u0027, \u0027max_speed\u0027,\n...                            \u0027num_legs\u0027])\n\u003e\u003e\u003e df\n     name   class  max_speed  num_legs\n0  falcon    bird      389.0         2\n1  parrot    bird       24.0         2\n2    lion  mammal       80.5         4\n3  monkey  mammal        NaN         4"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.to_xml", "label": "to_xml", "shape": "dot", "size": 20, "title": "NAME: to_xml\n------------------------------\nINPUTS: self, path_or_buffer, index, root_name, row_name, na_rep, attr_cols, elem_cols, namespaces, prefix, encoding, xml_declaration, pretty_print, parser, stylesheet, compression, storage_options\nOUTPUTS: str | None\n------------------------------\nDESCRIPTION: Render a DataFrame to an XML document. .. versionadded:: 1.3.0 Parameters ---------- path_or_buffer : str, path object, file-like object, or None, default None String, path object (implementing ``os.PathLike[str]``), or file-like object implementing a ``write()`` function. If None, the result is...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027shape\u0027: [\u0027square\u0027, \u0027circle\u0027, \u0027triangle\u0027],\n...                    \u0027degrees\u0027: [360, 360, 180],\n...                    \u0027sides\u0027: [4, np.nan, 3]})"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.transform", "label": "transform", "shape": "dot", "size": 20, "title": "NAME: transform\n------------------------------\nINPUTS: self, func, axis, args, kwargs\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Call ``func`` on self producing a DataFrame with the same axis shape as self. Parameters ---------- func : function, str, list-like or dict-like Function to use for transforming the data. If a function, must either work when passed a DataFrame...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: range(3), \u0027B\u0027: range(1, 4)})\n\u003e\u003e\u003e df\n   A  B\n0  0  1\n1  1  2\n2  2  3\n\u003e\u003e\u003e df.transform(lambda x: x + 1)\n   A  B\n0  1  2\n1  2  3\n2  3  4"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.transpose", "label": "transpose", "shape": "dot", "size": 20, "title": "NAME: transpose\n------------------------------\nINPUTS: self, args, copy\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Transpose index and columns. Reflect the DataFrame over its main diagonal by writing rows as columns and vice-versa. The property :attr:`.T` is an accessor to the method :meth:`transpose`. Parameters ---------- *args : tuple, optional Accepted for compatibility with NumPy. copy...\n\n\nEXAMPLE:\n\u003e\u003e\u003e d1 = {\u0027col1\u0027: [1, 2], \u0027col2\u0027: [3, 4]}\n\u003e\u003e\u003e df1 = pd.DataFrame(data=d1)\n\u003e\u003e\u003e df1\n   col1  col2\n0     1     3\n1     2     4"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.truediv", "label": "truediv", "shape": "dot", "size": 20, "title": "NAME: truediv\n------------------------------\nINPUTS: self, other, axis, level, fill_value\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Get Floating division of dataframe and other, element-wise (binary operator `truediv`). Equivalent to ``dataframe / other``, but with support to substitute a fill_value for missing data in one of the inputs. With reverse version, `rtruediv`. Among flexible wrappers (`add`, `sub`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027angles\u0027: [0, 3, 4],\n...                    \u0027degrees\u0027: [360, 180, 360]},\n...                   index=[\u0027circle\u0027, \u0027triangle\u0027, \u0027rectangle\u0027])\n\u003e\u003e\u003e df\n           angles  degrees\ncircle          0      360\ntriangle        3      180\nrectangle       4      360"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.truncate", "label": "truncate", "shape": "dot", "size": 20, "title": "NAME: truncate\n------------------------------\nINPUTS: self, before, after, axis, copy\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Truncate a Series or DataFrame before and after some index value. This is a useful shorthand for boolean indexing based on index values above or below certain thresholds. Parameters ---------- before : date, str, int Truncate all rows before this...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027],\n...                    \u0027B\u0027: [\u0027f\u0027, \u0027g\u0027, \u0027h\u0027, \u0027i\u0027, \u0027j\u0027],\n...                    \u0027C\u0027: [\u0027k\u0027, \u0027l\u0027, \u0027m\u0027, \u0027n\u0027, \u0027o\u0027]},\n...                   index=[1, 2, 3, 4, 5])\n\u003e\u003e\u003e df\n   A  B  C\n1  a  f  k\n2  b  g  l\n3  c  h  m\n4  d  i  n\n5  e  j  o"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.tz_convert", "label": "tz_convert", "shape": "dot", "size": 20, "title": "NAME: tz_convert\n------------------------------\nINPUTS: self, tz, axis, level, copy\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Convert tz-aware axis to target time zone. Parameters ---------- tz : str or tzinfo object or None Target time zone. Passing ``None`` will convert to UTC and remove the timezone information. axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(\n...     [1],\n...     index=pd.DatetimeIndex([\u00272018-09-15 01:30:00+02:00\u0027]),\n... )\n\u003e\u003e\u003e s.tz_convert(\u0027Asia/Shanghai\u0027)\n2018-09-15 07:30:00+08:00    1\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.tz_localize", "label": "tz_localize", "shape": "dot", "size": 20, "title": "NAME: tz_localize\n------------------------------\nINPUTS: self, tz, axis, level, copy, ambiguous, nonexistent\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Localize tz-naive index of a Series or DataFrame to target time zone. This operation localizes the Index. To localize the values in a timezone-naive Series, use :meth:`Series.dt.tz_localize`. Parameters ---------- tz : str or tzinfo or None Time zone to localize....\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(\n...     [1],\n...     index=pd.DatetimeIndex([\u00272018-09-15 01:30:00\u0027]),\n... )\n\u003e\u003e\u003e s.tz_localize(\u0027CET\u0027)\n2018-09-15 01:30:00+02:00    1\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.unstack", "label": "unstack", "shape": "dot", "size": 20, "title": "NAME: unstack\n------------------------------\nINPUTS: self, level, fill_value, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Pivot a level of the (necessarily hierarchical) index labels. Returns a DataFrame having a new level of column labels whose inner-most level consists of the pivoted index labels. If the index is not a MultiIndex, the output will be a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.MultiIndex.from_tuples([(\u0027one\u0027, \u0027a\u0027), (\u0027one\u0027, \u0027b\u0027),\n...                                    (\u0027two\u0027, \u0027a\u0027), (\u0027two\u0027, \u0027b\u0027)])\n\u003e\u003e\u003e s = pd.Series(np.arange(1.0, 5.0), index=index)\n\u003e\u003e\u003e s\none  a   1.0\n     b   2.0\ntwo  a   3.0\n     b   4.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.update", "label": "update", "shape": "dot", "size": 20, "title": "NAME: update\n------------------------------\nINPUTS: self, other, join, overwrite, filter_func, errors\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Modify in place using non-NA values from another DataFrame. Aligns on indices. There is no return value. Parameters ---------- other : DataFrame, or object coercible into a DataFrame Should have at least one matching index/column label with the original DataFrame....\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [1, 2, 3],\n...                    \u0027B\u0027: [400, 500, 600]})\n\u003e\u003e\u003e new_df = pd.DataFrame({\u0027B\u0027: [4, 5, 6],\n...                        \u0027C\u0027: [7, 8, 9]})\n\u003e\u003e\u003e df.update(new_df)\n\u003e\u003e\u003e df\n   A  B\n0  1  4\n1  2  5\n2  3  6"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.value_counts", "label": "value_counts", "shape": "dot", "size": 20, "title": "NAME: value_counts\n------------------------------\nINPUTS: self, subset, normalize, sort, ascending, dropna\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return a Series containing the frequency of each distinct row in the Dataframe. Parameters ---------- subset : label or list of labels, optional Columns to use when counting unique combinations. normalize : bool, default False Return proportions rather than frequencies....\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027num_legs\u0027: [2, 4, 4, 6],\n...                    \u0027num_wings\u0027: [2, 0, 0, 0]},\n...                   index=[\u0027falcon\u0027, \u0027dog\u0027, \u0027cat\u0027, \u0027ant\u0027])\n\u003e\u003e\u003e df\n        num_legs  num_wings\nfalcon         2          2\ndog            4          0\ncat            4          0\nant            6          0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.var", "label": "var", "shape": "dot", "size": 20, "title": "NAME: var\n------------------------------\nINPUTS: self, axis, skipna, ddof, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return unbiased variance over requested axis. Normalized by N-1 by default. This can be changed using the ddof argument. Parameters ---------- axis : {index (0), columns (1)} For `Series` this parameter is unused and defaults to 0. .. warning:: The...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027person_id\u0027: [0, 1, 2, 3],\n...                    \u0027age\u0027: [21, 25, 62, 43],\n...                    \u0027height\u0027: [1.61, 1.87, 1.49, 2.01]}\n...                   ).set_index(\u0027person_id\u0027)\n\u003e\u003e\u003e df\n           age  height\nperson_id\n0           21    1.61\n1           25    1.87\n2           62    1.49\n3           43    2.01"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.where", "label": "where", "shape": "dot", "size": 20, "title": "NAME: where\n------------------------------\nINPUTS: self, cond, other, inplace, axis, level\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Replace values where the condition is False. Parameters ---------- cond : bool Series/DataFrame, array-like, or callable Where `cond` is True, keep the original value. Where False, replace with corresponding value from `other`. If `cond` is callable, it is computed on...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(range(5))\n\u003e\u003e\u003e s.where(s \u003e 0)\n0    NaN\n1    1.0\n2    2.0\n3    3.0\n4    4.0\ndtype: float64\n\u003e\u003e\u003e s.mask(s \u003e 0)\n0    0.0\n1    NaN\n2    NaN\n3    NaN\n4    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DataFrame.xs", "label": "xs", "shape": "dot", "size": 20, "title": "NAME: xs\n------------------------------\nINPUTS: self, key, axis, level, drop_level\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return cross-section from the Series/DataFrame. This method takes a `key` argument to select data at a particular level of a MultiIndex. Parameters ---------- key : label or tuple of label Label contained in the index, or partially in a MultiIndex....\n\n\nEXAMPLE:\n\u003e\u003e\u003e d = {\u0027num_legs\u0027: [4, 4, 2, 2],\n...      \u0027num_wings\u0027: [0, 0, 2, 2],\n...      \u0027class\u0027: [\u0027mammal\u0027, \u0027mammal\u0027, \u0027mammal\u0027, \u0027bird\u0027],\n...      \u0027animal\u0027: [\u0027cat\u0027, \u0027dog\u0027, \u0027bat\u0027, \u0027penguin\u0027],\n...      \u0027locomotion\u0027: [\u0027walks\u0027, \u0027walks\u0027, \u0027flies\u0027, \u0027walks\u0027]}\n\u003e\u003e\u003e df = pd.DataFrame(data=d)\n\u003e\u003e\u003e df = df.set_index([\u0027class\u0027, \u0027animal\u0027, \u0027locomotion\u0027])\n\u003e\u003e\u003e df\n                           num_legs  num_wings\nclass  animal  locomotion\nmammal cat     walks              4          0\n       dog     walks              4          0\n       bat     flies              2          2\nbird   penguin walks              2          2"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.all", "label": "all", "shape": "dot", "size": 20, "title": "NAME: all\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return whether all elements are Truthy. Parameters ---------- *args Required for compatibility with numpy. **kwargs Required for compatibility with numpy. Returns ------- bool or array-like (if axis is specified) A single element array-like may be converted to bool. See Also...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Index([1, 2, 3]).all()\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.any", "label": "any", "shape": "dot", "size": 20, "title": "NAME: any\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return whether any element is Truthy. Parameters ---------- *args Required for compatibility with numpy. **kwargs Required for compatibility with numpy. Returns ------- bool or array-like (if axis is specified) A single element array-like may be converted to bool. See Also...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([0, 1, 2])\n\u003e\u003e\u003e index.any()\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.append", "label": "append", "shape": "dot", "size": 20, "title": "NAME: append\n------------------------------\nINPUTS: self, other\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Append a collection of Index options together. Parameters ---------- other : Index or list/tuple of indices Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([1, 2, 3]) \u003e\u003e\u003e idx.append(pd.Index([4])) Index([1, 2, 3, 4], dtype=\u0027int64\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.append(pd.Index([4]))\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.argmax", "label": "argmax", "shape": "dot", "size": 20, "title": "NAME: argmax\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the largest value in the Series. If the maximum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.argmin", "label": "argmin", "shape": "dot", "size": 20, "title": "NAME: argmin\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the smallest value in the Series. If the minimum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.argsort", "label": "argsort", "shape": "dot", "size": 20, "title": "NAME: argsort\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Return the integer indices that would sort the index. Parameters ---------- *args Passed to `numpy.ndarray.argsort`. **kwargs Passed to `numpy.ndarray.argsort`. Returns ------- np.ndarray[np.intp] Integer indices that would sort the index if used as an indexer. See Also -------- numpy.argsort : Similar...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027b\u0027, \u0027a\u0027, \u0027d\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027b\u0027, \u0027a\u0027, \u0027d\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.as_unit", "label": "as_unit", "shape": "dot", "size": 20, "title": "NAME: as_unit\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.asof", "label": "asof", "shape": "dot", "size": 20, "title": "NAME: asof\n------------------------------\nINPUTS: self, label\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the label from the index, or, if not present, the previous one. Assuming that the index is sorted, return the passed index label if it is in the index, or return the previous index label if the passed one...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u00272013-12-31\u0027, \u00272014-01-02\u0027, \u00272014-01-03\u0027])\n\u003e\u003e\u003e idx.asof(\u00272014-01-01\u0027)\n\u00272013-12-31\u0027"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.asof_locs", "label": "asof_locs", "shape": "dot", "size": 20, "title": "NAME: asof_locs\n------------------------------\nINPUTS: self, where, mask\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Return the locations (indices) of labels in the index. As in the :meth:`pandas.Index.asof`, if the label (a particular entry in ``where``) is not in the index, the latest index label up to the passed label is chosen and its index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.date_range(\u00272023-06-01\u0027, periods=3, freq=\u0027D\u0027)\n\u003e\u003e\u003e where = pd.DatetimeIndex([\u00272023-05-30 00:12:00\u0027, \u00272023-06-01 00:00:00\u0027,\n...                           \u00272023-06-02 23:59:59\u0027])\n\u003e\u003e\u003e mask = np.ones(3, dtype=bool)\n\u003e\u003e\u003e idx.asof_locs(where, mask)\narray([-1,  0,  1])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.astype", "label": "astype", "shape": "dot", "size": 20, "title": "NAME: astype\n------------------------------\nINPUTS: self, dtype, copy\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Create an Index with values cast to dtypes. The class of a new Index is determined by dtype. When conversion is impossible, a TypeError exception is raised. Parameters ---------- dtype : numpy dtype or pandas type Note that any signed...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx.astype(\u0027float\u0027)\nIndex([1.0, 2.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.ceil", "label": "ceil", "shape": "dot", "size": 20, "title": "NAME: ceil\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Perform ceil operation on the data to the specified `freq`. Parameters ---------- freq : str or Offset The frequency level to ceil the index to. Must be a fixed frequency like \u0027S\u0027 (second) not \u0027ME\u0027 (month end). See :ref:`frequency aliases...\n\n\nEXAMPLE:\n\u003e\u003e\u003e rng = pd.date_range(\u00271/1/2018 11:59:00\u0027, periods=3, freq=\u0027min\u0027)\n\u003e\u003e\u003e rng\nDatetimeIndex([\u00272018-01-01 11:59:00\u0027, \u00272018-01-01 12:00:00\u0027,\n               \u00272018-01-01 12:01:00\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=\u0027min\u0027)\n\u003e\u003e\u003e rng.ceil(\u0027h\u0027)\nDatetimeIndex([\u00272018-01-01 12:00:00\u0027, \u00272018-01-01 12:00:00\u0027,\n               \u00272018-01-01 13:00:00\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=None)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.copy", "label": "copy", "shape": "dot", "size": 20, "title": "NAME: copy\n------------------------------\nINPUTS: self, name, deep\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make a copy of this object. Name is set on the new object. Parameters ---------- name : Label, optional Set name for new object. deep : bool, default False Returns ------- Index Index refer to new object which is a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e new_idx = idx.copy()\n\u003e\u003e\u003e idx is new_idx\nFalse"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.day_name", "label": "day_name", "shape": "dot", "size": 20, "title": "NAME: day_name\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the day names with specified locale. Parameters ---------- locale : str, optional Locale determining the language in which to return the day name. Default is English locale (``\u0027en_US.utf8\u0027``). Use the command ``locale -a`` on your terminal on Unix systems...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(pd.date_range(start=\u00272018-01-01\u0027, freq=\u0027D\u0027, periods=3))\n\u003e\u003e\u003e s\n0   2018-01-01\n1   2018-01-02\n2   2018-01-03\ndtype: datetime64[ns]\n\u003e\u003e\u003e s.dt.day_name()\n0       Monday\n1      Tuesday\n2    Wednesday\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.delete", "label": "delete", "shape": "dot", "size": 20, "title": "NAME: delete\n------------------------------\nINPUTS: self, loc\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make new Index with passed location(-s) deleted. Parameters ---------- loc : int or list of int Location of item(-s) which will be deleted. Use a list of locations to delete more than one value at the same time. Returns -------...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.delete(1)\nIndex([\u0027a\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.diff", "label": "diff", "shape": "dot", "size": 20, "title": "NAME: diff\n------------------------------\nINPUTS: self, periods\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Computes the difference between consecutive values in the Index object. If periods is greater than 1, computes the difference between values that are `periods` number of positions apart. Parameters ---------- periods : int, optional The number of positions between the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import pandas as pd\n\u003e\u003e\u003e idx = pd.Index([10, 20, 30, 40, 50])\n\u003e\u003e\u003e idx.diff()\nIndex([nan, 10.0, 10.0, 10.0, 10.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.difference", "label": "difference", "shape": "dot", "size": 20, "title": "NAME: difference\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a new Index with elements of index not in `other`. This is the set difference of two Index objects. Parameters ---------- other : Index or array-like sort : bool or None, default None Whether to sort the resulting index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([2, 1, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.difference(idx2)\nIndex([1, 2], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx1.difference(idx2, sort=False)\nIndex([2, 1], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.drop", "label": "drop", "shape": "dot", "size": 20, "title": "NAME: drop\n------------------------------\nINPUTS: self, labels, errors\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Make new Index with passed list of labels deleted. Parameters ---------- labels : array-like or scalar errors : {\u0027ignore\u0027, \u0027raise\u0027}, default \u0027raise\u0027 If \u0027ignore\u0027, suppress error and existing labels are dropped. Returns ------- Index Will be same type as self,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.drop([\u0027a\u0027])\nIndex([\u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.drop_duplicates", "label": "drop_duplicates", "shape": "dot", "size": 20, "title": "NAME: drop_duplicates\n------------------------------\nINPUTS: self, keep\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return Index with duplicate values removed. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, ``False``}, default \u0027first\u0027 - \u0027first\u0027 : Drop duplicates except for the first occurrence. - \u0027last\u0027 : Drop duplicates except for the last occurrence. - ``False`` : Drop all...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027lama\u0027, \u0027cow\u0027, \u0027lama\u0027, \u0027beetle\u0027, \u0027lama\u0027, \u0027hippo\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.droplevel", "label": "droplevel", "shape": "dot", "size": 20, "title": "NAME: droplevel\n------------------------------\nINPUTS: self, level\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return index with requested level(s) removed. If resulting index has only 1 level left, the result will be of Index type, not MultiIndex. The original index is not modified inplace. Parameters ---------- level : int, str, or list-like, default 0...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays(\n... [[1, 2], [3, 4], [5, 6]], names=[\u0027x\u0027, \u0027y\u0027, \u0027z\u0027])\n\u003e\u003e\u003e mi\nMultiIndex([(1, 3, 5),\n            (2, 4, 6)],\n           names=[\u0027x\u0027, \u0027y\u0027, \u0027z\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.dropna", "label": "dropna", "shape": "dot", "size": 20, "title": "NAME: dropna\n------------------------------\nINPUTS: self, how\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return Index without NA/NaN values. Parameters ---------- how : {\u0027any\u0027, \u0027all\u0027}, default \u0027any\u0027 If the Index is a MultiIndex, drop the value when any or all levels are NaN. Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([1, np.nan, 3])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, np.nan, 3])\n\u003e\u003e\u003e idx.dropna()\nIndex([1.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.duplicated", "label": "duplicated", "shape": "dot", "size": 20, "title": "NAME: duplicated\n------------------------------\nINPUTS: self, keep\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Indicate duplicate index values. Duplicated values are indicated as ``True`` values in the resulting array. Either all duplicates, all except the first, or all except the last occurrence of duplicates can be indicated. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, False},...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027lama\u0027, \u0027cow\u0027, \u0027lama\u0027, \u0027beetle\u0027, \u0027lama\u0027])\n\u003e\u003e\u003e idx.duplicated()\narray([False, False,  True, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.equals", "label": "equals", "shape": "dot", "size": 20, "title": "NAME: equals\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Determines if two Index objects contain the same elements....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.factorize", "label": "factorize", "shape": "dot", "size": 20, "title": "NAME: factorize\n------------------------------\nINPUTS: self, sort, use_na_sentinel\nOUTPUTS: tuple[npt.NDArray[np.intp], Index]\n------------------------------\nDESCRIPTION: Encode the object as an enumerated type or categorical variable. This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct values. `factorize` is available as both a top-level function :func:`pandas.factorize`, and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e codes, uniques = pd.factorize(np.array([\u0027b\u0027, \u0027b\u0027, \u0027a\u0027, \u0027c\u0027, \u0027b\u0027], dtype=\"O\"))\n\u003e\u003e\u003e codes\narray([0, 0, 1, 2, 0])\n\u003e\u003e\u003e uniques\narray([\u0027b\u0027, \u0027a\u0027, \u0027c\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.fillna", "label": "fillna", "shape": "dot", "size": 20, "title": "NAME: fillna\n------------------------------\nINPUTS: self, value, downcast\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Fill NA/NaN values with the specified value. Parameters ---------- value : scalar Scalar value to use to fill holes (e.g. 0). This value cannot be a list-likes. downcast : dict, default is None A dict of item-\u003edtype of what to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([np.nan, np.nan, 3])\n\u003e\u003e\u003e idx.fillna(0)\nIndex([0.0, 0.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.floor", "label": "floor", "shape": "dot", "size": 20, "title": "NAME: floor\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Perform floor operation on the data to the specified `freq`. Parameters ---------- freq : str or Offset The frequency level to floor the index to. Must be a fixed frequency like \u0027S\u0027 (second) not \u0027ME\u0027 (month end). See :ref:`frequency aliases...\n\n\nEXAMPLE:\n\u003e\u003e\u003e rng = pd.date_range(\u00271/1/2018 11:59:00\u0027, periods=3, freq=\u0027min\u0027)\n\u003e\u003e\u003e rng\nDatetimeIndex([\u00272018-01-01 11:59:00\u0027, \u00272018-01-01 12:00:00\u0027,\n               \u00272018-01-01 12:01:00\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=\u0027min\u0027)\n\u003e\u003e\u003e rng.floor(\u0027h\u0027)\nDatetimeIndex([\u00272018-01-01 11:00:00\u0027, \u00272018-01-01 12:00:00\u0027,\n               \u00272018-01-01 12:00:00\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=None)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.format", "label": "format", "shape": "dot", "size": 20, "title": "NAME: format\n------------------------------\nINPUTS: self, name, formatter, na_rep, date_format\nOUTPUTS: list[str]\n------------------------------\nDESCRIPTION: Render a string representation of the Index....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.get_indexer", "label": "get_indexer", "shape": "dot", "size": 20, "title": "NAME: get_indexer\n------------------------------\nINPUTS: self, target, method, limit, tolerance\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Compute indexer and mask for new index given the current index. The indexer should be then used as an input to ndarray.take to align the current data to the new index. Parameters ---------- target : Index method : {None, \u0027pad\u0027/\u0027ffill\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([\u0027c\u0027, \u0027a\u0027, \u0027b\u0027])\n\u003e\u003e\u003e index.get_indexer([\u0027a\u0027, \u0027b\u0027, \u0027x\u0027])\narray([ 1,  2, -1])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.get_indexer_for", "label": "get_indexer_for", "shape": "dot", "size": 20, "title": "NAME: get_indexer_for\n------------------------------\nINPUTS: self, target\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Guaranteed return of an indexer even when non-unique. This dispatches to get_indexer or get_indexer_non_unique as appropriate. Returns ------- np.ndarray[np.intp] List of indices. Examples -------- \u003e\u003e\u003e idx = pd.Index([np.nan, \u0027var1\u0027, np.nan]) \u003e\u003e\u003e idx.get_indexer_for([np.nan]) array([0, 2])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([np.nan, \u0027var1\u0027, np.nan])\n\u003e\u003e\u003e idx.get_indexer_for([np.nan])\narray([0, 2])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.get_indexer_non_unique", "label": "get_indexer_non_unique", "shape": "dot", "size": 20, "title": "NAME: get_indexer_non_unique\n------------------------------\nINPUTS: self, target\nOUTPUTS: tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]\n------------------------------\nDESCRIPTION: Compute indexer and mask for new index given the current index. The indexer should be then used as an input to ndarray.take to align the current data to the new index. Parameters ---------- target : Index Returns ------- indexer :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([\u0027c\u0027, \u0027b\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027])\n\u003e\u003e\u003e index.get_indexer_non_unique([\u0027b\u0027, \u0027b\u0027])\n(array([1, 3, 4, 1, 3, 4]), array([], dtype=int64))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.get_level_values", "label": "get_level_values", "shape": "dot", "size": 20, "title": "NAME: get_level_values\n------------------------------\nINPUTS: self, level\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Return an Index of values for requested level. This is primarily useful to get an individual level of values from a MultiIndex, but is provided on Index as well for compatibility. Parameters ---------- level : int or str It is...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abc\u0027))\n\u003e\u003e\u003e idx\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.get_loc", "label": "get_loc", "shape": "dot", "size": 20, "title": "NAME: get_loc\n------------------------------\nINPUTS: self, key\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Get integer location for requested label Returns ------- loc : int...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.get_slice_bound", "label": "get_slice_bound", "shape": "dot", "size": 20, "title": "NAME: get_slice_bound\n------------------------------\nINPUTS: self, label, side\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Calculate slice bound that corresponds to given label. Returns leftmost (one-past-the-rightmost if ``side==\u0027right\u0027``) position of given label. Parameters ---------- label : object side : {\u0027left\u0027, \u0027right\u0027} Returns ------- int Index of label. See Also -------- Index.get_loc : Get integer location,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.RangeIndex(5)\n\u003e\u003e\u003e idx.get_slice_bound(3, \u0027left\u0027)\n3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.groupby", "label": "groupby", "shape": "dot", "size": 20, "title": "NAME: groupby\n------------------------------\nINPUTS: self, values\nOUTPUTS: PrettyDict[Hashable, np.ndarray]\n------------------------------\nDESCRIPTION: Group the index labels by a given array of values. Parameters ---------- values : array Values used to determine the groups. Returns ------- dict {group name -\u003e group labels}...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.holds_integer", "label": "holds_integer", "shape": "dot", "size": 20, "title": "NAME: holds_integer\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Whether the type is an integer type. .. deprecated:: 2.0.0 Use `pandas.api.types.infer_dtype` instead...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.identical", "label": "identical", "shape": "dot", "size": 20, "title": "NAME: identical\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Similar to equals, but checks that object attributes and types are also equal. Returns ------- bool If two Index objects have equal elements and same type True, otherwise False. Examples -------- \u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027]) \u003e\u003e\u003e idx2 =...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx2 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx2.identical(idx1)\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.indexer_at_time", "label": "indexer_at_time", "shape": "dot", "size": 20, "title": "NAME: indexer_at_time\n------------------------------\nINPUTS: self, time, asof\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Return index locations of values at particular time of day. Parameters ---------- time : datetime.time or str Time passed in either as object (datetime.time) or as string in appropriate format (\"%H:%M\", \"%H%M\", \"%I:%M%p\", \"%I%M%p\", \"%H:%M:%S\", \"%H%M%S\", \"%I:%M:%S%p\", \"%I%M%S%p\"). Returns -------...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.DatetimeIndex([\"1/1/2020 10:00\", \"2/1/2020 11:00\",\n...                         \"3/1/2020 10:00\"])\n\u003e\u003e\u003e idx.indexer_at_time(\"10:00\")\narray([0, 2])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.indexer_between_time", "label": "indexer_between_time", "shape": "dot", "size": 20, "title": "NAME: indexer_between_time\n------------------------------\nINPUTS: self, start_time, end_time, include_start, include_end\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Return index locations of values between particular times of day. Parameters ---------- start_time, end_time : datetime.time, str Time passed either as object (datetime.time) or as string in appropriate format (\"%H:%M\", \"%H%M\", \"%I:%M%p\", \"%I%M%p\", \"%H:%M:%S\", \"%H%M%S\", \"%I:%M:%S%p\",\"%I%M%S%p\"). include_start : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.date_range(\"2023-01-01\", periods=4, freq=\"h\")\n\u003e\u003e\u003e idx\nDatetimeIndex([\u00272023-01-01 00:00:00\u0027, \u00272023-01-01 01:00:00\u0027,\n                   \u00272023-01-01 02:00:00\u0027, \u00272023-01-01 03:00:00\u0027],\n                  dtype=\u0027datetime64[ns]\u0027, freq=\u0027h\u0027)\n\u003e\u003e\u003e idx.indexer_between_time(\"00:00\", \"2:00\", include_end=False)\narray([0, 1])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.infer_objects", "label": "infer_objects", "shape": "dot", "size": 20, "title": "NAME: infer_objects\n------------------------------\nINPUTS: self, copy\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: If we have an object dtype, try to infer a non-object dtype. Parameters ---------- copy : bool, default True Whether to make a copy in cases where no inference occurs....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.insert", "label": "insert", "shape": "dot", "size": 20, "title": "NAME: insert\n------------------------------\nINPUTS: self, loc, item\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Make new Index inserting new item at location. Follows Python numpy.insert semantics for negative values. Parameters ---------- loc : int item : object Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e idx.insert(1, \u0027x\u0027) Index([\u0027a\u0027, \u0027x\u0027, \u0027b\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.insert(1, \u0027x\u0027)\nIndex([\u0027a\u0027, \u0027x\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.intersection", "label": "intersection", "shape": "dot", "size": 20, "title": "NAME: intersection\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Form the intersection of two Index objects. This returns a new Index with elements common to the index and `other`. Parameters ---------- other : Index or array-like sort : True, False or None, default False Whether to sort the resulting...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.intersection(idx2)\nIndex([3, 4], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.is_", "label": "is_", "shape": "dot", "size": 20, "title": "NAME: is_\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: More flexible, faster check like ``is`` but that works through views. Note: this is *not* the same as ``Index.identical()``, which checks that metadata is also the same. Parameters ---------- other : object Other object to compare against. Returns ------- bool...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx1.is_(idx1.view())\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.is_boolean", "label": "is_boolean", "shape": "dot", "size": 20, "title": "NAME: is_boolean\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of booleans. .. deprecated:: 2.0.0 Use `pandas.api.types.is_bool_dtype` instead. Returns ------- bool Whether or not the Index only consists of booleans. See Also -------- is_integer : Check if the Index only consists of integers (deprecated)....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([True, False, True])\n\u003e\u003e\u003e idx.is_boolean()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.is_categorical", "label": "is_categorical", "shape": "dot", "size": 20, "title": "NAME: is_categorical\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index holds categorical data. .. deprecated:: 2.0.0 Use `isinstance(index.dtype, pd.CategoricalDtype)` instead. Returns ------- bool True if the Index is categorical. See Also -------- CategoricalIndex : Index for categorical data. is_boolean : Check if the Index only consists...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n...                 \"Watermelon\"]).astype(\"category\")\n\u003e\u003e\u003e idx.is_categorical()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.is_floating", "label": "is_floating", "shape": "dot", "size": 20, "title": "NAME: is_floating\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index is a floating type. .. deprecated:: 2.0.0 Use `pandas.api.types.is_float_dtype` instead The Index may consist of only floats, NaNs, or a mix of floats, integers, or NaNs. Returns ------- bool Whether or not the Index only consists...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n\u003e\u003e\u003e idx.is_floating()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.is_integer", "label": "is_integer", "shape": "dot", "size": 20, "title": "NAME: is_integer\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of integers. .. deprecated:: 2.0.0 Use `pandas.api.types.is_integer_dtype` instead. Returns ------- bool Whether or not the Index only consists of integers. See Also -------- is_boolean : Check if the Index only consists of booleans (deprecated)....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx.is_integer()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.is_interval", "label": "is_interval", "shape": "dot", "size": 20, "title": "NAME: is_interval\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index holds Interval objects. .. deprecated:: 2.0.0 Use `isinstance(index.dtype, pd.IntervalDtype)` instead. Returns ------- bool Whether or not the Index holds Interval objects. See Also -------- IntervalIndex : Index for Interval objects. is_boolean : Check if the Index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([pd.Interval(left=0, right=5),\n...                 pd.Interval(left=5, right=10)])\n\u003e\u003e\u003e idx.is_interval()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.is_numeric", "label": "is_numeric", "shape": "dot", "size": 20, "title": "NAME: is_numeric\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of numeric data. .. deprecated:: 2.0.0 Use `pandas.api.types.is_numeric_dtype` instead. Returns ------- bool Whether or not the Index only consists of numeric data. See Also -------- is_boolean : Check if the Index only consists of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n\u003e\u003e\u003e idx.is_numeric()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.is_object", "label": "is_object", "shape": "dot", "size": 20, "title": "NAME: is_object\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index is of the object dtype. .. deprecated:: 2.0.0 Use `pandas.api.types.is_object_dtype` instead. Returns ------- bool Whether or not the Index is of the object dtype. See Also -------- is_boolean : Check if the Index only consists of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\"Apple\", \"Mango\", \"Watermelon\"])\n\u003e\u003e\u003e idx.is_object()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.isin", "label": "isin", "shape": "dot", "size": 20, "title": "NAME: isin\n------------------------------\nINPUTS: self, values, level\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Return a boolean array where the index values are in `values`. Compute boolean array of whether each index value is found in the passed set of values. The length of the returned boolean array matches the length of the index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1,2,3])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.isna", "label": "isna", "shape": "dot", "size": 20, "title": "NAME: isna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get mapped to ``True`` values. Everything else get mapped to ``False`` values. Characters such as empty strings `\u0027\u0027`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.isna()\narray([False, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.isnull", "label": "isnull", "shape": "dot", "size": 20, "title": "NAME: isnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get mapped to ``True`` values. Everything else get mapped to ``False`` values. Characters such as empty strings `\u0027\u0027`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.isna()\narray([False, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.isocalendar", "label": "isocalendar", "shape": "dot", "size": 20, "title": "NAME: isocalendar\n------------------------------\nINPUTS: self\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Calculate year, week, and day according to the ISO 8601 standard. Returns ------- DataFrame With columns year, week and day. See Also -------- Timestamp.isocalendar : Function return a 3-tuple containing ISO year, week number, and weekday for the given Timestamp...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.date_range(start=\u00272019-12-29\u0027, freq=\u0027D\u0027, periods=4)\n\u003e\u003e\u003e idx.isocalendar()\n            year  week  day\n2019-12-29  2019    52    7\n2019-12-30  2020     1    1\n2019-12-31  2020     1    2\n2020-01-01  2020     1    3\n\u003e\u003e\u003e idx.isocalendar().week\n2019-12-29    52\n2019-12-30     1\n2019-12-31     1\n2020-01-01     1\nFreq: D, Name: week, dtype: UInt32"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.item", "label": "item", "shape": "dot", "size": 20, "title": "NAME: item\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the first element of the underlying data as a Python scalar. Returns ------- scalar The first element of Series or Index. Raises ------ ValueError If the data is not length = 1. Examples -------- \u003e\u003e\u003e s = pd.Series([1]) \u003e\u003e\u003e...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1])\n\u003e\u003e\u003e s.item()\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.join", "label": "join", "shape": "dot", "size": 20, "title": "NAME: join\n------------------------------\nINPUTS: self, other, how, level, return_indexers, sort\nOUTPUTS: Index | tuple[Index, npt.NDArray[np.intp] | None, npt.NDArray[np.intp] | None]\n------------------------------\nDESCRIPTION: Compute join_index and indexers to conform data structures to the new index. Parameters ---------- other : Index how : {\u0027left\u0027, \u0027right\u0027, \u0027inner\u0027, \u0027outer\u0027} level : int or level name, default None return_indexers : bool, default False sort : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx2 = pd.Index([4, 5, 6])\n\u003e\u003e\u003e idx1.join(idx2, how=\u0027outer\u0027)\nIndex([1, 2, 3, 4, 5, 6], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.map", "label": "map", "shape": "dot", "size": 20, "title": "NAME: map\n------------------------------\nINPUTS: self, mapper, na_action\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Map values using an input mapping or function. Parameters ---------- mapper : function, dict, or Series Mapping correspondence. na_action : {None, \u0027ignore\u0027} If \u0027ignore\u0027, propagate NA values, without passing them to the mapping correspondence. Returns ------- Union[Index, MultiIndex] The output...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.map({1: \u0027a\u0027, 2: \u0027b\u0027, 3: \u0027c\u0027})\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.max", "label": "max", "shape": "dot", "size": 20, "title": "NAME: max\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the maximum value of the Index. Parameters ---------- axis : int, optional For compatibility with NumPy. Only 0 or None are allowed. skipna : bool, default True Exclude NA/null values when showing the result. *args, **kwargs Additional arguments and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([3, 2, 1])\n\u003e\u003e\u003e idx.max()\n3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.mean", "label": "mean", "shape": "dot", "size": 20, "title": "NAME: mean\n------------------------------\nINPUTS: self, skipna, axis\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the mean value of the Array. Parameters ---------- skipna : bool, default True Whether to ignore any NaT elements. axis : int, optional, default 0 Returns ------- scalar Timestamp or Timedelta. See Also -------- numpy.ndarray.mean : Returns the average...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.date_range(\u00272001-01-01 00:00\u0027, periods=3)\n\u003e\u003e\u003e idx\nDatetimeIndex([\u00272001-01-01\u0027, \u00272001-01-02\u0027, \u00272001-01-03\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=\u0027D\u0027)\n\u003e\u003e\u003e idx.mean()\nTimestamp(\u00272001-01-02 00:00:00\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.memory_usage", "label": "memory_usage", "shape": "dot", "size": 20, "title": "NAME: memory_usage\n------------------------------\nINPUTS: self, deep\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Memory usage of the values. Parameters ---------- deep : bool, default False Introspect the data deeply, interrogate `object` dtypes for system-level memory consumption. Returns ------- bytes used See Also -------- numpy.ndarray.nbytes : Total bytes consumed by the elements of the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.memory_usage()\n24"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.min", "label": "min", "shape": "dot", "size": 20, "title": "NAME: min\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the minimum value of the Index. Parameters ---------- axis : {None} Dummy argument for consistency with Series. skipna : bool, default True Exclude NA/null values when showing the result. *args, **kwargs Additional arguments and keywords for compatibility with NumPy....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([3, 2, 1])\n\u003e\u003e\u003e idx.min()\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.month_name", "label": "month_name", "shape": "dot", "size": 20, "title": "NAME: month_name\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the month names with specified locale. Parameters ---------- locale : str, optional Locale determining the language in which to return the month name. Default is English locale (``\u0027en_US.utf8\u0027``). Use the command ``locale -a`` on your terminal on Unix systems...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(pd.date_range(start=\u00272018-01\u0027, freq=\u0027ME\u0027, periods=3))\n\u003e\u003e\u003e s\n0   2018-01-31\n1   2018-02-28\n2   2018-03-31\ndtype: datetime64[ns]\n\u003e\u003e\u003e s.dt.month_name()\n0     January\n1    February\n2       March\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.normalize", "label": "normalize", "shape": "dot", "size": 20, "title": "NAME: normalize\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Convert times to midnight. The time component of the date-time is converted to midnight i.e. 00:00:00. This is useful in cases, when the time does not matter. Length is unaltered. The timezones are unaffected. This method is available on Series...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.date_range(start=\u00272014-08-01 10:00\u0027, freq=\u0027h\u0027,\n...                     periods=3, tz=\u0027Asia/Calcutta\u0027)\n\u003e\u003e\u003e idx\nDatetimeIndex([\u00272014-08-01 10:00:00+05:30\u0027,\n               \u00272014-08-01 11:00:00+05:30\u0027,\n               \u00272014-08-01 12:00:00+05:30\u0027],\n                dtype=\u0027datetime64[ns, Asia/Calcutta]\u0027, freq=\u0027h\u0027)\n\u003e\u003e\u003e idx.normalize()\nDatetimeIndex([\u00272014-08-01 00:00:00+05:30\u0027,\n               \u00272014-08-01 00:00:00+05:30\u0027,\n               \u00272014-08-01 00:00:00+05:30\u0027],\n               dtype=\u0027datetime64[ns, Asia/Calcutta]\u0027, freq=None)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.notna", "label": "notna", "shape": "dot", "size": 20, "title": "NAME: notna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to ``True``. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values. NA values, such as None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.notna()\narray([ True,  True, False])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.notnull", "label": "notnull", "shape": "dot", "size": 20, "title": "NAME: notnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to ``True``. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values. NA values, such as None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.notna()\narray([ True,  True, False])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.nunique", "label": "nunique", "shape": "dot", "size": 20, "title": "NAME: nunique\n------------------------------\nINPUTS: self, dropna\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return number of unique elements in the object. Excludes NA values by default. Parameters ---------- dropna : bool, default True Don\u0027t include NaN in the count. Returns ------- int See Also -------- DataFrame.nunique: Method nunique for DataFrame. Series.count: Count non-NA/null...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 3, 5, 7, 7])\n\u003e\u003e\u003e s\n0    1\n1    3\n2    5\n3    7\n4    7\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.putmask", "label": "putmask", "shape": "dot", "size": 20, "title": "NAME: putmask\n------------------------------\nINPUTS: self, mask, value\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Return a new Index of the values set with the mask. Returns ------- Index See Also -------- numpy.ndarray.putmask : Changes elements of an array based on conditional and input values. Examples -------- \u003e\u003e\u003e idx1 = pd.Index([1, 2, 3]) \u003e\u003e\u003e idx2...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx2 = pd.Index([5, 6, 7])\n\u003e\u003e\u003e idx1.putmask([True, False, False], idx2)\nIndex([5, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.ravel", "label": "ravel", "shape": "dot", "size": 20, "title": "NAME: ravel\n------------------------------\nINPUTS: self, order\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a view on self. Returns ------- Index See Also -------- numpy.ndarray.ravel : Return a flattened array. Examples -------- \u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e s.index.ravel() Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e s.index.ravel()\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.reindex", "label": "reindex", "shape": "dot", "size": 20, "title": "NAME: reindex\n------------------------------\nINPUTS: self, target, method, level, limit, tolerance\nOUTPUTS: tuple[Index, npt.NDArray[np.intp] | None]\n------------------------------\nDESCRIPTION: Create index with target\u0027s values. Parameters ---------- target : an iterable method : {None, \u0027pad\u0027/\u0027ffill\u0027, \u0027backfill\u0027/\u0027bfill\u0027, \u0027nearest\u0027}, optional * default: exact matches only. * pad / ffill: find the PREVIOUS index value if no exact match. * backfill / bfill:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.reindex([\u0027car\u0027, \u0027bike\u0027])\n(Index([\u0027car\u0027, \u0027bike\u0027], dtype=\u0027object\u0027), array([0, 1]))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.rename", "label": "rename", "shape": "dot", "size": 20, "title": "NAME: rename\n------------------------------\nINPUTS: self, name, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Alter Index or MultiIndex name. Able to set new names without level. Defaults to returning new index. Length of names must match number of levels in MultiIndex. Parameters ---------- name : label or list of labels Name(s) to set. inplace...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027A\u0027, \u0027C\u0027, \u0027A\u0027, \u0027B\u0027], name=\u0027score\u0027)\n\u003e\u003e\u003e idx.rename(\u0027grade\u0027)\nIndex([\u0027A\u0027, \u0027C\u0027, \u0027A\u0027, \u0027B\u0027], dtype=\u0027object\u0027, name=\u0027grade\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.repeat", "label": "repeat", "shape": "dot", "size": 20, "title": "NAME: repeat\n------------------------------\nINPUTS: self, repeats, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Repeat elements of a Index. Returns a new Index where each element of the current Index is repeated consecutively a given number of times. Parameters ---------- repeats : int or array of ints The number of repetitions for each element....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.repeat(2)\nIndex([\u0027a\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027c\u0027, \u0027c\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.repeat([1, 2, 3])\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027c\u0027, \u0027c\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.round", "label": "round", "shape": "dot", "size": 20, "title": "NAME: round\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Perform round operation on the data to the specified `freq`. Parameters ---------- freq : str or Offset The frequency level to round the index to. Must be a fixed frequency like \u0027S\u0027 (second) not \u0027ME\u0027 (month end). See :ref:`frequency aliases...\n\n\nEXAMPLE:\n\u003e\u003e\u003e rng = pd.date_range(\u00271/1/2018 11:59:00\u0027, periods=3, freq=\u0027min\u0027)\n\u003e\u003e\u003e rng\nDatetimeIndex([\u00272018-01-01 11:59:00\u0027, \u00272018-01-01 12:00:00\u0027,\n               \u00272018-01-01 12:01:00\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=\u0027min\u0027)\n\u003e\u003e\u003e rng.round(\u0027h\u0027)\nDatetimeIndex([\u00272018-01-01 12:00:00\u0027, \u00272018-01-01 12:00:00\u0027,\n               \u00272018-01-01 12:00:00\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=None)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.searchsorted", "label": "searchsorted", "shape": "dot", "size": 20, "title": "NAME: searchsorted\n------------------------------\nINPUTS: self, value, side, sorter\nOUTPUTS: npt.NDArray[np.intp] | np.intp\n------------------------------\nDESCRIPTION: Find indices where elements should be inserted to maintain order. Find the indices into a sorted Index `self` such that, if the corresponding elements in `value` were inserted before the indices, the order of `self` would be preserved. .. note::...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([1, 2, 3])\n\u003e\u003e\u003e ser\n0    1\n1    2\n2    3\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.set_names", "label": "set_names", "shape": "dot", "size": 20, "title": "NAME: set_names\n------------------------------\nINPUTS: self, names, level, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Set Index or MultiIndex name. Able to set new names partially and by level. Parameters ---------- names : label or list of label or dict-like for MultiIndex Name(s) to set. .. versionchanged:: 1.3.0 level : int, label or list of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx.set_names(\u0027quarter\u0027)\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027, name=\u0027quarter\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.shift", "label": "shift", "shape": "dot", "size": 20, "title": "NAME: shift\n------------------------------\nINPUTS: self, periods, freq\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Shift index by desired number of time frequency increments. This method is for shifting the values of datetime-like indexes by a specified time increment a given number of times. Parameters ---------- periods : int, default 1 Number of periods (or...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.slice_indexer", "label": "slice_indexer", "shape": "dot", "size": 20, "title": "NAME: slice_indexer\n------------------------------\nINPUTS: self, start, end, step\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return indexer for specified label slice. Index.slice_indexer, customized to handle time slicing. In addition to functionality provided by Index.slice_indexer, does the following: - if both `start` and `end` are instances of `datetime.time`, it invokes `indexer_between_time` - if `start` and `end`...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.slice_locs", "label": "slice_locs", "shape": "dot", "size": 20, "title": "NAME: slice_locs\n------------------------------\nINPUTS: self, start, end, step\nOUTPUTS: tuple[int, int]\n------------------------------\nDESCRIPTION: Compute slice locations for input labels. Parameters ---------- start : label, default None If None, defaults to the beginning. end : label, default None If None, defaults to the end. step : int, defaults None If None, defaults to 1....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abcd\u0027))\n\u003e\u003e\u003e idx.slice_locs(start=\u0027b\u0027, end=\u0027c\u0027)\n(1, 3)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.snap", "label": "snap", "shape": "dot", "size": 20, "title": "NAME: snap\n------------------------------\nINPUTS: self, freq\nOUTPUTS: DatetimeIndex\n------------------------------\nDESCRIPTION: Snap time stamps to nearest occurring frequency. Returns ------- DatetimeIndex Examples -------- \u003e\u003e\u003e idx = pd.DatetimeIndex([\u00272023-01-01\u0027, \u00272023-01-02\u0027, ... \u00272023-02-01\u0027, \u00272023-02-02\u0027]) \u003e\u003e\u003e idx DatetimeIndex([\u00272023-01-01\u0027, \u00272023-01-02\u0027, \u00272023-02-01\u0027, \u00272023-02-02\u0027], dtype=\u0027datetime64[ns]\u0027, freq=None) \u003e\u003e\u003e idx.snap(\u0027MS\u0027) DatetimeIndex([\u00272023-01-01\u0027, \u00272023-01-01\u0027, \u00272023-02-01\u0027, \u00272023-02-01\u0027], dtype=\u0027datetime64[ns]\u0027, freq=None)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.DatetimeIndex([\u00272023-01-01\u0027, \u00272023-01-02\u0027,\n...                        \u00272023-02-01\u0027, \u00272023-02-02\u0027])\n\u003e\u003e\u003e idx\nDatetimeIndex([\u00272023-01-01\u0027, \u00272023-01-02\u0027, \u00272023-02-01\u0027, \u00272023-02-02\u0027],\ndtype=\u0027datetime64[ns]\u0027, freq=None)\n\u003e\u003e\u003e idx.snap(\u0027MS\u0027)\nDatetimeIndex([\u00272023-01-01\u0027, \u00272023-01-01\u0027, \u00272023-02-01\u0027, \u00272023-02-01\u0027],\ndtype=\u0027datetime64[ns]\u0027, freq=None)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.sort", "label": "sort", "shape": "dot", "size": 20, "title": "NAME: sort\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Use sort_values instead....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.sort_values", "label": "sort_values", "shape": "dot", "size": 20, "title": "NAME: sort_values\n------------------------------\nINPUTS: self, return_indexer, ascending, na_position, key\nOUTPUTS: Self | tuple[Self, np.ndarray]\n------------------------------\nDESCRIPTION: Return a sorted copy of the index. Return a sorted copy of the index, and optionally return the indices that sorted the index itself. Parameters ---------- return_indexer : bool, default False Should the indices that would sort the index be...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([10, 100, 1, 1000])\n\u003e\u003e\u003e idx\nIndex([10, 100, 1, 1000], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.sortlevel", "label": "sortlevel", "shape": "dot", "size": 20, "title": "NAME: sortlevel\n------------------------------\nINPUTS: self, level, ascending, sort_remaining, na_position\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: For internal compatibility with the Index API. Sort the Index. This is for compat with MultiIndex Parameters ---------- ascending : bool, default True False to sort in descending order na_position : {\u0027first\u0027 or \u0027last\u0027}, default \u0027first\u0027 Argument \u0027first\u0027 puts NaNs...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.std", "label": "std", "shape": "dot", "size": 20, "title": "NAME: std\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return sample standard deviation over requested axis. Normalized by `N-1` by default. This can be changed using ``ddof``. Parameters ---------- axis : int, optional Axis for the function to be applied on. For :class:`pandas.Series` this parameter is unused and defaults...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.date_range(\u00272001-01-01 00:00\u0027, periods=3)\n\u003e\u003e\u003e idx\nDatetimeIndex([\u00272001-01-01\u0027, \u00272001-01-02\u0027, \u00272001-01-03\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=\u0027D\u0027)\n\u003e\u003e\u003e idx.std()\nTimedelta(\u00271 days 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.str", "label": "str", "shape": "dot", "size": 20, "title": "NAME: str\n------------------------------\nINPUTS: data\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Vectorized string functions for Series and Index. NAs stay NA unless handled otherwise by a particular method. Patterned after Python\u0027s string methods, with some inspiration from R\u0027s stringr package. Examples -------- \u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"]) \u003e\u003e\u003e s 0 A_Str_Series dtype:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"])\n\u003e\u003e\u003e s\n0    A_Str_Series\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.strftime", "label": "strftime", "shape": "dot", "size": 20, "title": "NAME: strftime\n------------------------------\nINPUTS: self, date_format\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Convert to Index using specified date_format. Return an Index of formatted strings specified by date_format, which supports the same string format as the python standard library. Details of the string format can be found in `python string format doc \u003chttps://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior\u003e`__....\n\n\nEXAMPLE:\n\u003e\u003e\u003e rng = pd.date_range(pd.Timestamp(\"2018-03-10 09:00\"),\n...                     periods=3, freq=\u0027s\u0027)\n\u003e\u003e\u003e rng.strftime(\u0027%B %d, %Y, %r\u0027)\nIndex([\u0027March 10, 2018, 09:00:00 AM\u0027, \u0027March 10, 2018, 09:00:01 AM\u0027,\n       \u0027March 10, 2018, 09:00:02 AM\u0027],\n      dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.symmetric_difference", "label": "symmetric_difference", "shape": "dot", "size": 20, "title": "NAME: symmetric_difference\n------------------------------\nINPUTS: self, other, result_name, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Compute the symmetric difference of two Index objects. Parameters ---------- other : Index or array-like result_name : str sort : bool or None, default None Whether to sort the resulting index. By default, the values are attempted to be sorted,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([2, 3, 4, 5])\n\u003e\u003e\u003e idx1.symmetric_difference(idx2)\nIndex([1, 5], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.take", "label": "take", "shape": "dot", "size": 20, "title": "NAME: take\n------------------------------\nINPUTS: self, indices, axis, allow_fill, fill_value, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a new Index of the values selected by the indices. For internal compatibility with numpy arrays. Parameters ---------- indices : array-like Indices to be taken. axis : int, optional The axis over which to select values, always 0. allow_fill...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.take([2, 2, 1, 2])\nIndex([\u0027c\u0027, \u0027c\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.to_flat_index", "label": "to_flat_index", "shape": "dot", "size": 20, "title": "NAME: to_flat_index\n------------------------------\nINPUTS: self\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Identity method. This is implemented for compatibility with subclass implementations when chaining. Returns ------- pd.Index Caller. See Also -------- MultiIndex.to_flat_index : Subclass implementation....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.to_frame", "label": "to_frame", "shape": "dot", "size": 20, "title": "NAME: to_frame\n------------------------------\nINPUTS: self, index, name\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Create a DataFrame with a column containing the Index. Parameters ---------- index : bool, default True Set the index of the returned DataFrame as the original Index. name : object, defaults to index.name The passed name should substitute for the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027Ant\u0027, \u0027Bear\u0027, \u0027Cow\u0027], name=\u0027animal\u0027)\n\u003e\u003e\u003e idx.to_frame()\n       animal\nanimal\nAnt       Ant\nBear     Bear\nCow       Cow"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.to_julian_date", "label": "to_julian_date", "shape": "dot", "size": 20, "title": "NAME: to_julian_date\n------------------------------\nINPUTS: self\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Convert Datetime Array to float64 ndarray of Julian Dates. 0 Julian date is noon January 1, 4713 BC. https://en.wikipedia.org/wiki/Julian_day...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.to_list", "label": "to_list", "shape": "dot", "size": 20, "title": "NAME: to_list\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list See Also -------- numpy.ndarray.tolist : Return the array as an...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.to_list()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.to_numpy", "label": "to_numpy", "shape": "dot", "size": 20, "title": "NAME: to_numpy\n------------------------------\nINPUTS: self, dtype, copy, na_value, kwargs\nOUTPUTS: np.ndarray\n------------------------------\nDESCRIPTION: A NumPy ndarray representing the values in this Series or Index. Parameters ---------- dtype : str or numpy.dtype, optional The dtype to pass to :meth:`numpy.asarray`. copy : bool, default False Whether to ensure that the returned value is not a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series(pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027]))\n\u003e\u003e\u003e ser.to_numpy()\narray([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.to_period", "label": "to_period", "shape": "dot", "size": 20, "title": "NAME: to_period\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Cast to PeriodArray/PeriodIndex at a particular frequency. Converts DatetimeArray/Index to PeriodArray/PeriodIndex. Parameters ---------- freq : str or Period, optional One of pandas\u0027 :ref:`period aliases \u003ctimeseries.period_aliases\u003e` or an Period object. Will be inferred by default. Returns ------- PeriodArray/PeriodIndex Raises ------ ValueError...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"y\": [1, 2, 3]},\n...                   index=pd.to_datetime([\"2000-03-31 00:00:00\",\n...                                         \"2000-05-31 00:00:00\",\n...                                         \"2000-08-31 00:00:00\"]))\n\u003e\u003e\u003e df.index.to_period(\"M\")\nPeriodIndex([\u00272000-03\u0027, \u00272000-05\u0027, \u00272000-08\u0027],\n            dtype=\u0027period[M]\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.to_pydatetime", "label": "to_pydatetime", "shape": "dot", "size": 20, "title": "NAME: to_pydatetime\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return an ndarray of ``datetime.datetime`` objects. Returns ------- numpy.ndarray Examples -------- \u003e\u003e\u003e idx = pd.date_range(\u00272018-02-27\u0027, periods=3) \u003e\u003e\u003e idx.to_pydatetime() array([datetime.datetime(2018, 2, 27, 0, 0), datetime.datetime(2018, 2, 28, 0, 0), datetime.datetime(2018, 3, 1, 0, 0)], dtype=object)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.date_range(\u00272018-02-27\u0027, periods=3)\n\u003e\u003e\u003e idx.to_pydatetime()\narray([datetime.datetime(2018, 2, 27, 0, 0),\n       datetime.datetime(2018, 2, 28, 0, 0),\n       datetime.datetime(2018, 3, 1, 0, 0)], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.to_series", "label": "to_series", "shape": "dot", "size": 20, "title": "NAME: to_series\n------------------------------\nINPUTS: self, index, name\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Create a Series with both index and values equal to the index keys. Useful with map for returning an indexer based on an index. Parameters ---------- index : Index, optional Index of resulting Series. If None, defaults to original index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027Ant\u0027, \u0027Bear\u0027, \u0027Cow\u0027], name=\u0027animal\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.tolist", "label": "tolist", "shape": "dot", "size": 20, "title": "NAME: tolist\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list See Also -------- numpy.ndarray.tolist : Return the array as an...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.to_list()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.transpose", "label": "transpose", "shape": "dot", "size": 20, "title": "NAME: transpose\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return the transpose, which is by definition self. Returns ------- %(klass)s...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.tz_convert", "label": "tz_convert", "shape": "dot", "size": 20, "title": "NAME: tz_convert\n------------------------------\nINPUTS: self, tz\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Convert tz-aware Datetime Array/Index from one time zone to another. Parameters ---------- tz : str, pytz.timezone, dateutil.tz.tzfile, datetime.tzinfo or None Time zone for time. Corresponding timestamps would be converted to this time zone of the Datetime Array/Index. A `tz` of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e dti = pd.date_range(start=\u00272014-08-01 09:00\u0027,\n...                     freq=\u0027h\u0027, periods=3, tz=\u0027Europe/Berlin\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.tz_localize", "label": "tz_localize", "shape": "dot", "size": 20, "title": "NAME: tz_localize\n------------------------------\nINPUTS: self, tz, ambiguous, nonexistent\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Localize tz-naive Datetime Array/Index to tz-aware Datetime Array/Index. This method takes a time zone (tz) naive Datetime Array/Index object and makes this time zone aware. It does not move the time to another time zone. This method can also be...\n\n\nEXAMPLE:\n\u003e\u003e\u003e tz_naive = pd.date_range(\u00272018-03-01 09:00\u0027, periods=3)\n\u003e\u003e\u003e tz_naive\nDatetimeIndex([\u00272018-03-01 09:00:00\u0027, \u00272018-03-02 09:00:00\u0027,\n               \u00272018-03-03 09:00:00\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=\u0027D\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.union", "label": "union", "shape": "dot", "size": 20, "title": "NAME: union\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Form the union of two Index objects. If the Index objects are incompatible, both Index objects will be cast to dtype(\u0027object\u0027) first. Parameters ---------- other : Index or array-like sort : bool or None, default None Whether to sort the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.union(idx2)\nIndex([1, 2, 3, 4, 5, 6], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.unique", "label": "unique", "shape": "dot", "size": 20, "title": "NAME: unique\n------------------------------\nINPUTS: self, level\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return unique values in the index. Unique values are returned in order of appearance, this does NOT sort. Parameters ---------- level : int or hashable, optional Only return values from specified level (for MultiIndex). If int, gets the level by...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 1, 2, 3, 3])\n\u003e\u003e\u003e idx.unique()\nIndex([1, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.value_counts", "label": "value_counts", "shape": "dot", "size": 20, "title": "NAME: value_counts\n------------------------------\nINPUTS: self, normalize, sort, ascending, bins, dropna\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return a Series containing counts of unique values. The resulting object will be in descending order so that the first element is the most frequently-occurring element. Excludes NA values by default. Parameters ---------- normalize : bool, default False If True...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([3, 1, 2, 3, 4, np.nan])\n\u003e\u003e\u003e index.value_counts()\n3.0    2\n1.0    1\n2.0    1\n4.0    1\nName: count, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.view", "label": "view", "shape": "dot", "size": 20, "title": "NAME: view\n------------------------------\nINPUTS: self, cls\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeIndex.where", "label": "where", "shape": "dot", "size": 20, "title": "NAME: where\n------------------------------\nINPUTS: self, cond, other\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Replace values where the condition is False. The replacement is taken from other. Parameters ---------- cond : bool array-like with the same length as self Condition to select the values on. other : scalar, or array-like, default None Replacement if...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.where(idx.isin([\u0027car\u0027, \u0027train\u0027]), \u0027other\u0027)\nIndex([\u0027car\u0027, \u0027other\u0027, \u0027train\u0027, \u0027other\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeTZDtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: \nOUTPUTS: type_t[DatetimeArray]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeTZDtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: DatetimeTZDtype\n------------------------------\nDESCRIPTION: Construct a DatetimeTZDtype from a string. Parameters ---------- string : str The string alias for this DatetimeTZDtype. Should be formatted like ``datetime64[ns, \u003ctz\u003e]``, where ``\u003ctz\u003e`` is the timezone name. Examples -------- \u003e\u003e\u003e DatetimeTZDtype.construct_from_string(\u0027datetime64[ns, UTC]\u0027) datetime64[ns, UTC]...\n\n\nEXAMPLE:\n\u003e\u003e\u003e DatetimeTZDtype.construct_from_string(\u0027datetime64[ns, UTC]\u0027)\ndatetime64[ns, UTC]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeTZDtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeTZDtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if we match \u0027dtype\u0027. Parameters ---------- dtype : object The object to check. Returns ------- bool Notes ----- The default implementation is True if 1. ``cls.construct_from_string(dtype)`` is an instance of ``cls``. 2. ``dtype`` is an object and is an...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.DatetimeTZDtype.reset_cache", "label": "reset_cache", "shape": "dot", "size": 20, "title": "NAME: reset_cache\n------------------------------\nINPUTS: \nOUTPUTS: None\n------------------------------\nDESCRIPTION: clear the cache...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.DatetimeTZDtype.type", "label": "type", "shape": "dot", "size": 20, "title": "NAME: type\n------------------------------\nINPUTS: ts_input, year, month, day, hour, minute, second, microsecond, tzinfo, nanosecond, tz, unit, fold\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Pandas replacement for python datetime.datetime object. Timestamp is the pandas equivalent of python\u0027s Datetime and is interchangeable with it in most cases. It\u0027s the type used for the entries that make up a DatetimeIndex, and other timeseries oriented data structures...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Timestamp(\u00272017-01-01T12\u0027)\nTimestamp(\u00272017-01-01 12:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.ExcelFile.CalamineReader", "label": "CalamineReader", "shape": "dot", "size": 20, "title": "NAME: CalamineReader\n------------------------------\nINPUTS: filepath_or_buffer, storage_options, engine_kwargs\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Abstract base class for generic types. A generic type is typically declared by inheriting from this class parameterized with one or more type variables. For example, a generic mapping type might be defined as:: class Mapping(Generic[KT, VT]): def __getitem__(self, key:...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.ExcelFile.ODFReader", "label": "ODFReader", "shape": "dot", "size": 20, "title": "NAME: ODFReader\n------------------------------\nINPUTS: filepath_or_buffer, storage_options, engine_kwargs\nOUTPUTS: None\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.ExcelFile.OpenpyxlReader", "label": "OpenpyxlReader", "shape": "dot", "size": 20, "title": "NAME: OpenpyxlReader\n------------------------------\nINPUTS: filepath_or_buffer, storage_options, engine_kwargs\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Abstract base class for generic types. A generic type is typically declared by inheriting from this class parameterized with one or more type variables. For example, a generic mapping type might be defined as:: class Mapping(Generic[KT, VT]): def __getitem__(self, key:...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.ExcelFile.PyxlsbReader", "label": "PyxlsbReader", "shape": "dot", "size": 20, "title": "NAME: PyxlsbReader\n------------------------------\nINPUTS: filepath_or_buffer, storage_options, engine_kwargs\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Abstract base class for generic types. A generic type is typically declared by inheriting from this class parameterized with one or more type variables. For example, a generic mapping type might be defined as:: class Mapping(Generic[KT, VT]): def __getitem__(self, key:...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.ExcelFile.XlrdReader", "label": "XlrdReader", "shape": "dot", "size": 20, "title": "NAME: XlrdReader\n------------------------------\nINPUTS: filepath_or_buffer, storage_options, engine_kwargs\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Abstract base class for generic types. A generic type is typically declared by inheriting from this class parameterized with one or more type variables. For example, a generic mapping type might be defined as:: class Mapping(Generic[KT, VT]): def __getitem__(self, key:...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.ExcelFile.close", "label": "close", "shape": "dot", "size": 20, "title": "NAME: close\n------------------------------\nINPUTS: self\nOUTPUTS: None\n------------------------------\nDESCRIPTION: close io if necessary...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.ExcelFile.parse", "label": "parse", "shape": "dot", "size": 20, "title": "NAME: parse\n------------------------------\nINPUTS: self, sheet_name, header, names, index_col, usecols, converters, true_values, false_values, skiprows, nrows, na_values, parse_dates, date_parser, date_format, thousands, comment, skipfooter, dtype_backend, kwds\nOUTPUTS: DataFrame | dict[str, DataFrame] | dict[int, DataFrame]\n------------------------------\nDESCRIPTION: Parse specified sheet(s) into a DataFrame. Equivalent to read_excel(ExcelFile, ...) See the read_excel docstring for more info on accepted parameters. Returns ------- DataFrame or dict of DataFrames DataFrame from the passed in Excel file. Examples -------- \u003e\u003e\u003e df = pd.DataFrame([[1,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], columns=[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027])\n\u003e\u003e\u003e df.to_excel(\u0027myfile.xlsx\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e file = pd.ExcelFile(\u0027myfile.xlsx\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e file.parse()  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.ExcelWriter.check_extension", "label": "check_extension", "shape": "dot", "size": 20, "title": "NAME: check_extension\n------------------------------\nINPUTS: ext\nOUTPUTS: Literal[True]\n------------------------------\nDESCRIPTION: checks that path\u0027s extension against the Writer\u0027s supported extensions. If it isn\u0027t supported, raises UnsupportedFiletypeError....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.ExcelWriter.close", "label": "close", "shape": "dot", "size": 20, "title": "NAME: close\n------------------------------\nINPUTS: self\nOUTPUTS: None\n------------------------------\nDESCRIPTION: synonym for save, to make it more file-like...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Float32Dtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: \nOUTPUTS: type[FloatingArray]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Float32Dtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Construct this type from a string. This is useful mainly for data types that accept parameters. For example, a period dtype accepts a frequency parameter that can be set as ``period[h]`` (where H means hourly frequency). By default, in the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import re\n\u003e\u003e\u003e @classmethod\n... def construct_from_string(cls, string):\n...     pattern = re.compile(r\"^my_type\\[(?P\u003carg_name\u003e.+)\\]$\")\n...     match = pattern.match(string)\n...     if match:\n...         return cls(**match.groupdict())\n...     else:\n...         raise TypeError(\n...             f\"Cannot construct a \u0027{cls.__name__}\u0027 from \u0027{string}\u0027\"\n...         )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Float32Dtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Float32Dtype.from_numpy_dtype", "label": "from_numpy_dtype", "shape": "dot", "size": 20, "title": "NAME: from_numpy_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: BaseMaskedDtype\n------------------------------\nDESCRIPTION: Construct the MaskedDtype corresponding to the given numpy dtype....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Float32Dtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if we match \u0027dtype\u0027. Parameters ---------- dtype : object The object to check. Returns ------- bool Notes ----- The default implementation is True if 1. ``cls.construct_from_string(dtype)`` is an instance of ``cls``. 2. ``dtype`` is an object and is an...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Float32Dtype.type", "label": "type", "shape": "dot", "size": 20, "title": "NAME: type\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Single-precision floating-point number type, compatible with C ``float``. :Character code: ``\u0027f\u0027`` :Canonical name: `numpy.single` :Alias on this platform (win32 AMD64): `numpy.float32`: 32-bit-precision floating-point number type: sign bit, 8 bits exponent, 23 bits mantissa....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Float64Dtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: \nOUTPUTS: type[FloatingArray]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Float64Dtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Construct this type from a string. This is useful mainly for data types that accept parameters. For example, a period dtype accepts a frequency parameter that can be set as ``period[h]`` (where H means hourly frequency). By default, in the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import re\n\u003e\u003e\u003e @classmethod\n... def construct_from_string(cls, string):\n...     pattern = re.compile(r\"^my_type\\[(?P\u003carg_name\u003e.+)\\]$\")\n...     match = pattern.match(string)\n...     if match:\n...         return cls(**match.groupdict())\n...     else:\n...         raise TypeError(\n...             f\"Cannot construct a \u0027{cls.__name__}\u0027 from \u0027{string}\u0027\"\n...         )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Float64Dtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Float64Dtype.from_numpy_dtype", "label": "from_numpy_dtype", "shape": "dot", "size": 20, "title": "NAME: from_numpy_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: BaseMaskedDtype\n------------------------------\nDESCRIPTION: Construct the MaskedDtype corresponding to the given numpy dtype....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Float64Dtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if we match \u0027dtype\u0027. Parameters ---------- dtype : object The object to check. Returns ------- bool Notes ----- The default implementation is True if 1. ``cls.construct_from_string(dtype)`` is an instance of ``cls``. 2. ``dtype`` is an object and is an...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Float64Dtype.type", "label": "type", "shape": "dot", "size": 20, "title": "NAME: type\n------------------------------\nINPUTS: x\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Double-precision floating-point number type, compatible with Python `float` and C ``double``. :Character code: ``\u0027d\u0027`` :Canonical name: `numpy.double` :Alias: `numpy.float_` :Alias on this platform (win32 AMD64): `numpy.float64`: 64-bit precision floating-point number type: sign bit, 11 bits exponent, 52 bits mantissa....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.append", "label": "append", "shape": "dot", "size": 20, "title": "NAME: append\n------------------------------\nINPUTS: self, key, value, format, axes, index, append, complib, complevel, columns, min_itemsize, nan_rep, chunksize, expectedrows, dropna, data_columns, encoding, errors\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Append to Table in file. Node must already exist and be Table format. Parameters ---------- key : str value : {Series, DataFrame} format : \u0027table\u0027 is the default Format to use when storing object in HDFStore. Value can be one...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df1 = pd.DataFrame([[1, 2], [3, 4]], columns=[\u0027A\u0027, \u0027B\u0027])\n\u003e\u003e\u003e store = pd.HDFStore(\"store.h5\", \u0027w\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e store.put(\u0027data\u0027, df1, format=\u0027table\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e df2 = pd.DataFrame([[5, 6], [7, 8]], columns=[\u0027A\u0027, \u0027B\u0027])\n\u003e\u003e\u003e store.append(\u0027data\u0027, df2)  # doctest: +SKIP\n\u003e\u003e\u003e store.close()  # doctest: +SKIP\n   A  B\n0  1  2\n1  3  4\n0  5  6\n1  7  8"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.append_to_multiple", "label": "append_to_multiple", "shape": "dot", "size": 20, "title": "NAME: append_to_multiple\n------------------------------\nINPUTS: self, d, value, selector, data_columns, axes, dropna, kwargs\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Append to multiple tables Parameters ---------- d : a dict of table_name to table_columns, None is acceptable as the values of one node (this will get all the remaining columns) value : a pandas object selector : a string that...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.close", "label": "close", "shape": "dot", "size": 20, "title": "NAME: close\n------------------------------\nINPUTS: self\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Close the PyTables file handle...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.copy", "label": "copy", "shape": "dot", "size": 20, "title": "NAME: copy\n------------------------------\nINPUTS: self, file, mode, propindexes, keys, complib, complevel, fletcher32, overwrite\nOUTPUTS: HDFStore\n------------------------------\nDESCRIPTION: Copy the existing store to a new file, updating in place. Parameters ---------- propindexes : bool, default True Restore indexes in copied file. keys : list, optional List of keys to include in the copy (defaults to all). overwrite :...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.create_table_index", "label": "create_table_index", "shape": "dot", "size": 20, "title": "NAME: create_table_index\n------------------------------\nINPUTS: self, key, columns, optlevel, kind\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Create a pytables index on the table. Parameters ---------- key : str columns : None, bool, or listlike[str] Indicate which columns to create an index on. * False : Do not create any indexes. * True : Create indexes on...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.flush", "label": "flush", "shape": "dot", "size": 20, "title": "NAME: flush\n------------------------------\nINPUTS: self, fsync\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Force all buffered modifications to be written to disk. Parameters ---------- fsync : bool (default False) call ``os.fsync()`` on the file handle to force writing to disk. Notes ----- Without ``fsync=True``, flushing may not guarantee that the OS writes to...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.get", "label": "get", "shape": "dot", "size": 20, "title": "NAME: get\n------------------------------\nINPUTS: self, key\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Retrieve pandas object stored in file. Parameters ---------- key : str Returns ------- object Same type as object stored in file. Examples -------- \u003e\u003e\u003e df = pd.DataFrame([[1, 2], [3, 4]], columns=[\u0027A\u0027, \u0027B\u0027]) \u003e\u003e\u003e store = pd.HDFStore(\"store.h5\", \u0027w\u0027) # doctest: +SKIP...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[1, 2], [3, 4]], columns=[\u0027A\u0027, \u0027B\u0027])\n\u003e\u003e\u003e store = pd.HDFStore(\"store.h5\", \u0027w\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e store.put(\u0027data\u0027, df)  # doctest: +SKIP\n\u003e\u003e\u003e store.get(\u0027data\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e store.close()  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.get_node", "label": "get_node", "shape": "dot", "size": 20, "title": "NAME: get_node\n------------------------------\nINPUTS: self, key\nOUTPUTS: Node | None\n------------------------------\nDESCRIPTION: return the node with the key or None if it does not exist...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.get_storer", "label": "get_storer", "shape": "dot", "size": 20, "title": "NAME: get_storer\n------------------------------\nINPUTS: self, key\nOUTPUTS: GenericFixed | Table\n------------------------------\nDESCRIPTION: return the storer object for a key, raise if not in the file...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.groups", "label": "groups", "shape": "dot", "size": 20, "title": "NAME: groups\n------------------------------\nINPUTS: self\nOUTPUTS: list\n------------------------------\nDESCRIPTION: Return a list of all the top-level nodes. Each node returned is not a pandas storage object. Returns ------- list List of objects. Examples -------- \u003e\u003e\u003e df = pd.DataFrame([[1, 2], [3, 4]], columns=[\u0027A\u0027, \u0027B\u0027]) \u003e\u003e\u003e store = pd.HDFStore(\"store.h5\", \u0027w\u0027) #...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[1, 2], [3, 4]], columns=[\u0027A\u0027, \u0027B\u0027])\n\u003e\u003e\u003e store = pd.HDFStore(\"store.h5\", \u0027w\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e store.put(\u0027data\u0027, df)  # doctest: +SKIP\n\u003e\u003e\u003e print(store.groups())  # doctest: +SKIP\n\u003e\u003e\u003e store.close()  # doctest: +SKIP\n[/data (Group) \u0027\u0027\n  children := [\u0027axis0\u0027 (Array), \u0027axis1\u0027 (Array), \u0027block0_values\u0027 (Array),\n  \u0027block0_items\u0027 (Array)]]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.info", "label": "info", "shape": "dot", "size": 20, "title": "NAME: info\n------------------------------\nINPUTS: self\nOUTPUTS: str\n------------------------------\nDESCRIPTION: Print detailed information on the store. Returns ------- str Examples -------- \u003e\u003e\u003e df = pd.DataFrame([[1, 2], [3, 4]], columns=[\u0027A\u0027, \u0027B\u0027]) \u003e\u003e\u003e store = pd.HDFStore(\"store.h5\", \u0027w\u0027) # doctest: +SKIP \u003e\u003e\u003e store.put(\u0027data\u0027, df) # doctest: +SKIP \u003e\u003e\u003e print(store.info()) # doctest: +SKIP \u003e\u003e\u003e...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[1, 2], [3, 4]], columns=[\u0027A\u0027, \u0027B\u0027])\n\u003e\u003e\u003e store = pd.HDFStore(\"store.h5\", \u0027w\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e store.put(\u0027data\u0027, df)  # doctest: +SKIP\n\u003e\u003e\u003e print(store.info())  # doctest: +SKIP\n\u003e\u003e\u003e store.close()  # doctest: +SKIP\n\u003cclass \u0027pandas.io.pytables.HDFStore\u0027\u003e\nFile path: store.h5\n/data    frame    (shape-\u003e[2,2])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.items", "label": "items", "shape": "dot", "size": 20, "title": "NAME: items\n------------------------------\nINPUTS: self\nOUTPUTS: Iterator[tuple[str, list]]\n------------------------------\nDESCRIPTION: iterate on key-\u003egroup...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.keys", "label": "keys", "shape": "dot", "size": 20, "title": "NAME: keys\n------------------------------\nINPUTS: self, include\nOUTPUTS: list[str]\n------------------------------\nDESCRIPTION: Return a list of keys corresponding to objects stored in HDFStore. Parameters ---------- include : str, default \u0027pandas\u0027 When kind equals \u0027pandas\u0027 return pandas objects. When kind equals \u0027native\u0027 return native HDF5 Table objects. Returns ------- list List of ABSOLUTE...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[1, 2], [3, 4]], columns=[\u0027A\u0027, \u0027B\u0027])\n\u003e\u003e\u003e store = pd.HDFStore(\"store.h5\", \u0027w\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e store.put(\u0027data\u0027, df)  # doctest: +SKIP\n\u003e\u003e\u003e store.get(\u0027data\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e print(store.keys())  # doctest: +SKIP\n[\u0027/data1\u0027, \u0027/data2\u0027]\n\u003e\u003e\u003e store.close()  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.open", "label": "open", "shape": "dot", "size": 20, "title": "NAME: open\n------------------------------\nINPUTS: self, mode, kwargs\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Open the file in the specified mode Parameters ---------- mode : {\u0027a\u0027, \u0027w\u0027, \u0027r\u0027, \u0027r+\u0027}, default \u0027a\u0027 See HDFStore docstring or tables.open_file for info about modes **kwargs These parameters will be passed to the PyTables open_file method....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.put", "label": "put", "shape": "dot", "size": 20, "title": "NAME: put\n------------------------------\nINPUTS: self, key, value, format, index, append, complib, complevel, min_itemsize, nan_rep, data_columns, encoding, errors, track_times, dropna\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Store object in HDFStore. Parameters ---------- key : str value : {Series, DataFrame} format : \u0027fixed(f)|table(t)\u0027, default is \u0027fixed\u0027 Format to use when storing object in HDFStore. Value can be one of: ``\u0027fixed\u0027`` Fixed format. Fast writing/reading. Not-appendable, nor searchable....\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[1, 2], [3, 4]], columns=[\u0027A\u0027, \u0027B\u0027])\n\u003e\u003e\u003e store = pd.HDFStore(\"store.h5\", \u0027w\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e store.put(\u0027data\u0027, df)  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.remove", "label": "remove", "shape": "dot", "size": 20, "title": "NAME: remove\n------------------------------\nINPUTS: self, key, where, start, stop\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Remove pandas object partially by specifying the where condition Parameters ---------- key : str Node to remove or delete rows from where : list of Term (or convertible) objects, optional start : integer (defaults to None), row number to start...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.select", "label": "select", "shape": "dot", "size": 20, "title": "NAME: select\n------------------------------\nINPUTS: self, key, where, start, stop, columns, iterator, chunksize, auto_close\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Retrieve pandas object stored in file, optionally based on where criteria. .. warning:: Pandas uses PyTables for reading and writing HDF5 files, which allows serializing object-dtype data with pickle when using the \"fixed\" format. Loading pickled data received from untrusted...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[1, 2], [3, 4]], columns=[\u0027A\u0027, \u0027B\u0027])\n\u003e\u003e\u003e store = pd.HDFStore(\"store.h5\", \u0027w\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e store.put(\u0027data\u0027, df)  # doctest: +SKIP\n\u003e\u003e\u003e store.get(\u0027data\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e print(store.keys())  # doctest: +SKIP\n[\u0027/data1\u0027, \u0027/data2\u0027]\n\u003e\u003e\u003e store.select(\u0027/data1\u0027)  # doctest: +SKIP\n   A  B\n0  1  2\n1  3  4\n\u003e\u003e\u003e store.select(\u0027/data1\u0027, where=\u0027columns == A\u0027)  # doctest: +SKIP\n   A\n0  1\n1  3\n\u003e\u003e\u003e store.close()  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.select_as_coordinates", "label": "select_as_coordinates", "shape": "dot", "size": 20, "title": "NAME: select_as_coordinates\n------------------------------\nINPUTS: self, key, where, start, stop\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: return the selection as an Index .. warning:: Pandas uses PyTables for reading and writing HDF5 files, which allows serializing object-dtype data with pickle when using the \"fixed\" format. Loading pickled data received from untrusted sources can be unsafe. See:...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.select_as_multiple", "label": "select_as_multiple", "shape": "dot", "size": 20, "title": "NAME: select_as_multiple\n------------------------------\nINPUTS: self, keys, where, selector, columns, start, stop, iterator, chunksize, auto_close\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Retrieve pandas objects from multiple tables. .. warning:: Pandas uses PyTables for reading and writing HDF5 files, which allows serializing object-dtype data with pickle when using the \"fixed\" format. Loading pickled data received from untrusted sources can be unsafe. See:...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.select_column", "label": "select_column", "shape": "dot", "size": 20, "title": "NAME: select_column\n------------------------------\nINPUTS: self, key, column, start, stop\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: return a single column from the table. This is generally only useful to select an indexable .. warning:: Pandas uses PyTables for reading and writing HDF5 files, which allows serializing object-dtype data with pickle when using the \"fixed\" format. Loading...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.HDFStore.walk", "label": "walk", "shape": "dot", "size": 20, "title": "NAME: walk\n------------------------------\nINPUTS: self, where\nOUTPUTS: Iterator[tuple[str, list[str], list[str]]]\n------------------------------\nDESCRIPTION: Walk the pytables group hierarchy for pandas objects. This generator will yield the group path, subgroups and pandas object names for each group. Any non-pandas PyTables objects that are not a group will be ignored. The `where` group itself is...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df1 = pd.DataFrame([[1, 2], [3, 4]], columns=[\u0027A\u0027, \u0027B\u0027])\n\u003e\u003e\u003e store = pd.HDFStore(\"store.h5\", \u0027w\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e store.put(\u0027data\u0027, df1, format=\u0027table\u0027)  # doctest: +SKIP\n\u003e\u003e\u003e df2 = pd.DataFrame([[5, 6], [7, 8]], columns=[\u0027A\u0027, \u0027B\u0027])\n\u003e\u003e\u003e store.append(\u0027data\u0027, df2)  # doctest: +SKIP\n\u003e\u003e\u003e store.close()  # doctest: +SKIP\n\u003e\u003e\u003e for group in store.walk():  # doctest: +SKIP\n...     print(group)  # doctest: +SKIP\n\u003e\u003e\u003e store.close()  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.all", "label": "all", "shape": "dot", "size": 20, "title": "NAME: all\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return whether all elements are Truthy. Parameters ---------- *args Required for compatibility with numpy. **kwargs Required for compatibility with numpy. Returns ------- bool or array-like (if axis is specified) A single element array-like may be converted to bool. See Also...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Index([1, 2, 3]).all()\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.any", "label": "any", "shape": "dot", "size": 20, "title": "NAME: any\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return whether any element is Truthy. Parameters ---------- *args Required for compatibility with numpy. **kwargs Required for compatibility with numpy. Returns ------- bool or array-like (if axis is specified) A single element array-like may be converted to bool. See Also...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([0, 1, 2])\n\u003e\u003e\u003e index.any()\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.append", "label": "append", "shape": "dot", "size": 20, "title": "NAME: append\n------------------------------\nINPUTS: self, other\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Append a collection of Index options together. Parameters ---------- other : Index or list/tuple of indices Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([1, 2, 3]) \u003e\u003e\u003e idx.append(pd.Index([4])) Index([1, 2, 3, 4], dtype=\u0027int64\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.append(pd.Index([4]))\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.argmax", "label": "argmax", "shape": "dot", "size": 20, "title": "NAME: argmax\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the largest value in the Series. If the maximum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.argmin", "label": "argmin", "shape": "dot", "size": 20, "title": "NAME: argmin\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the smallest value in the Series. If the minimum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.argsort", "label": "argsort", "shape": "dot", "size": 20, "title": "NAME: argsort\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Return the integer indices that would sort the index. Parameters ---------- *args Passed to `numpy.ndarray.argsort`. **kwargs Passed to `numpy.ndarray.argsort`. Returns ------- np.ndarray[np.intp] Integer indices that would sort the index if used as an indexer. See Also -------- numpy.argsort : Similar...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027b\u0027, \u0027a\u0027, \u0027d\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027b\u0027, \u0027a\u0027, \u0027d\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.asof", "label": "asof", "shape": "dot", "size": 20, "title": "NAME: asof\n------------------------------\nINPUTS: self, label\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the label from the index, or, if not present, the previous one. Assuming that the index is sorted, return the passed index label if it is in the index, or return the previous index label if the passed one...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u00272013-12-31\u0027, \u00272014-01-02\u0027, \u00272014-01-03\u0027])\n\u003e\u003e\u003e idx.asof(\u00272014-01-01\u0027)\n\u00272013-12-31\u0027"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.asof_locs", "label": "asof_locs", "shape": "dot", "size": 20, "title": "NAME: asof_locs\n------------------------------\nINPUTS: self, where, mask\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Return the locations (indices) of labels in the index. As in the :meth:`pandas.Index.asof`, if the label (a particular entry in ``where``) is not in the index, the latest index label up to the passed label is chosen and its index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.date_range(\u00272023-06-01\u0027, periods=3, freq=\u0027D\u0027)\n\u003e\u003e\u003e where = pd.DatetimeIndex([\u00272023-05-30 00:12:00\u0027, \u00272023-06-01 00:00:00\u0027,\n...                           \u00272023-06-02 23:59:59\u0027])\n\u003e\u003e\u003e mask = np.ones(3, dtype=bool)\n\u003e\u003e\u003e idx.asof_locs(where, mask)\narray([-1,  0,  1])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.astype", "label": "astype", "shape": "dot", "size": 20, "title": "NAME: astype\n------------------------------\nINPUTS: self, dtype, copy\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Create an Index with values cast to dtypes. The class of a new Index is determined by dtype. When conversion is impossible, a TypeError exception is raised. Parameters ---------- dtype : numpy dtype or pandas type Note that any signed...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx.astype(\u0027float\u0027)\nIndex([1.0, 2.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.copy", "label": "copy", "shape": "dot", "size": 20, "title": "NAME: copy\n------------------------------\nINPUTS: self, name, deep\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make a copy of this object. Name is set on the new object. Parameters ---------- name : Label, optional Set name for new object. deep : bool, default False Returns ------- Index Index refer to new object which is a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e new_idx = idx.copy()\n\u003e\u003e\u003e idx is new_idx\nFalse"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.delete", "label": "delete", "shape": "dot", "size": 20, "title": "NAME: delete\n------------------------------\nINPUTS: self, loc\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make new Index with passed location(-s) deleted. Parameters ---------- loc : int or list of int Location of item(-s) which will be deleted. Use a list of locations to delete more than one value at the same time. Returns -------...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.delete(1)\nIndex([\u0027a\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.diff", "label": "diff", "shape": "dot", "size": 20, "title": "NAME: diff\n------------------------------\nINPUTS: self, periods\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Computes the difference between consecutive values in the Index object. If periods is greater than 1, computes the difference between values that are `periods` number of positions apart. Parameters ---------- periods : int, optional The number of positions between the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import pandas as pd\n\u003e\u003e\u003e idx = pd.Index([10, 20, 30, 40, 50])\n\u003e\u003e\u003e idx.diff()\nIndex([nan, 10.0, 10.0, 10.0, 10.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.difference", "label": "difference", "shape": "dot", "size": 20, "title": "NAME: difference\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a new Index with elements of index not in `other`. This is the set difference of two Index objects. Parameters ---------- other : Index or array-like sort : bool or None, default None Whether to sort the resulting index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([2, 1, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.difference(idx2)\nIndex([1, 2], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx1.difference(idx2, sort=False)\nIndex([2, 1], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.drop", "label": "drop", "shape": "dot", "size": 20, "title": "NAME: drop\n------------------------------\nINPUTS: self, labels, errors\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Make new Index with passed list of labels deleted. Parameters ---------- labels : array-like or scalar errors : {\u0027ignore\u0027, \u0027raise\u0027}, default \u0027raise\u0027 If \u0027ignore\u0027, suppress error and existing labels are dropped. Returns ------- Index Will be same type as self,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.drop([\u0027a\u0027])\nIndex([\u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.drop_duplicates", "label": "drop_duplicates", "shape": "dot", "size": 20, "title": "NAME: drop_duplicates\n------------------------------\nINPUTS: self, keep\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return Index with duplicate values removed. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, ``False``}, default \u0027first\u0027 - \u0027first\u0027 : Drop duplicates except for the first occurrence. - \u0027last\u0027 : Drop duplicates except for the last occurrence. - ``False`` : Drop all...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027lama\u0027, \u0027cow\u0027, \u0027lama\u0027, \u0027beetle\u0027, \u0027lama\u0027, \u0027hippo\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.droplevel", "label": "droplevel", "shape": "dot", "size": 20, "title": "NAME: droplevel\n------------------------------\nINPUTS: self, level\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return index with requested level(s) removed. If resulting index has only 1 level left, the result will be of Index type, not MultiIndex. The original index is not modified inplace. Parameters ---------- level : int, str, or list-like, default 0...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays(\n... [[1, 2], [3, 4], [5, 6]], names=[\u0027x\u0027, \u0027y\u0027, \u0027z\u0027])\n\u003e\u003e\u003e mi\nMultiIndex([(1, 3, 5),\n            (2, 4, 6)],\n           names=[\u0027x\u0027, \u0027y\u0027, \u0027z\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.dropna", "label": "dropna", "shape": "dot", "size": 20, "title": "NAME: dropna\n------------------------------\nINPUTS: self, how\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return Index without NA/NaN values. Parameters ---------- how : {\u0027any\u0027, \u0027all\u0027}, default \u0027any\u0027 If the Index is a MultiIndex, drop the value when any or all levels are NaN. Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([1, np.nan, 3])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, np.nan, 3])\n\u003e\u003e\u003e idx.dropna()\nIndex([1.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.duplicated", "label": "duplicated", "shape": "dot", "size": 20, "title": "NAME: duplicated\n------------------------------\nINPUTS: self, keep\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Indicate duplicate index values. Duplicated values are indicated as ``True`` values in the resulting array. Either all duplicates, all except the first, or all except the last occurrence of duplicates can be indicated. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, False},...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027lama\u0027, \u0027cow\u0027, \u0027lama\u0027, \u0027beetle\u0027, \u0027lama\u0027])\n\u003e\u003e\u003e idx.duplicated()\narray([False, False,  True, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.equals", "label": "equals", "shape": "dot", "size": 20, "title": "NAME: equals\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Determine if two Index object are equal. The things that are being compared are: * The elements inside the Index object. * The order of the elements inside the Index object. Parameters ---------- other : Any The other object to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx1\nIndex([1, 2, 3], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx1.equals(pd.Index([1, 2, 3]))\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.factorize", "label": "factorize", "shape": "dot", "size": 20, "title": "NAME: factorize\n------------------------------\nINPUTS: self, sort, use_na_sentinel\nOUTPUTS: tuple[npt.NDArray[np.intp], Index]\n------------------------------\nDESCRIPTION: Encode the object as an enumerated type or categorical variable. This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct values. `factorize` is available as both a top-level function :func:`pandas.factorize`, and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e codes, uniques = pd.factorize(np.array([\u0027b\u0027, \u0027b\u0027, \u0027a\u0027, \u0027c\u0027, \u0027b\u0027], dtype=\"O\"))\n\u003e\u003e\u003e codes\narray([0, 0, 1, 2, 0])\n\u003e\u003e\u003e uniques\narray([\u0027b\u0027, \u0027a\u0027, \u0027c\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.fillna", "label": "fillna", "shape": "dot", "size": 20, "title": "NAME: fillna\n------------------------------\nINPUTS: self, value, downcast\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Fill NA/NaN values with the specified value. Parameters ---------- value : scalar Scalar value to use to fill holes (e.g. 0). This value cannot be a list-likes. downcast : dict, default is None A dict of item-\u003edtype of what to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([np.nan, np.nan, 3])\n\u003e\u003e\u003e idx.fillna(0)\nIndex([0.0, 0.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.format", "label": "format", "shape": "dot", "size": 20, "title": "NAME: format\n------------------------------\nINPUTS: self, name, formatter, na_rep\nOUTPUTS: list[str_t]\n------------------------------\nDESCRIPTION: Render a string representation of the Index....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.get_indexer", "label": "get_indexer", "shape": "dot", "size": 20, "title": "NAME: get_indexer\n------------------------------\nINPUTS: self, target, method, limit, tolerance\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Compute indexer and mask for new index given the current index. The indexer should be then used as an input to ndarray.take to align the current data to the new index. Parameters ---------- target : Index method : {None, \u0027pad\u0027/\u0027ffill\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([\u0027c\u0027, \u0027a\u0027, \u0027b\u0027])\n\u003e\u003e\u003e index.get_indexer([\u0027a\u0027, \u0027b\u0027, \u0027x\u0027])\narray([ 1,  2, -1])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.get_indexer_for", "label": "get_indexer_for", "shape": "dot", "size": 20, "title": "NAME: get_indexer_for\n------------------------------\nINPUTS: self, target\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Guaranteed return of an indexer even when non-unique. This dispatches to get_indexer or get_indexer_non_unique as appropriate. Returns ------- np.ndarray[np.intp] List of indices. Examples -------- \u003e\u003e\u003e idx = pd.Index([np.nan, \u0027var1\u0027, np.nan]) \u003e\u003e\u003e idx.get_indexer_for([np.nan]) array([0, 2])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([np.nan, \u0027var1\u0027, np.nan])\n\u003e\u003e\u003e idx.get_indexer_for([np.nan])\narray([0, 2])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.get_indexer_non_unique", "label": "get_indexer_non_unique", "shape": "dot", "size": 20, "title": "NAME: get_indexer_non_unique\n------------------------------\nINPUTS: self, target\nOUTPUTS: tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]\n------------------------------\nDESCRIPTION: Compute indexer and mask for new index given the current index. The indexer should be then used as an input to ndarray.take to align the current data to the new index. Parameters ---------- target : Index Returns ------- indexer :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([\u0027c\u0027, \u0027b\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027])\n\u003e\u003e\u003e index.get_indexer_non_unique([\u0027b\u0027, \u0027b\u0027])\n(array([1, 3, 4, 1, 3, 4]), array([], dtype=int64))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.get_level_values", "label": "get_level_values", "shape": "dot", "size": 20, "title": "NAME: get_level_values\n------------------------------\nINPUTS: self, level\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Return an Index of values for requested level. This is primarily useful to get an individual level of values from a MultiIndex, but is provided on Index as well for compatibility. Parameters ---------- level : int or str It is...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abc\u0027))\n\u003e\u003e\u003e idx\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.get_loc", "label": "get_loc", "shape": "dot", "size": 20, "title": "NAME: get_loc\n------------------------------\nINPUTS: self, key\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Get integer location, slice or boolean mask for requested label. Parameters ---------- key : label Returns ------- int if unique index, slice if monotonic index, else mask Examples -------- \u003e\u003e\u003e unique_index = pd.Index(list(\u0027abc\u0027)) \u003e\u003e\u003e unique_index.get_loc(\u0027b\u0027) 1 \u003e\u003e\u003e monotonic_index = pd.Index(list(\u0027abbc\u0027))...\n\n\nEXAMPLE:\n\u003e\u003e\u003e unique_index = pd.Index(list(\u0027abc\u0027))\n\u003e\u003e\u003e unique_index.get_loc(\u0027b\u0027)\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.get_slice_bound", "label": "get_slice_bound", "shape": "dot", "size": 20, "title": "NAME: get_slice_bound\n------------------------------\nINPUTS: self, label, side\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Calculate slice bound that corresponds to given label. Returns leftmost (one-past-the-rightmost if ``side==\u0027right\u0027``) position of given label. Parameters ---------- label : object side : {\u0027left\u0027, \u0027right\u0027} Returns ------- int Index of label. See Also -------- Index.get_loc : Get integer location,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.RangeIndex(5)\n\u003e\u003e\u003e idx.get_slice_bound(3, \u0027left\u0027)\n3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.groupby", "label": "groupby", "shape": "dot", "size": 20, "title": "NAME: groupby\n------------------------------\nINPUTS: self, values\nOUTPUTS: PrettyDict[Hashable, np.ndarray]\n------------------------------\nDESCRIPTION: Group the index labels by a given array of values. Parameters ---------- values : array Values used to determine the groups. Returns ------- dict {group name -\u003e group labels}...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.holds_integer", "label": "holds_integer", "shape": "dot", "size": 20, "title": "NAME: holds_integer\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Whether the type is an integer type. .. deprecated:: 2.0.0 Use `pandas.api.types.infer_dtype` instead...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.identical", "label": "identical", "shape": "dot", "size": 20, "title": "NAME: identical\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Similar to equals, but checks that object attributes and types are also equal. Returns ------- bool If two Index objects have equal elements and same type True, otherwise False. Examples -------- \u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027]) \u003e\u003e\u003e idx2 =...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx2 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx2.identical(idx1)\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.infer_objects", "label": "infer_objects", "shape": "dot", "size": 20, "title": "NAME: infer_objects\n------------------------------\nINPUTS: self, copy\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: If we have an object dtype, try to infer a non-object dtype. Parameters ---------- copy : bool, default True Whether to make a copy in cases where no inference occurs....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.insert", "label": "insert", "shape": "dot", "size": 20, "title": "NAME: insert\n------------------------------\nINPUTS: self, loc, item\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Make new Index inserting new item at location. Follows Python numpy.insert semantics for negative values. Parameters ---------- loc : int item : object Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e idx.insert(1, \u0027x\u0027) Index([\u0027a\u0027, \u0027x\u0027, \u0027b\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.insert(1, \u0027x\u0027)\nIndex([\u0027a\u0027, \u0027x\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.intersection", "label": "intersection", "shape": "dot", "size": 20, "title": "NAME: intersection\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Form the intersection of two Index objects. This returns a new Index with elements common to the index and `other`. Parameters ---------- other : Index or array-like sort : True, False or None, default False Whether to sort the resulting...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.intersection(idx2)\nIndex([3, 4], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.is_", "label": "is_", "shape": "dot", "size": 20, "title": "NAME: is_\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: More flexible, faster check like ``is`` but that works through views. Note: this is *not* the same as ``Index.identical()``, which checks that metadata is also the same. Parameters ---------- other : object Other object to compare against. Returns ------- bool...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx1.is_(idx1.view())\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.is_boolean", "label": "is_boolean", "shape": "dot", "size": 20, "title": "NAME: is_boolean\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of booleans. .. deprecated:: 2.0.0 Use `pandas.api.types.is_bool_dtype` instead. Returns ------- bool Whether or not the Index only consists of booleans. See Also -------- is_integer : Check if the Index only consists of integers (deprecated)....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([True, False, True])\n\u003e\u003e\u003e idx.is_boolean()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.is_categorical", "label": "is_categorical", "shape": "dot", "size": 20, "title": "NAME: is_categorical\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index holds categorical data. .. deprecated:: 2.0.0 Use `isinstance(index.dtype, pd.CategoricalDtype)` instead. Returns ------- bool True if the Index is categorical. See Also -------- CategoricalIndex : Index for categorical data. is_boolean : Check if the Index only consists...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n...                 \"Watermelon\"]).astype(\"category\")\n\u003e\u003e\u003e idx.is_categorical()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.is_floating", "label": "is_floating", "shape": "dot", "size": 20, "title": "NAME: is_floating\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index is a floating type. .. deprecated:: 2.0.0 Use `pandas.api.types.is_float_dtype` instead The Index may consist of only floats, NaNs, or a mix of floats, integers, or NaNs. Returns ------- bool Whether or not the Index only consists...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n\u003e\u003e\u003e idx.is_floating()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.is_integer", "label": "is_integer", "shape": "dot", "size": 20, "title": "NAME: is_integer\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of integers. .. deprecated:: 2.0.0 Use `pandas.api.types.is_integer_dtype` instead. Returns ------- bool Whether or not the Index only consists of integers. See Also -------- is_boolean : Check if the Index only consists of booleans (deprecated)....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx.is_integer()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.is_interval", "label": "is_interval", "shape": "dot", "size": 20, "title": "NAME: is_interval\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index holds Interval objects. .. deprecated:: 2.0.0 Use `isinstance(index.dtype, pd.IntervalDtype)` instead. Returns ------- bool Whether or not the Index holds Interval objects. See Also -------- IntervalIndex : Index for Interval objects. is_boolean : Check if the Index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([pd.Interval(left=0, right=5),\n...                 pd.Interval(left=5, right=10)])\n\u003e\u003e\u003e idx.is_interval()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.is_numeric", "label": "is_numeric", "shape": "dot", "size": 20, "title": "NAME: is_numeric\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of numeric data. .. deprecated:: 2.0.0 Use `pandas.api.types.is_numeric_dtype` instead. Returns ------- bool Whether or not the Index only consists of numeric data. See Also -------- is_boolean : Check if the Index only consists of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n\u003e\u003e\u003e idx.is_numeric()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.is_object", "label": "is_object", "shape": "dot", "size": 20, "title": "NAME: is_object\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index is of the object dtype. .. deprecated:: 2.0.0 Use `pandas.api.types.is_object_dtype` instead. Returns ------- bool Whether or not the Index is of the object dtype. See Also -------- is_boolean : Check if the Index only consists of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\"Apple\", \"Mango\", \"Watermelon\"])\n\u003e\u003e\u003e idx.is_object()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.isin", "label": "isin", "shape": "dot", "size": 20, "title": "NAME: isin\n------------------------------\nINPUTS: self, values, level\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Return a boolean array where the index values are in `values`. Compute boolean array of whether each index value is found in the passed set of values. The length of the returned boolean array matches the length of the index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1,2,3])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.isna", "label": "isna", "shape": "dot", "size": 20, "title": "NAME: isna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get mapped to ``True`` values. Everything else get mapped to ``False`` values. Characters such as empty strings `\u0027\u0027`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.isna()\narray([False, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.isnull", "label": "isnull", "shape": "dot", "size": 20, "title": "NAME: isnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get mapped to ``True`` values. Everything else get mapped to ``False`` values. Characters such as empty strings `\u0027\u0027`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.isna()\narray([False, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.item", "label": "item", "shape": "dot", "size": 20, "title": "NAME: item\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the first element of the underlying data as a Python scalar. Returns ------- scalar The first element of Series or Index. Raises ------ ValueError If the data is not length = 1. Examples -------- \u003e\u003e\u003e s = pd.Series([1]) \u003e\u003e\u003e...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1])\n\u003e\u003e\u003e s.item()\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.join", "label": "join", "shape": "dot", "size": 20, "title": "NAME: join\n------------------------------\nINPUTS: self, other, how, level, return_indexers, sort\nOUTPUTS: Index | tuple[Index, npt.NDArray[np.intp] | None, npt.NDArray[np.intp] | None]\n------------------------------\nDESCRIPTION: Compute join_index and indexers to conform data structures to the new index. Parameters ---------- other : Index how : {\u0027left\u0027, \u0027right\u0027, \u0027inner\u0027, \u0027outer\u0027} level : int or level name, default None return_indexers : bool, default False sort : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx2 = pd.Index([4, 5, 6])\n\u003e\u003e\u003e idx1.join(idx2, how=\u0027outer\u0027)\nIndex([1, 2, 3, 4, 5, 6], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.map", "label": "map", "shape": "dot", "size": 20, "title": "NAME: map\n------------------------------\nINPUTS: self, mapper, na_action\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Map values using an input mapping or function. Parameters ---------- mapper : function, dict, or Series Mapping correspondence. na_action : {None, \u0027ignore\u0027} If \u0027ignore\u0027, propagate NA values, without passing them to the mapping correspondence. Returns ------- Union[Index, MultiIndex] The output...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.map({1: \u0027a\u0027, 2: \u0027b\u0027, 3: \u0027c\u0027})\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.max", "label": "max", "shape": "dot", "size": 20, "title": "NAME: max\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the maximum value of the Index. Parameters ---------- axis : int, optional For compatibility with NumPy. Only 0 or None are allowed. skipna : bool, default True Exclude NA/null values when showing the result. *args, **kwargs Additional arguments and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([3, 2, 1])\n\u003e\u003e\u003e idx.max()\n3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.memory_usage", "label": "memory_usage", "shape": "dot", "size": 20, "title": "NAME: memory_usage\n------------------------------\nINPUTS: self, deep\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Memory usage of the values. Parameters ---------- deep : bool, default False Introspect the data deeply, interrogate `object` dtypes for system-level memory consumption. Returns ------- bytes used See Also -------- numpy.ndarray.nbytes : Total bytes consumed by the elements of the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.memory_usage()\n24"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.min", "label": "min", "shape": "dot", "size": 20, "title": "NAME: min\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the minimum value of the Index. Parameters ---------- axis : {None} Dummy argument for consistency with Series. skipna : bool, default True Exclude NA/null values when showing the result. *args, **kwargs Additional arguments and keywords for compatibility with NumPy....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([3, 2, 1])\n\u003e\u003e\u003e idx.min()\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.notna", "label": "notna", "shape": "dot", "size": 20, "title": "NAME: notna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to ``True``. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values. NA values, such as None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.notna()\narray([ True,  True, False])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.notnull", "label": "notnull", "shape": "dot", "size": 20, "title": "NAME: notnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to ``True``. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values. NA values, such as None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.notna()\narray([ True,  True, False])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.nunique", "label": "nunique", "shape": "dot", "size": 20, "title": "NAME: nunique\n------------------------------\nINPUTS: self, dropna\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return number of unique elements in the object. Excludes NA values by default. Parameters ---------- dropna : bool, default True Don\u0027t include NaN in the count. Returns ------- int See Also -------- DataFrame.nunique: Method nunique for DataFrame. Series.count: Count non-NA/null...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 3, 5, 7, 7])\n\u003e\u003e\u003e s\n0    1\n1    3\n2    5\n3    7\n4    7\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.putmask", "label": "putmask", "shape": "dot", "size": 20, "title": "NAME: putmask\n------------------------------\nINPUTS: self, mask, value\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Return a new Index of the values set with the mask. Returns ------- Index See Also -------- numpy.ndarray.putmask : Changes elements of an array based on conditional and input values. Examples -------- \u003e\u003e\u003e idx1 = pd.Index([1, 2, 3]) \u003e\u003e\u003e idx2...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx2 = pd.Index([5, 6, 7])\n\u003e\u003e\u003e idx1.putmask([True, False, False], idx2)\nIndex([5, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.ravel", "label": "ravel", "shape": "dot", "size": 20, "title": "NAME: ravel\n------------------------------\nINPUTS: self, order\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a view on self. Returns ------- Index See Also -------- numpy.ndarray.ravel : Return a flattened array. Examples -------- \u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e s.index.ravel() Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e s.index.ravel()\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.reindex", "label": "reindex", "shape": "dot", "size": 20, "title": "NAME: reindex\n------------------------------\nINPUTS: self, target, method, level, limit, tolerance\nOUTPUTS: tuple[Index, npt.NDArray[np.intp] | None]\n------------------------------\nDESCRIPTION: Create index with target\u0027s values. Parameters ---------- target : an iterable method : {None, \u0027pad\u0027/\u0027ffill\u0027, \u0027backfill\u0027/\u0027bfill\u0027, \u0027nearest\u0027}, optional * default: exact matches only. * pad / ffill: find the PREVIOUS index value if no exact match. * backfill / bfill:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.reindex([\u0027car\u0027, \u0027bike\u0027])\n(Index([\u0027car\u0027, \u0027bike\u0027], dtype=\u0027object\u0027), array([0, 1]))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.rename", "label": "rename", "shape": "dot", "size": 20, "title": "NAME: rename\n------------------------------\nINPUTS: self, name, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Alter Index or MultiIndex name. Able to set new names without level. Defaults to returning new index. Length of names must match number of levels in MultiIndex. Parameters ---------- name : label or list of labels Name(s) to set. inplace...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027A\u0027, \u0027C\u0027, \u0027A\u0027, \u0027B\u0027], name=\u0027score\u0027)\n\u003e\u003e\u003e idx.rename(\u0027grade\u0027)\nIndex([\u0027A\u0027, \u0027C\u0027, \u0027A\u0027, \u0027B\u0027], dtype=\u0027object\u0027, name=\u0027grade\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.repeat", "label": "repeat", "shape": "dot", "size": 20, "title": "NAME: repeat\n------------------------------\nINPUTS: self, repeats, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Repeat elements of a Index. Returns a new Index where each element of the current Index is repeated consecutively a given number of times. Parameters ---------- repeats : int or array of ints The number of repetitions for each element....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.repeat(2)\nIndex([\u0027a\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027c\u0027, \u0027c\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.repeat([1, 2, 3])\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027c\u0027, \u0027c\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.round", "label": "round", "shape": "dot", "size": 20, "title": "NAME: round\n------------------------------\nINPUTS: self, decimals\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Round each value in the Index to the given number of decimals. Parameters ---------- decimals : int, optional Number of decimal places to round to. If decimals is negative, it specifies the number of positions to the left of the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import pandas as pd\n\u003e\u003e\u003e idx = pd.Index([10.1234, 20.5678, 30.9123, 40.4567, 50.7890])\n\u003e\u003e\u003e idx.round(decimals=2)\nIndex([10.12, 20.57, 30.91, 40.46, 50.79], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.searchsorted", "label": "searchsorted", "shape": "dot", "size": 20, "title": "NAME: searchsorted\n------------------------------\nINPUTS: self, value, side, sorter\nOUTPUTS: npt.NDArray[np.intp] | np.intp\n------------------------------\nDESCRIPTION: Find indices where elements should be inserted to maintain order. Find the indices into a sorted Index `self` such that, if the corresponding elements in `value` were inserted before the indices, the order of `self` would be preserved. .. note::...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([1, 2, 3])\n\u003e\u003e\u003e ser\n0    1\n1    2\n2    3\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.set_names", "label": "set_names", "shape": "dot", "size": 20, "title": "NAME: set_names\n------------------------------\nINPUTS: self, names, level, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Set Index or MultiIndex name. Able to set new names partially and by level. Parameters ---------- names : label or list of label or dict-like for MultiIndex Name(s) to set. .. versionchanged:: 1.3.0 level : int, label or list of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx.set_names(\u0027quarter\u0027)\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027, name=\u0027quarter\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.shift", "label": "shift", "shape": "dot", "size": 20, "title": "NAME: shift\n------------------------------\nINPUTS: self, periods, freq\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Shift index by desired number of time frequency increments. This method is for shifting the values of datetime-like indexes by a specified time increment a given number of times. Parameters ---------- periods : int, default 1 Number of periods (or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e month_starts = pd.date_range(\u00271/1/2011\u0027, periods=5, freq=\u0027MS\u0027)\n\u003e\u003e\u003e month_starts\nDatetimeIndex([\u00272011-01-01\u0027, \u00272011-02-01\u0027, \u00272011-03-01\u0027, \u00272011-04-01\u0027,\n               \u00272011-05-01\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=\u0027MS\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.slice_indexer", "label": "slice_indexer", "shape": "dot", "size": 20, "title": "NAME: slice_indexer\n------------------------------\nINPUTS: self, start, end, step\nOUTPUTS: slice\n------------------------------\nDESCRIPTION: Compute the slice indexer for input labels and step. Index needs to be ordered and unique. Parameters ---------- start : label, default None If None, defaults to the beginning. end : label, default None If None, defaults to the end....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abcd\u0027))\n\u003e\u003e\u003e idx.slice_indexer(start=\u0027b\u0027, end=\u0027c\u0027)\nslice(1, 3, None)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.slice_locs", "label": "slice_locs", "shape": "dot", "size": 20, "title": "NAME: slice_locs\n------------------------------\nINPUTS: self, start, end, step\nOUTPUTS: tuple[int, int]\n------------------------------\nDESCRIPTION: Compute slice locations for input labels. Parameters ---------- start : label, default None If None, defaults to the beginning. end : label, default None If None, defaults to the end. step : int, defaults None If None, defaults to 1....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abcd\u0027))\n\u003e\u003e\u003e idx.slice_locs(start=\u0027b\u0027, end=\u0027c\u0027)\n(1, 3)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.sort", "label": "sort", "shape": "dot", "size": 20, "title": "NAME: sort\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Use sort_values instead....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.sort_values", "label": "sort_values", "shape": "dot", "size": 20, "title": "NAME: sort_values\n------------------------------\nINPUTS: self, return_indexer, ascending, na_position, key\nOUTPUTS: Self | tuple[Self, np.ndarray]\n------------------------------\nDESCRIPTION: Return a sorted copy of the index. Return a sorted copy of the index, and optionally return the indices that sorted the index itself. Parameters ---------- return_indexer : bool, default False Should the indices that would sort the index be...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([10, 100, 1, 1000])\n\u003e\u003e\u003e idx\nIndex([10, 100, 1, 1000], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.sortlevel", "label": "sortlevel", "shape": "dot", "size": 20, "title": "NAME: sortlevel\n------------------------------\nINPUTS: self, level, ascending, sort_remaining, na_position\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: For internal compatibility with the Index API. Sort the Index. This is for compat with MultiIndex Parameters ---------- ascending : bool, default True False to sort in descending order na_position : {\u0027first\u0027 or \u0027last\u0027}, default \u0027first\u0027 Argument \u0027first\u0027 puts NaNs...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Index.str", "label": "str", "shape": "dot", "size": 20, "title": "NAME: str\n------------------------------\nINPUTS: data\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Vectorized string functions for Series and Index. NAs stay NA unless handled otherwise by a particular method. Patterned after Python\u0027s string methods, with some inspiration from R\u0027s stringr package. Examples -------- \u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"]) \u003e\u003e\u003e s 0 A_Str_Series dtype:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"])\n\u003e\u003e\u003e s\n0    A_Str_Series\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.symmetric_difference", "label": "symmetric_difference", "shape": "dot", "size": 20, "title": "NAME: symmetric_difference\n------------------------------\nINPUTS: self, other, result_name, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Compute the symmetric difference of two Index objects. Parameters ---------- other : Index or array-like result_name : str sort : bool or None, default None Whether to sort the resulting index. By default, the values are attempted to be sorted,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([2, 3, 4, 5])\n\u003e\u003e\u003e idx1.symmetric_difference(idx2)\nIndex([1, 5], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.take", "label": "take", "shape": "dot", "size": 20, "title": "NAME: take\n------------------------------\nINPUTS: self, indices, axis, allow_fill, fill_value, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a new Index of the values selected by the indices. For internal compatibility with numpy arrays. Parameters ---------- indices : array-like Indices to be taken. axis : int, optional The axis over which to select values, always 0. allow_fill...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.take([2, 2, 1, 2])\nIndex([\u0027c\u0027, \u0027c\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.to_flat_index", "label": "to_flat_index", "shape": "dot", "size": 20, "title": "NAME: to_flat_index\n------------------------------\nINPUTS: self\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Identity method. This is implemented for compatibility with subclass implementations when chaining. Returns ------- pd.Index Caller. See Also -------- MultiIndex.to_flat_index : Subclass implementation....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.to_frame", "label": "to_frame", "shape": "dot", "size": 20, "title": "NAME: to_frame\n------------------------------\nINPUTS: self, index, name\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Create a DataFrame with a column containing the Index. Parameters ---------- index : bool, default True Set the index of the returned DataFrame as the original Index. name : object, defaults to index.name The passed name should substitute for the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027Ant\u0027, \u0027Bear\u0027, \u0027Cow\u0027], name=\u0027animal\u0027)\n\u003e\u003e\u003e idx.to_frame()\n       animal\nanimal\nAnt       Ant\nBear     Bear\nCow       Cow"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.to_list", "label": "to_list", "shape": "dot", "size": 20, "title": "NAME: to_list\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list See Also -------- numpy.ndarray.tolist : Return the array as an...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.to_list()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.to_numpy", "label": "to_numpy", "shape": "dot", "size": 20, "title": "NAME: to_numpy\n------------------------------\nINPUTS: self, dtype, copy, na_value, kwargs\nOUTPUTS: np.ndarray\n------------------------------\nDESCRIPTION: A NumPy ndarray representing the values in this Series or Index. Parameters ---------- dtype : str or numpy.dtype, optional The dtype to pass to :meth:`numpy.asarray`. copy : bool, default False Whether to ensure that the returned value is not a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series(pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027]))\n\u003e\u003e\u003e ser.to_numpy()\narray([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.to_series", "label": "to_series", "shape": "dot", "size": 20, "title": "NAME: to_series\n------------------------------\nINPUTS: self, index, name\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Create a Series with both index and values equal to the index keys. Useful with map for returning an indexer based on an index. Parameters ---------- index : Index, optional Index of resulting Series. If None, defaults to original index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027Ant\u0027, \u0027Bear\u0027, \u0027Cow\u0027], name=\u0027animal\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.tolist", "label": "tolist", "shape": "dot", "size": 20, "title": "NAME: tolist\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list See Also -------- numpy.ndarray.tolist : Return the array as an...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.to_list()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.transpose", "label": "transpose", "shape": "dot", "size": 20, "title": "NAME: transpose\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return the transpose, which is by definition self. Returns ------- %(klass)s...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.union", "label": "union", "shape": "dot", "size": 20, "title": "NAME: union\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Form the union of two Index objects. If the Index objects are incompatible, both Index objects will be cast to dtype(\u0027object\u0027) first. Parameters ---------- other : Index or array-like sort : bool or None, default None Whether to sort the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.union(idx2)\nIndex([1, 2, 3, 4, 5, 6], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.unique", "label": "unique", "shape": "dot", "size": 20, "title": "NAME: unique\n------------------------------\nINPUTS: self, level\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return unique values in the index. Unique values are returned in order of appearance, this does NOT sort. Parameters ---------- level : int or hashable, optional Only return values from specified level (for MultiIndex). If int, gets the level by...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 1, 2, 3, 3])\n\u003e\u003e\u003e idx.unique()\nIndex([1, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.value_counts", "label": "value_counts", "shape": "dot", "size": 20, "title": "NAME: value_counts\n------------------------------\nINPUTS: self, normalize, sort, ascending, bins, dropna\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return a Series containing counts of unique values. The resulting object will be in descending order so that the first element is the most frequently-occurring element. Excludes NA values by default. Parameters ---------- normalize : bool, default False If True...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([3, 1, 2, 3, 4, np.nan])\n\u003e\u003e\u003e index.value_counts()\n3.0    2\n1.0    1\n2.0    1\n4.0    1\nName: count, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.view", "label": "view", "shape": "dot", "size": 20, "title": "NAME: view\n------------------------------\nINPUTS: self, cls\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Index.where", "label": "where", "shape": "dot", "size": 20, "title": "NAME: where\n------------------------------\nINPUTS: self, cond, other\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Replace values where the condition is False. The replacement is taken from other. Parameters ---------- cond : bool array-like with the same length as self Condition to select the values on. other : scalar, or array-like, default None Replacement if...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.where(idx.isin([\u0027car\u0027, \u0027train\u0027]), \u0027other\u0027)\nIndex([\u0027car\u0027, \u0027other\u0027, \u0027train\u0027, \u0027other\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int16Dtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: \nOUTPUTS: type[IntegerArray]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int16Dtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Construct this type from a string. This is useful mainly for data types that accept parameters. For example, a period dtype accepts a frequency parameter that can be set as ``period[h]`` (where H means hourly frequency). By default, in the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import re\n\u003e\u003e\u003e @classmethod\n... def construct_from_string(cls, string):\n...     pattern = re.compile(r\"^my_type\\[(?P\u003carg_name\u003e.+)\\]$\")\n...     match = pattern.match(string)\n...     if match:\n...         return cls(**match.groupdict())\n...     else:\n...         raise TypeError(\n...             f\"Cannot construct a \u0027{cls.__name__}\u0027 from \u0027{string}\u0027\"\n...         )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int16Dtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int16Dtype.from_numpy_dtype", "label": "from_numpy_dtype", "shape": "dot", "size": 20, "title": "NAME: from_numpy_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: BaseMaskedDtype\n------------------------------\nDESCRIPTION: Construct the MaskedDtype corresponding to the given numpy dtype....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int16Dtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if we match \u0027dtype\u0027. Parameters ---------- dtype : object The object to check. Returns ------- bool Notes ----- The default implementation is True if 1. ``cls.construct_from_string(dtype)`` is an instance of ``cls``. 2. ``dtype`` is an object and is an...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Int16Dtype.type", "label": "type", "shape": "dot", "size": 20, "title": "NAME: type\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Signed integer type, compatible with C ``short``. :Character code: ``\u0027h\u0027`` :Canonical name: `numpy.short` :Alias on this platform (win32 AMD64): `numpy.int16`: 16-bit signed integer (``-32_768`` to ``32_767``)....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int32Dtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: \nOUTPUTS: type[IntegerArray]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int32Dtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Construct this type from a string. This is useful mainly for data types that accept parameters. For example, a period dtype accepts a frequency parameter that can be set as ``period[h]`` (where H means hourly frequency). By default, in the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import re\n\u003e\u003e\u003e @classmethod\n... def construct_from_string(cls, string):\n...     pattern = re.compile(r\"^my_type\\[(?P\u003carg_name\u003e.+)\\]$\")\n...     match = pattern.match(string)\n...     if match:\n...         return cls(**match.groupdict())\n...     else:\n...         raise TypeError(\n...             f\"Cannot construct a \u0027{cls.__name__}\u0027 from \u0027{string}\u0027\"\n...         )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int32Dtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int32Dtype.from_numpy_dtype", "label": "from_numpy_dtype", "shape": "dot", "size": 20, "title": "NAME: from_numpy_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: BaseMaskedDtype\n------------------------------\nDESCRIPTION: Construct the MaskedDtype corresponding to the given numpy dtype....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int32Dtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if we match \u0027dtype\u0027. Parameters ---------- dtype : object The object to check. Returns ------- bool Notes ----- The default implementation is True if 1. ``cls.construct_from_string(dtype)`` is an instance of ``cls``. 2. ``dtype`` is an object and is an...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Int32Dtype.type", "label": "type", "shape": "dot", "size": 20, "title": "NAME: type\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Signed integer type, compatible with Python `int` and C ``long``. :Character code: ``\u0027l\u0027`` :Canonical name: `numpy.int_` :Alias on this platform (win32 AMD64): `numpy.int32`: 32-bit signed integer (``-2_147_483_648`` to ``2_147_483_647``)....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int64Dtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: \nOUTPUTS: type[IntegerArray]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int64Dtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Construct this type from a string. This is useful mainly for data types that accept parameters. For example, a period dtype accepts a frequency parameter that can be set as ``period[h]`` (where H means hourly frequency). By default, in the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import re\n\u003e\u003e\u003e @classmethod\n... def construct_from_string(cls, string):\n...     pattern = re.compile(r\"^my_type\\[(?P\u003carg_name\u003e.+)\\]$\")\n...     match = pattern.match(string)\n...     if match:\n...         return cls(**match.groupdict())\n...     else:\n...         raise TypeError(\n...             f\"Cannot construct a \u0027{cls.__name__}\u0027 from \u0027{string}\u0027\"\n...         )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int64Dtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int64Dtype.from_numpy_dtype", "label": "from_numpy_dtype", "shape": "dot", "size": 20, "title": "NAME: from_numpy_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: BaseMaskedDtype\n------------------------------\nDESCRIPTION: Construct the MaskedDtype corresponding to the given numpy dtype....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int64Dtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if we match \u0027dtype\u0027. Parameters ---------- dtype : object The object to check. Returns ------- bool Notes ----- The default implementation is True if 1. ``cls.construct_from_string(dtype)`` is an instance of ``cls``. 2. ``dtype`` is an object and is an...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Int64Dtype.type", "label": "type", "shape": "dot", "size": 20, "title": "NAME: type\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Signed integer type, compatible with C ``long long``. :Character code: ``\u0027q\u0027`` :Canonical name: `numpy.longlong` :Alias on this platform (win32 AMD64): `numpy.int64`: 64-bit signed integer (``-9_223_372_036_854_775_808`` to ``9_223_372_036_854_775_807``). :Alias on this platform (win32 AMD64): `numpy.intp`: Signed integer large enough to fit...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int8Dtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: \nOUTPUTS: type[IntegerArray]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int8Dtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Construct this type from a string. This is useful mainly for data types that accept parameters. For example, a period dtype accepts a frequency parameter that can be set as ``period[h]`` (where H means hourly frequency). By default, in the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import re\n\u003e\u003e\u003e @classmethod\n... def construct_from_string(cls, string):\n...     pattern = re.compile(r\"^my_type\\[(?P\u003carg_name\u003e.+)\\]$\")\n...     match = pattern.match(string)\n...     if match:\n...         return cls(**match.groupdict())\n...     else:\n...         raise TypeError(\n...             f\"Cannot construct a \u0027{cls.__name__}\u0027 from \u0027{string}\u0027\"\n...         )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int8Dtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int8Dtype.from_numpy_dtype", "label": "from_numpy_dtype", "shape": "dot", "size": 20, "title": "NAME: from_numpy_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: BaseMaskedDtype\n------------------------------\nDESCRIPTION: Construct the MaskedDtype corresponding to the given numpy dtype....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Int8Dtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if we match \u0027dtype\u0027. Parameters ---------- dtype : object The object to check. Returns ------- bool Notes ----- The default implementation is True if 1. ``cls.construct_from_string(dtype)`` is an instance of ``cls``. 2. ``dtype`` is an object and is an...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Int8Dtype.type", "label": "type", "shape": "dot", "size": 20, "title": "NAME: type\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Signed integer type, compatible with C ``char``. :Character code: ``\u0027b\u0027`` :Canonical name: `numpy.byte` :Alias on this platform (win32 AMD64): `numpy.int8`: 8-bit signed integer (``-128`` to ``127``)....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalDtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: \nOUTPUTS: type[IntervalArray]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalDtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: IntervalDtype\n------------------------------\nDESCRIPTION: attempt to construct this type from a string, raise a TypeError if its not possible...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalDtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalDtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Return a boolean if we if the passed type is an actual dtype that we can match (via string or type)...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalDtype.reset_cache", "label": "reset_cache", "shape": "dot", "size": 20, "title": "NAME: reset_cache\n------------------------------\nINPUTS: \nOUTPUTS: None\n------------------------------\nDESCRIPTION: clear the cache...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.all", "label": "all", "shape": "dot", "size": 20, "title": "NAME: all\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return whether all elements are Truthy. Parameters ---------- *args Required for compatibility with numpy. **kwargs Required for compatibility with numpy. Returns ------- bool or array-like (if axis is specified) A single element array-like may be converted to bool. See Also...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Index([1, 2, 3]).all()\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.any", "label": "any", "shape": "dot", "size": 20, "title": "NAME: any\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return whether any element is Truthy. Parameters ---------- *args Required for compatibility with numpy. **kwargs Required for compatibility with numpy. Returns ------- bool or array-like (if axis is specified) A single element array-like may be converted to bool. See Also...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([0, 1, 2])\n\u003e\u003e\u003e index.any()\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.append", "label": "append", "shape": "dot", "size": 20, "title": "NAME: append\n------------------------------\nINPUTS: self, other\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Append a collection of Index options together. Parameters ---------- other : Index or list/tuple of indices Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([1, 2, 3]) \u003e\u003e\u003e idx.append(pd.Index([4])) Index([1, 2, 3, 4], dtype=\u0027int64\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.append(pd.Index([4]))\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.argmax", "label": "argmax", "shape": "dot", "size": 20, "title": "NAME: argmax\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the largest value in the Series. If the maximum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.argmin", "label": "argmin", "shape": "dot", "size": 20, "title": "NAME: argmin\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the smallest value in the Series. If the minimum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.argsort", "label": "argsort", "shape": "dot", "size": 20, "title": "NAME: argsort\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Return the integer indices that would sort the index. Parameters ---------- *args Passed to `numpy.ndarray.argsort`. **kwargs Passed to `numpy.ndarray.argsort`. Returns ------- np.ndarray[np.intp] Integer indices that would sort the index if used as an indexer. See Also -------- numpy.argsort : Similar...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027b\u0027, \u0027a\u0027, \u0027d\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027b\u0027, \u0027a\u0027, \u0027d\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.asof", "label": "asof", "shape": "dot", "size": 20, "title": "NAME: asof\n------------------------------\nINPUTS: self, label\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the label from the index, or, if not present, the previous one. Assuming that the index is sorted, return the passed index label if it is in the index, or return the previous index label if the passed one...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u00272013-12-31\u0027, \u00272014-01-02\u0027, \u00272014-01-03\u0027])\n\u003e\u003e\u003e idx.asof(\u00272014-01-01\u0027)\n\u00272013-12-31\u0027"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.asof_locs", "label": "asof_locs", "shape": "dot", "size": 20, "title": "NAME: asof_locs\n------------------------------\nINPUTS: self, where, mask\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Return the locations (indices) of labels in the index. As in the :meth:`pandas.Index.asof`, if the label (a particular entry in ``where``) is not in the index, the latest index label up to the passed label is chosen and its index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.date_range(\u00272023-06-01\u0027, periods=3, freq=\u0027D\u0027)\n\u003e\u003e\u003e where = pd.DatetimeIndex([\u00272023-05-30 00:12:00\u0027, \u00272023-06-01 00:00:00\u0027,\n...                           \u00272023-06-02 23:59:59\u0027])\n\u003e\u003e\u003e mask = np.ones(3, dtype=bool)\n\u003e\u003e\u003e idx.asof_locs(where, mask)\narray([-1,  0,  1])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.astype", "label": "astype", "shape": "dot", "size": 20, "title": "NAME: astype\n------------------------------\nINPUTS: self, dtype, copy\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Create an Index with values cast to dtypes. The class of a new Index is determined by dtype. When conversion is impossible, a TypeError exception is raised. Parameters ---------- dtype : numpy dtype or pandas type Note that any signed...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx.astype(\u0027float\u0027)\nIndex([1.0, 2.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.contains", "label": "contains", "shape": "dot", "size": 20, "title": "NAME: contains\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Check elementwise if the Intervals contain the value. Return a boolean mask whether the value is contained in the Intervals of the IntervalArray. Parameters ---------- other : scalar The value to check whether it is contained in the Intervals. Returns...\n\n\nEXAMPLE:\n\u003e\u003e\u003e intervals = pd.arrays.IntervalArray.from_tuples([(0, 1), (1, 3), (2, 4)])\n\u003e\u003e\u003e intervals\n\u003cIntervalArray\u003e\n[(0, 1], (1, 3], (2, 4]]\nLength: 3, dtype: interval[int64, right]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.copy", "label": "copy", "shape": "dot", "size": 20, "title": "NAME: copy\n------------------------------\nINPUTS: self, name, deep\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make a copy of this object. Name is set on the new object. Parameters ---------- name : Label, optional Set name for new object. deep : bool, default False Returns ------- Index Index refer to new object which is a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e new_idx = idx.copy()\n\u003e\u003e\u003e idx is new_idx\nFalse"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.delete", "label": "delete", "shape": "dot", "size": 20, "title": "NAME: delete\n------------------------------\nINPUTS: self, loc\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make new Index with passed location(-s) deleted. Parameters ---------- loc : int or list of int Location of item(-s) which will be deleted. Use a list of locations to delete more than one value at the same time. Returns -------...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.delete(1)\nIndex([\u0027a\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.diff", "label": "diff", "shape": "dot", "size": 20, "title": "NAME: diff\n------------------------------\nINPUTS: self, periods\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Computes the difference between consecutive values in the Index object. If periods is greater than 1, computes the difference between values that are `periods` number of positions apart. Parameters ---------- periods : int, optional The number of positions between the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import pandas as pd\n\u003e\u003e\u003e idx = pd.Index([10, 20, 30, 40, 50])\n\u003e\u003e\u003e idx.diff()\nIndex([nan, 10.0, 10.0, 10.0, 10.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.difference", "label": "difference", "shape": "dot", "size": 20, "title": "NAME: difference\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a new Index with elements of index not in `other`. This is the set difference of two Index objects. Parameters ---------- other : Index or array-like sort : bool or None, default None Whether to sort the resulting index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([2, 1, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.difference(idx2)\nIndex([1, 2], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx1.difference(idx2, sort=False)\nIndex([2, 1], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.drop", "label": "drop", "shape": "dot", "size": 20, "title": "NAME: drop\n------------------------------\nINPUTS: self, labels, errors\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Make new Index with passed list of labels deleted. Parameters ---------- labels : array-like or scalar errors : {\u0027ignore\u0027, \u0027raise\u0027}, default \u0027raise\u0027 If \u0027ignore\u0027, suppress error and existing labels are dropped. Returns ------- Index Will be same type as self,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.drop([\u0027a\u0027])\nIndex([\u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.drop_duplicates", "label": "drop_duplicates", "shape": "dot", "size": 20, "title": "NAME: drop_duplicates\n------------------------------\nINPUTS: self, keep\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return Index with duplicate values removed. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, ``False``}, default \u0027first\u0027 - \u0027first\u0027 : Drop duplicates except for the first occurrence. - \u0027last\u0027 : Drop duplicates except for the last occurrence. - ``False`` : Drop all...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027lama\u0027, \u0027cow\u0027, \u0027lama\u0027, \u0027beetle\u0027, \u0027lama\u0027, \u0027hippo\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.droplevel", "label": "droplevel", "shape": "dot", "size": 20, "title": "NAME: droplevel\n------------------------------\nINPUTS: self, level\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return index with requested level(s) removed. If resulting index has only 1 level left, the result will be of Index type, not MultiIndex. The original index is not modified inplace. Parameters ---------- level : int, str, or list-like, default 0...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays(\n... [[1, 2], [3, 4], [5, 6]], names=[\u0027x\u0027, \u0027y\u0027, \u0027z\u0027])\n\u003e\u003e\u003e mi\nMultiIndex([(1, 3, 5),\n            (2, 4, 6)],\n           names=[\u0027x\u0027, \u0027y\u0027, \u0027z\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.dropna", "label": "dropna", "shape": "dot", "size": 20, "title": "NAME: dropna\n------------------------------\nINPUTS: self, how\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return Index without NA/NaN values. Parameters ---------- how : {\u0027any\u0027, \u0027all\u0027}, default \u0027any\u0027 If the Index is a MultiIndex, drop the value when any or all levels are NaN. Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([1, np.nan, 3])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, np.nan, 3])\n\u003e\u003e\u003e idx.dropna()\nIndex([1.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.duplicated", "label": "duplicated", "shape": "dot", "size": 20, "title": "NAME: duplicated\n------------------------------\nINPUTS: self, keep\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Indicate duplicate index values. Duplicated values are indicated as ``True`` values in the resulting array. Either all duplicates, all except the first, or all except the last occurrence of duplicates can be indicated. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, False},...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027lama\u0027, \u0027cow\u0027, \u0027lama\u0027, \u0027beetle\u0027, \u0027lama\u0027])\n\u003e\u003e\u003e idx.duplicated()\narray([False, False,  True, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.equals", "label": "equals", "shape": "dot", "size": 20, "title": "NAME: equals\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Determine if two Index object are equal. The things that are being compared are: * The elements inside the Index object. * The order of the elements inside the Index object. Parameters ---------- other : Any The other object to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx1\nIndex([1, 2, 3], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx1.equals(pd.Index([1, 2, 3]))\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.factorize", "label": "factorize", "shape": "dot", "size": 20, "title": "NAME: factorize\n------------------------------\nINPUTS: self, sort, use_na_sentinel\nOUTPUTS: tuple[npt.NDArray[np.intp], Index]\n------------------------------\nDESCRIPTION: Encode the object as an enumerated type or categorical variable. This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct values. `factorize` is available as both a top-level function :func:`pandas.factorize`, and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e codes, uniques = pd.factorize(np.array([\u0027b\u0027, \u0027b\u0027, \u0027a\u0027, \u0027c\u0027, \u0027b\u0027], dtype=\"O\"))\n\u003e\u003e\u003e codes\narray([0, 0, 1, 2, 0])\n\u003e\u003e\u003e uniques\narray([\u0027b\u0027, \u0027a\u0027, \u0027c\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.fillna", "label": "fillna", "shape": "dot", "size": 20, "title": "NAME: fillna\n------------------------------\nINPUTS: self, value, downcast\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Fill NA/NaN values with the specified value. Parameters ---------- value : scalar Scalar value to use to fill holes (e.g. 0). This value cannot be a list-likes. downcast : dict, default is None A dict of item-\u003edtype of what to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([np.nan, np.nan, 3])\n\u003e\u003e\u003e idx.fillna(0)\nIndex([0.0, 0.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.format", "label": "format", "shape": "dot", "size": 20, "title": "NAME: format\n------------------------------\nINPUTS: self, name, formatter, na_rep\nOUTPUTS: list[str_t]\n------------------------------\nDESCRIPTION: Render a string representation of the Index....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.from_arrays", "label": "from_arrays", "shape": "dot", "size": 20, "title": "NAME: from_arrays\n------------------------------\nINPUTS: left, right, closed, name, copy, dtype\nOUTPUTS: IntervalIndex\n------------------------------\nDESCRIPTION: Construct from two arrays defining the left and right bounds. Parameters ---------- left : array-like (1-dimensional) Left bounds for each interval. right : array-like (1-dimensional) Right bounds for each interval. closed : {\u0027left\u0027, \u0027right\u0027, \u0027both\u0027, \u0027neither\u0027}, default \u0027right\u0027 Whether the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.IntervalIndex.from_arrays([0, 1, 2], [1, 2, 3])\nIntervalIndex([(0, 1], (1, 2], (2, 3]],\n              dtype=\u0027interval[int64, right]\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.from_breaks", "label": "from_breaks", "shape": "dot", "size": 20, "title": "NAME: from_breaks\n------------------------------\nINPUTS: breaks, closed, name, copy, dtype\nOUTPUTS: IntervalIndex\n------------------------------\nDESCRIPTION: Construct an IntervalIndex from an array of splits. Parameters ---------- breaks : array-like (1-dimensional) Left and right bounds for each interval. closed : {\u0027left\u0027, \u0027right\u0027, \u0027both\u0027, \u0027neither\u0027}, default \u0027right\u0027 Whether the intervals are closed on the left-side, right-side, both or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.IntervalIndex.from_breaks([0, 1, 2, 3])\nIntervalIndex([(0, 1], (1, 2], (2, 3]],\n              dtype=\u0027interval[int64, right]\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.from_tuples", "label": "from_tuples", "shape": "dot", "size": 20, "title": "NAME: from_tuples\n------------------------------\nINPUTS: data, closed, name, copy, dtype\nOUTPUTS: IntervalIndex\n------------------------------\nDESCRIPTION: Construct an IntervalIndex from an array-like of tuples. Parameters ---------- data : array-like (1-dimensional) Array of tuples. closed : {\u0027left\u0027, \u0027right\u0027, \u0027both\u0027, \u0027neither\u0027}, default \u0027right\u0027 Whether the intervals are closed on the left-side, right-side, both or neither. name : str,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.IntervalIndex.from_tuples([(0, 1), (1, 2)])\nIntervalIndex([(0, 1], (1, 2]],\n               dtype=\u0027interval[int64, right]\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.get_indexer", "label": "get_indexer", "shape": "dot", "size": 20, "title": "NAME: get_indexer\n------------------------------\nINPUTS: self, target, method, limit, tolerance\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Compute indexer and mask for new index given the current index. The indexer should be then used as an input to ndarray.take to align the current data to the new index. Parameters ---------- target : Index method : {None, \u0027pad\u0027/\u0027ffill\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([\u0027c\u0027, \u0027a\u0027, \u0027b\u0027])\n\u003e\u003e\u003e index.get_indexer([\u0027a\u0027, \u0027b\u0027, \u0027x\u0027])\narray([ 1,  2, -1])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.get_indexer_for", "label": "get_indexer_for", "shape": "dot", "size": 20, "title": "NAME: get_indexer_for\n------------------------------\nINPUTS: self, target\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Guaranteed return of an indexer even when non-unique. This dispatches to get_indexer or get_indexer_non_unique as appropriate. Returns ------- np.ndarray[np.intp] List of indices. Examples -------- \u003e\u003e\u003e idx = pd.Index([np.nan, \u0027var1\u0027, np.nan]) \u003e\u003e\u003e idx.get_indexer_for([np.nan]) array([0, 2])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([np.nan, \u0027var1\u0027, np.nan])\n\u003e\u003e\u003e idx.get_indexer_for([np.nan])\narray([0, 2])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.get_indexer_non_unique", "label": "get_indexer_non_unique", "shape": "dot", "size": 20, "title": "NAME: get_indexer_non_unique\n------------------------------\nINPUTS: self, target\nOUTPUTS: tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]\n------------------------------\nDESCRIPTION: Compute indexer and mask for new index given the current index. The indexer should be then used as an input to ndarray.take to align the current data to the new index. Parameters ---------- target : IntervalIndex or list of Intervals...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([\u0027c\u0027, \u0027b\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027])\n\u003e\u003e\u003e index.get_indexer_non_unique([\u0027b\u0027, \u0027b\u0027])\n(array([1, 3, 4, 1, 3, 4]), array([], dtype=int64))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.get_level_values", "label": "get_level_values", "shape": "dot", "size": 20, "title": "NAME: get_level_values\n------------------------------\nINPUTS: self, level\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Return an Index of values for requested level. This is primarily useful to get an individual level of values from a MultiIndex, but is provided on Index as well for compatibility. Parameters ---------- level : int or str It is...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abc\u0027))\n\u003e\u003e\u003e idx\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.get_loc", "label": "get_loc", "shape": "dot", "size": 20, "title": "NAME: get_loc\n------------------------------\nINPUTS: self, key\nOUTPUTS: int | slice | np.ndarray\n------------------------------\nDESCRIPTION: Get integer location, slice or boolean mask for requested label. Parameters ---------- key : label Returns ------- int if unique index, slice if monotonic index, else mask Examples -------- \u003e\u003e\u003e i1, i2 = pd.Interval(0, 1), pd.Interval(1, 2) \u003e\u003e\u003e index =...\n\n\nEXAMPLE:\n\u003e\u003e\u003e i1, i2 = pd.Interval(0, 1), pd.Interval(1, 2)\n\u003e\u003e\u003e index = pd.IntervalIndex([i1, i2])\n\u003e\u003e\u003e index.get_loc(1)\n0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.get_slice_bound", "label": "get_slice_bound", "shape": "dot", "size": 20, "title": "NAME: get_slice_bound\n------------------------------\nINPUTS: self, label, side\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Calculate slice bound that corresponds to given label. Returns leftmost (one-past-the-rightmost if ``side==\u0027right\u0027``) position of given label. Parameters ---------- label : object side : {\u0027left\u0027, \u0027right\u0027} Returns ------- int Index of label. See Also -------- Index.get_loc : Get integer location,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.RangeIndex(5)\n\u003e\u003e\u003e idx.get_slice_bound(3, \u0027left\u0027)\n3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.groupby", "label": "groupby", "shape": "dot", "size": 20, "title": "NAME: groupby\n------------------------------\nINPUTS: self, values\nOUTPUTS: PrettyDict[Hashable, np.ndarray]\n------------------------------\nDESCRIPTION: Group the index labels by a given array of values. Parameters ---------- values : array Values used to determine the groups. Returns ------- dict {group name -\u003e group labels}...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.holds_integer", "label": "holds_integer", "shape": "dot", "size": 20, "title": "NAME: holds_integer\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Whether the type is an integer type. .. deprecated:: 2.0.0 Use `pandas.api.types.infer_dtype` instead...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.identical", "label": "identical", "shape": "dot", "size": 20, "title": "NAME: identical\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Similar to equals, but checks that object attributes and types are also equal. Returns ------- bool If two Index objects have equal elements and same type True, otherwise False. Examples -------- \u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027]) \u003e\u003e\u003e idx2 =...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx2 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx2.identical(idx1)\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.infer_objects", "label": "infer_objects", "shape": "dot", "size": 20, "title": "NAME: infer_objects\n------------------------------\nINPUTS: self, copy\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: If we have an object dtype, try to infer a non-object dtype. Parameters ---------- copy : bool, default True Whether to make a copy in cases where no inference occurs....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.insert", "label": "insert", "shape": "dot", "size": 20, "title": "NAME: insert\n------------------------------\nINPUTS: self, loc, item\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Make new Index inserting new item at location. Follows Python numpy.insert semantics for negative values. Parameters ---------- loc : int item : object Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e idx.insert(1, \u0027x\u0027) Index([\u0027a\u0027, \u0027x\u0027, \u0027b\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.insert(1, \u0027x\u0027)\nIndex([\u0027a\u0027, \u0027x\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.intersection", "label": "intersection", "shape": "dot", "size": 20, "title": "NAME: intersection\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Form the intersection of two Index objects. This returns a new Index with elements common to the index and `other`. Parameters ---------- other : Index or array-like sort : True, False or None, default False Whether to sort the resulting...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.intersection(idx2)\nIndex([3, 4], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.is_", "label": "is_", "shape": "dot", "size": 20, "title": "NAME: is_\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: More flexible, faster check like ``is`` but that works through views. Note: this is *not* the same as ``Index.identical()``, which checks that metadata is also the same. Parameters ---------- other : object Other object to compare against. Returns ------- bool...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx1.is_(idx1.view())\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.is_boolean", "label": "is_boolean", "shape": "dot", "size": 20, "title": "NAME: is_boolean\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of booleans. .. deprecated:: 2.0.0 Use `pandas.api.types.is_bool_dtype` instead. Returns ------- bool Whether or not the Index only consists of booleans. See Also -------- is_integer : Check if the Index only consists of integers (deprecated)....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([True, False, True])\n\u003e\u003e\u003e idx.is_boolean()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.is_categorical", "label": "is_categorical", "shape": "dot", "size": 20, "title": "NAME: is_categorical\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index holds categorical data. .. deprecated:: 2.0.0 Use `isinstance(index.dtype, pd.CategoricalDtype)` instead. Returns ------- bool True if the Index is categorical. See Also -------- CategoricalIndex : Index for categorical data. is_boolean : Check if the Index only consists...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n...                 \"Watermelon\"]).astype(\"category\")\n\u003e\u003e\u003e idx.is_categorical()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.is_floating", "label": "is_floating", "shape": "dot", "size": 20, "title": "NAME: is_floating\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index is a floating type. .. deprecated:: 2.0.0 Use `pandas.api.types.is_float_dtype` instead The Index may consist of only floats, NaNs, or a mix of floats, integers, or NaNs. Returns ------- bool Whether or not the Index only consists...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n\u003e\u003e\u003e idx.is_floating()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.is_integer", "label": "is_integer", "shape": "dot", "size": 20, "title": "NAME: is_integer\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of integers. .. deprecated:: 2.0.0 Use `pandas.api.types.is_integer_dtype` instead. Returns ------- bool Whether or not the Index only consists of integers. See Also -------- is_boolean : Check if the Index only consists of booleans (deprecated)....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx.is_integer()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.is_interval", "label": "is_interval", "shape": "dot", "size": 20, "title": "NAME: is_interval\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index holds Interval objects. .. deprecated:: 2.0.0 Use `isinstance(index.dtype, pd.IntervalDtype)` instead. Returns ------- bool Whether or not the Index holds Interval objects. See Also -------- IntervalIndex : Index for Interval objects. is_boolean : Check if the Index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([pd.Interval(left=0, right=5),\n...                 pd.Interval(left=5, right=10)])\n\u003e\u003e\u003e idx.is_interval()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.is_numeric", "label": "is_numeric", "shape": "dot", "size": 20, "title": "NAME: is_numeric\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of numeric data. .. deprecated:: 2.0.0 Use `pandas.api.types.is_numeric_dtype` instead. Returns ------- bool Whether or not the Index only consists of numeric data. See Also -------- is_boolean : Check if the Index only consists of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n\u003e\u003e\u003e idx.is_numeric()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.is_object", "label": "is_object", "shape": "dot", "size": 20, "title": "NAME: is_object\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index is of the object dtype. .. deprecated:: 2.0.0 Use `pandas.api.types.is_object_dtype` instead. Returns ------- bool Whether or not the Index is of the object dtype. See Also -------- is_boolean : Check if the Index only consists of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\"Apple\", \"Mango\", \"Watermelon\"])\n\u003e\u003e\u003e idx.is_object()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.isin", "label": "isin", "shape": "dot", "size": 20, "title": "NAME: isin\n------------------------------\nINPUTS: self, values, level\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Return a boolean array where the index values are in `values`. Compute boolean array of whether each index value is found in the passed set of values. The length of the returned boolean array matches the length of the index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1,2,3])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.isna", "label": "isna", "shape": "dot", "size": 20, "title": "NAME: isna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get mapped to ``True`` values. Everything else get mapped to ``False`` values. Characters such as empty strings `\u0027\u0027`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.isna()\narray([False, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.isnull", "label": "isnull", "shape": "dot", "size": 20, "title": "NAME: isnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get mapped to ``True`` values. Everything else get mapped to ``False`` values. Characters such as empty strings `\u0027\u0027`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.isna()\narray([False, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.item", "label": "item", "shape": "dot", "size": 20, "title": "NAME: item\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the first element of the underlying data as a Python scalar. Returns ------- scalar The first element of Series or Index. Raises ------ ValueError If the data is not length = 1. Examples -------- \u003e\u003e\u003e s = pd.Series([1]) \u003e\u003e\u003e...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1])\n\u003e\u003e\u003e s.item()\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.join", "label": "join", "shape": "dot", "size": 20, "title": "NAME: join\n------------------------------\nINPUTS: self, other, how, level, return_indexers, sort\nOUTPUTS: Index | tuple[Index, npt.NDArray[np.intp] | None, npt.NDArray[np.intp] | None]\n------------------------------\nDESCRIPTION: Compute join_index and indexers to conform data structures to the new index. Parameters ---------- other : Index how : {\u0027left\u0027, \u0027right\u0027, \u0027inner\u0027, \u0027outer\u0027} level : int or level name, default None return_indexers : bool, default False sort : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx2 = pd.Index([4, 5, 6])\n\u003e\u003e\u003e idx1.join(idx2, how=\u0027outer\u0027)\nIndex([1, 2, 3, 4, 5, 6], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.map", "label": "map", "shape": "dot", "size": 20, "title": "NAME: map\n------------------------------\nINPUTS: self, mapper, na_action\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Map values using an input mapping or function. Parameters ---------- mapper : function, dict, or Series Mapping correspondence. na_action : {None, \u0027ignore\u0027} If \u0027ignore\u0027, propagate NA values, without passing them to the mapping correspondence. Returns ------- Union[Index, MultiIndex] The output...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.map({1: \u0027a\u0027, 2: \u0027b\u0027, 3: \u0027c\u0027})\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.max", "label": "max", "shape": "dot", "size": 20, "title": "NAME: max\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the maximum value of the Index. Parameters ---------- axis : int, optional For compatibility with NumPy. Only 0 or None are allowed. skipna : bool, default True Exclude NA/null values when showing the result. *args, **kwargs Additional arguments and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([3, 2, 1])\n\u003e\u003e\u003e idx.max()\n3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.memory_usage", "label": "memory_usage", "shape": "dot", "size": 20, "title": "NAME: memory_usage\n------------------------------\nINPUTS: self, deep\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Memory usage of the values. Parameters ---------- deep : bool, default False Introspect the data deeply, interrogate `object` dtypes for system-level memory consumption. Returns ------- bytes used See Also -------- numpy.ndarray.nbytes : Total bytes consumed by the elements of the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.memory_usage()\n24"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.min", "label": "min", "shape": "dot", "size": 20, "title": "NAME: min\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the minimum value of the Index. Parameters ---------- axis : {None} Dummy argument for consistency with Series. skipna : bool, default True Exclude NA/null values when showing the result. *args, **kwargs Additional arguments and keywords for compatibility with NumPy....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([3, 2, 1])\n\u003e\u003e\u003e idx.min()\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.notna", "label": "notna", "shape": "dot", "size": 20, "title": "NAME: notna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to ``True``. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values. NA values, such as None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.notna()\narray([ True,  True, False])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.notnull", "label": "notnull", "shape": "dot", "size": 20, "title": "NAME: notnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to ``True``. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values. NA values, such as None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.notna()\narray([ True,  True, False])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.nunique", "label": "nunique", "shape": "dot", "size": 20, "title": "NAME: nunique\n------------------------------\nINPUTS: self, dropna\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return number of unique elements in the object. Excludes NA values by default. Parameters ---------- dropna : bool, default True Don\u0027t include NaN in the count. Returns ------- int See Also -------- DataFrame.nunique: Method nunique for DataFrame. Series.count: Count non-NA/null...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 3, 5, 7, 7])\n\u003e\u003e\u003e s\n0    1\n1    3\n2    5\n3    7\n4    7\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.overlaps", "label": "overlaps", "shape": "dot", "size": 20, "title": "NAME: overlaps\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Check elementwise if an Interval overlaps the values in the IntervalArray. Two intervals overlap if they share a common point, including closed endpoints. Intervals that only have an open endpoint in common do not overlap. Parameters ---------- other : IntervalArray...\n\n\nEXAMPLE:\n\u003e\u003e\u003e data = [(0, 1), (1, 3), (2, 4)]\n\u003e\u003e\u003e intervals = pd.arrays.IntervalArray.from_tuples(data)\n\u003e\u003e\u003e intervals\n\u003cIntervalArray\u003e\n[(0, 1], (1, 3], (2, 4]]\nLength: 3, dtype: interval[int64, right]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.putmask", "label": "putmask", "shape": "dot", "size": 20, "title": "NAME: putmask\n------------------------------\nINPUTS: self, mask, value\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Return a new Index of the values set with the mask. Returns ------- Index See Also -------- numpy.ndarray.putmask : Changes elements of an array based on conditional and input values. Examples -------- \u003e\u003e\u003e idx1 = pd.Index([1, 2, 3]) \u003e\u003e\u003e idx2...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx2 = pd.Index([5, 6, 7])\n\u003e\u003e\u003e idx1.putmask([True, False, False], idx2)\nIndex([5, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.ravel", "label": "ravel", "shape": "dot", "size": 20, "title": "NAME: ravel\n------------------------------\nINPUTS: self, order\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a view on self. Returns ------- Index See Also -------- numpy.ndarray.ravel : Return a flattened array. Examples -------- \u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e s.index.ravel() Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e s.index.ravel()\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.reindex", "label": "reindex", "shape": "dot", "size": 20, "title": "NAME: reindex\n------------------------------\nINPUTS: self, target, method, level, limit, tolerance\nOUTPUTS: tuple[Index, npt.NDArray[np.intp] | None]\n------------------------------\nDESCRIPTION: Create index with target\u0027s values. Parameters ---------- target : an iterable method : {None, \u0027pad\u0027/\u0027ffill\u0027, \u0027backfill\u0027/\u0027bfill\u0027, \u0027nearest\u0027}, optional * default: exact matches only. * pad / ffill: find the PREVIOUS index value if no exact match. * backfill / bfill:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.reindex([\u0027car\u0027, \u0027bike\u0027])\n(Index([\u0027car\u0027, \u0027bike\u0027], dtype=\u0027object\u0027), array([0, 1]))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.rename", "label": "rename", "shape": "dot", "size": 20, "title": "NAME: rename\n------------------------------\nINPUTS: self, name, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Alter Index or MultiIndex name. Able to set new names without level. Defaults to returning new index. Length of names must match number of levels in MultiIndex. Parameters ---------- name : label or list of labels Name(s) to set. inplace...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027A\u0027, \u0027C\u0027, \u0027A\u0027, \u0027B\u0027], name=\u0027score\u0027)\n\u003e\u003e\u003e idx.rename(\u0027grade\u0027)\nIndex([\u0027A\u0027, \u0027C\u0027, \u0027A\u0027, \u0027B\u0027], dtype=\u0027object\u0027, name=\u0027grade\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.repeat", "label": "repeat", "shape": "dot", "size": 20, "title": "NAME: repeat\n------------------------------\nINPUTS: self, repeats, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Repeat elements of a Index. Returns a new Index where each element of the current Index is repeated consecutively a given number of times. Parameters ---------- repeats : int or array of ints The number of repetitions for each element....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.repeat(2)\nIndex([\u0027a\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027c\u0027, \u0027c\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.repeat([1, 2, 3])\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027c\u0027, \u0027c\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.round", "label": "round", "shape": "dot", "size": 20, "title": "NAME: round\n------------------------------\nINPUTS: self, decimals\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Round each value in the Index to the given number of decimals. Parameters ---------- decimals : int, optional Number of decimal places to round to. If decimals is negative, it specifies the number of positions to the left of the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import pandas as pd\n\u003e\u003e\u003e idx = pd.Index([10.1234, 20.5678, 30.9123, 40.4567, 50.7890])\n\u003e\u003e\u003e idx.round(decimals=2)\nIndex([10.12, 20.57, 30.91, 40.46, 50.79], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.searchsorted", "label": "searchsorted", "shape": "dot", "size": 20, "title": "NAME: searchsorted\n------------------------------\nINPUTS: self, value, side, sorter\nOUTPUTS: npt.NDArray[np.intp] | np.intp\n------------------------------\nDESCRIPTION: Find indices where elements should be inserted to maintain order. Find the indices into a sorted Index `self` such that, if the corresponding elements in `value` were inserted before the indices, the order of `self` would be preserved. .. note::...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([1, 2, 3])\n\u003e\u003e\u003e ser\n0    1\n1    2\n2    3\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.set_closed", "label": "set_closed", "shape": "dot", "size": 20, "title": "NAME: set_closed\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return an identical IntervalArray closed on the specified side. Parameters ---------- closed : {\u0027left\u0027, \u0027right\u0027, \u0027both\u0027, \u0027neither\u0027} Whether the intervals are closed on the left-side, right-side, both or neither. Returns ------- IntervalArray Examples -------- \u003e\u003e\u003e index = pd.arrays.IntervalArray.from_breaks(range(4)) \u003e\u003e\u003e index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.arrays.IntervalArray.from_breaks(range(4))\n\u003e\u003e\u003e index\n\u003cIntervalArray\u003e\n[(0, 1], (1, 2], (2, 3]]\nLength: 3, dtype: interval[int64, right]\n\u003e\u003e\u003e index.set_closed(\u0027both\u0027)\n\u003cIntervalArray\u003e\n[[0, 1], [1, 2], [2, 3]]\nLength: 3, dtype: interval[int64, both]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.set_names", "label": "set_names", "shape": "dot", "size": 20, "title": "NAME: set_names\n------------------------------\nINPUTS: self, names, level, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Set Index or MultiIndex name. Able to set new names partially and by level. Parameters ---------- names : label or list of label or dict-like for MultiIndex Name(s) to set. .. versionchanged:: 1.3.0 level : int, label or list of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx.set_names(\u0027quarter\u0027)\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027, name=\u0027quarter\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.shift", "label": "shift", "shape": "dot", "size": 20, "title": "NAME: shift\n------------------------------\nINPUTS: self, periods, freq\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Shift index by desired number of time frequency increments. This method is for shifting the values of datetime-like indexes by a specified time increment a given number of times. Parameters ---------- periods : int, default 1 Number of periods (or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e month_starts = pd.date_range(\u00271/1/2011\u0027, periods=5, freq=\u0027MS\u0027)\n\u003e\u003e\u003e month_starts\nDatetimeIndex([\u00272011-01-01\u0027, \u00272011-02-01\u0027, \u00272011-03-01\u0027, \u00272011-04-01\u0027,\n               \u00272011-05-01\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=\u0027MS\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.slice_indexer", "label": "slice_indexer", "shape": "dot", "size": 20, "title": "NAME: slice_indexer\n------------------------------\nINPUTS: self, start, end, step\nOUTPUTS: slice\n------------------------------\nDESCRIPTION: Compute the slice indexer for input labels and step. Index needs to be ordered and unique. Parameters ---------- start : label, default None If None, defaults to the beginning. end : label, default None If None, defaults to the end....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abcd\u0027))\n\u003e\u003e\u003e idx.slice_indexer(start=\u0027b\u0027, end=\u0027c\u0027)\nslice(1, 3, None)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.slice_locs", "label": "slice_locs", "shape": "dot", "size": 20, "title": "NAME: slice_locs\n------------------------------\nINPUTS: self, start, end, step\nOUTPUTS: tuple[int, int]\n------------------------------\nDESCRIPTION: Compute slice locations for input labels. Parameters ---------- start : label, default None If None, defaults to the beginning. end : label, default None If None, defaults to the end. step : int, defaults None If None, defaults to 1....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abcd\u0027))\n\u003e\u003e\u003e idx.slice_locs(start=\u0027b\u0027, end=\u0027c\u0027)\n(1, 3)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.sort", "label": "sort", "shape": "dot", "size": 20, "title": "NAME: sort\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Use sort_values instead....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.sort_values", "label": "sort_values", "shape": "dot", "size": 20, "title": "NAME: sort_values\n------------------------------\nINPUTS: self, return_indexer, ascending, na_position, key\nOUTPUTS: Self | tuple[Self, np.ndarray]\n------------------------------\nDESCRIPTION: Return a sorted copy of the index. Return a sorted copy of the index, and optionally return the indices that sorted the index itself. Parameters ---------- return_indexer : bool, default False Should the indices that would sort the index be...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([10, 100, 1, 1000])\n\u003e\u003e\u003e idx\nIndex([10, 100, 1, 1000], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.sortlevel", "label": "sortlevel", "shape": "dot", "size": 20, "title": "NAME: sortlevel\n------------------------------\nINPUTS: self, level, ascending, sort_remaining, na_position\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: For internal compatibility with the Index API. Sort the Index. This is for compat with MultiIndex Parameters ---------- ascending : bool, default True False to sort in descending order na_position : {\u0027first\u0027 or \u0027last\u0027}, default \u0027first\u0027 Argument \u0027first\u0027 puts NaNs...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.IntervalIndex.str", "label": "str", "shape": "dot", "size": 20, "title": "NAME: str\n------------------------------\nINPUTS: data\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Vectorized string functions for Series and Index. NAs stay NA unless handled otherwise by a particular method. Patterned after Python\u0027s string methods, with some inspiration from R\u0027s stringr package. Examples -------- \u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"]) \u003e\u003e\u003e s 0 A_Str_Series dtype:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"])\n\u003e\u003e\u003e s\n0    A_Str_Series\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.symmetric_difference", "label": "symmetric_difference", "shape": "dot", "size": 20, "title": "NAME: symmetric_difference\n------------------------------\nINPUTS: self, other, result_name, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Compute the symmetric difference of two Index objects. Parameters ---------- other : Index or array-like result_name : str sort : bool or None, default None Whether to sort the resulting index. By default, the values are attempted to be sorted,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([2, 3, 4, 5])\n\u003e\u003e\u003e idx1.symmetric_difference(idx2)\nIndex([1, 5], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.take", "label": "take", "shape": "dot", "size": 20, "title": "NAME: take\n------------------------------\nINPUTS: self, indices, axis, allow_fill, fill_value, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a new Index of the values selected by the indices. For internal compatibility with numpy arrays. Parameters ---------- indices : array-like Indices to be taken. axis : int, optional The axis over which to select values, always 0. allow_fill...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.take([2, 2, 1, 2])\nIndex([\u0027c\u0027, \u0027c\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.to_flat_index", "label": "to_flat_index", "shape": "dot", "size": 20, "title": "NAME: to_flat_index\n------------------------------\nINPUTS: self\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Identity method. This is implemented for compatibility with subclass implementations when chaining. Returns ------- pd.Index Caller. See Also -------- MultiIndex.to_flat_index : Subclass implementation....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.to_frame", "label": "to_frame", "shape": "dot", "size": 20, "title": "NAME: to_frame\n------------------------------\nINPUTS: self, index, name\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Create a DataFrame with a column containing the Index. Parameters ---------- index : bool, default True Set the index of the returned DataFrame as the original Index. name : object, defaults to index.name The passed name should substitute for the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027Ant\u0027, \u0027Bear\u0027, \u0027Cow\u0027], name=\u0027animal\u0027)\n\u003e\u003e\u003e idx.to_frame()\n       animal\nanimal\nAnt       Ant\nBear     Bear\nCow       Cow"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.to_list", "label": "to_list", "shape": "dot", "size": 20, "title": "NAME: to_list\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list See Also -------- numpy.ndarray.tolist : Return the array as an...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.to_list()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.to_numpy", "label": "to_numpy", "shape": "dot", "size": 20, "title": "NAME: to_numpy\n------------------------------\nINPUTS: self, dtype, copy, na_value, kwargs\nOUTPUTS: np.ndarray\n------------------------------\nDESCRIPTION: A NumPy ndarray representing the values in this Series or Index. Parameters ---------- dtype : str or numpy.dtype, optional The dtype to pass to :meth:`numpy.asarray`. copy : bool, default False Whether to ensure that the returned value is not a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series(pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027]))\n\u003e\u003e\u003e ser.to_numpy()\narray([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.to_series", "label": "to_series", "shape": "dot", "size": 20, "title": "NAME: to_series\n------------------------------\nINPUTS: self, index, name\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Create a Series with both index and values equal to the index keys. Useful with map for returning an indexer based on an index. Parameters ---------- index : Index, optional Index of resulting Series. If None, defaults to original index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027Ant\u0027, \u0027Bear\u0027, \u0027Cow\u0027], name=\u0027animal\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.to_tuples", "label": "to_tuples", "shape": "dot", "size": 20, "title": "NAME: to_tuples\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return an ndarray (if self is IntervalArray) or Index (if self is IntervalIndex) of tuples of the form (left, right). Parameters ---------- na_tuple : bool, default True If ``True``, return ``NA`` as a tuple ``(nan, nan)``. If ``False``, just return...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.arrays.IntervalArray.from_tuples([(0, 1), (1, 2)])\n\u003e\u003e\u003e idx\n\u003cIntervalArray\u003e\n[(0, 1], (1, 2]]\nLength: 2, dtype: interval[int64, right]\n\u003e\u003e\u003e idx.to_tuples()\narray([(0, 1), (1, 2)], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.tolist", "label": "tolist", "shape": "dot", "size": 20, "title": "NAME: tolist\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list See Also -------- numpy.ndarray.tolist : Return the array as an...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.to_list()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.transpose", "label": "transpose", "shape": "dot", "size": 20, "title": "NAME: transpose\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return the transpose, which is by definition self. Returns ------- %(klass)s...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.union", "label": "union", "shape": "dot", "size": 20, "title": "NAME: union\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Form the union of two Index objects. If the Index objects are incompatible, both Index objects will be cast to dtype(\u0027object\u0027) first. Parameters ---------- other : Index or array-like sort : bool or None, default None Whether to sort the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.union(idx2)\nIndex([1, 2, 3, 4, 5, 6], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.unique", "label": "unique", "shape": "dot", "size": 20, "title": "NAME: unique\n------------------------------\nINPUTS: self, level\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return unique values in the index. Unique values are returned in order of appearance, this does NOT sort. Parameters ---------- level : int or hashable, optional Only return values from specified level (for MultiIndex). If int, gets the level by...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 1, 2, 3, 3])\n\u003e\u003e\u003e idx.unique()\nIndex([1, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.value_counts", "label": "value_counts", "shape": "dot", "size": 20, "title": "NAME: value_counts\n------------------------------\nINPUTS: self, normalize, sort, ascending, bins, dropna\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return a Series containing counts of unique values. The resulting object will be in descending order so that the first element is the most frequently-occurring element. Excludes NA values by default. Parameters ---------- normalize : bool, default False If True...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([3, 1, 2, 3, 4, np.nan])\n\u003e\u003e\u003e index.value_counts()\n3.0    2\n1.0    1\n2.0    1\n4.0    1\nName: count, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.view", "label": "view", "shape": "dot", "size": 20, "title": "NAME: view\n------------------------------\nINPUTS: self, cls\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.IntervalIndex.where", "label": "where", "shape": "dot", "size": 20, "title": "NAME: where\n------------------------------\nINPUTS: self, cond, other\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Replace values where the condition is False. The replacement is taken from other. Parameters ---------- cond : bool array-like with the same length as self Condition to select the values on. other : scalar, or array-like, default None Replacement if...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.where(idx.isin([\u0027car\u0027, \u0027train\u0027]), \u0027other\u0027)\nIndex([\u0027car\u0027, \u0027other\u0027, \u0027train\u0027, \u0027other\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.all", "label": "all", "shape": "dot", "size": 20, "title": "NAME: all\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return whether all elements are Truthy. Parameters ---------- *args Required for compatibility with numpy. **kwargs Required for compatibility with numpy. Returns ------- bool or array-like (if axis is specified) A single element array-like may be converted to bool. See Also...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Index([1, 2, 3]).all()\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.any", "label": "any", "shape": "dot", "size": 20, "title": "NAME: any\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return whether any element is Truthy. Parameters ---------- *args Required for compatibility with numpy. **kwargs Required for compatibility with numpy. Returns ------- bool or array-like (if axis is specified) A single element array-like may be converted to bool. See Also...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([0, 1, 2])\n\u003e\u003e\u003e index.any()\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.append", "label": "append", "shape": "dot", "size": 20, "title": "NAME: append\n------------------------------\nINPUTS: self, other\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Append a collection of Index options together. Parameters ---------- other : Index or list/tuple of indices Returns ------- Index The combined index. Examples -------- \u003e\u003e\u003e mi = pd.MultiIndex.from_arrays([[\u0027a\u0027], [\u0027b\u0027]]) \u003e\u003e\u003e mi MultiIndex([(\u0027a\u0027, \u0027b\u0027)], ) \u003e\u003e\u003e mi.append(mi) MultiIndex([(\u0027a\u0027, \u0027b\u0027), (\u0027a\u0027, \u0027b\u0027)],...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays([[\u0027a\u0027], [\u0027b\u0027]])\n\u003e\u003e\u003e mi\nMultiIndex([(\u0027a\u0027, \u0027b\u0027)],\n           )\n\u003e\u003e\u003e mi.append(mi)\nMultiIndex([(\u0027a\u0027, \u0027b\u0027), (\u0027a\u0027, \u0027b\u0027)],\n           )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.argmax", "label": "argmax", "shape": "dot", "size": 20, "title": "NAME: argmax\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the largest value in the Series. If the maximum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.argmin", "label": "argmin", "shape": "dot", "size": 20, "title": "NAME: argmin\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the smallest value in the Series. If the minimum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.argsort", "label": "argsort", "shape": "dot", "size": 20, "title": "NAME: argsort\n------------------------------\nINPUTS: self, args, na_position, kwargs\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Return the integer indices that would sort the index. Parameters ---------- *args Passed to `numpy.ndarray.argsort`. **kwargs Passed to `numpy.ndarray.argsort`. Returns ------- np.ndarray[np.intp] Integer indices that would sort the index if used as an indexer. See Also -------- numpy.argsort : Similar...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027b\u0027, \u0027a\u0027, \u0027d\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027b\u0027, \u0027a\u0027, \u0027d\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.asof", "label": "asof", "shape": "dot", "size": 20, "title": "NAME: asof\n------------------------------\nINPUTS: self, label\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the label from the index, or, if not present, the previous one. Assuming that the index is sorted, return the passed index label if it is in the index, or return the previous index label if the passed one...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u00272013-12-31\u0027, \u00272014-01-02\u0027, \u00272014-01-03\u0027])\n\u003e\u003e\u003e idx.asof(\u00272014-01-01\u0027)\n\u00272013-12-31\u0027"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.asof_locs", "label": "asof_locs", "shape": "dot", "size": 20, "title": "NAME: asof_locs\n------------------------------\nINPUTS: self, where, mask\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Return the locations (indices) of labels in the index. As in the :meth:`pandas.Index.asof`, if the label (a particular entry in ``where``) is not in the index, the latest index label up to the passed label is chosen and its index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.date_range(\u00272023-06-01\u0027, periods=3, freq=\u0027D\u0027)\n\u003e\u003e\u003e where = pd.DatetimeIndex([\u00272023-05-30 00:12:00\u0027, \u00272023-06-01 00:00:00\u0027,\n...                           \u00272023-06-02 23:59:59\u0027])\n\u003e\u003e\u003e mask = np.ones(3, dtype=bool)\n\u003e\u003e\u003e idx.asof_locs(where, mask)\narray([-1,  0,  1])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.astype", "label": "astype", "shape": "dot", "size": 20, "title": "NAME: astype\n------------------------------\nINPUTS: self, dtype, copy\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Create an Index with values cast to dtypes. The class of a new Index is determined by dtype. When conversion is impossible, a TypeError exception is raised. Parameters ---------- dtype : numpy dtype or pandas type Note that any signed...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx.astype(\u0027float\u0027)\nIndex([1.0, 2.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.copy", "label": "copy", "shape": "dot", "size": 20, "title": "NAME: copy\n------------------------------\nINPUTS: self, names, deep, name\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make a copy of this object. Names, dtype, levels and codes can be passed and will be set on new copy. Parameters ---------- names : sequence, optional deep : bool, default False name : Label Kept for compatibility with 1-dimensional...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays([[\u0027a\u0027], [\u0027b\u0027], [\u0027c\u0027]])\n\u003e\u003e\u003e mi\nMultiIndex([(\u0027a\u0027, \u0027b\u0027, \u0027c\u0027)],\n           )\n\u003e\u003e\u003e mi.copy()\nMultiIndex([(\u0027a\u0027, \u0027b\u0027, \u0027c\u0027)],\n           )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.delete", "label": "delete", "shape": "dot", "size": 20, "title": "NAME: delete\n------------------------------\nINPUTS: self, loc\nOUTPUTS: MultiIndex\n------------------------------\nDESCRIPTION: Make new index with passed location deleted Returns ------- new_index : MultiIndex...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.diff", "label": "diff", "shape": "dot", "size": 20, "title": "NAME: diff\n------------------------------\nINPUTS: self, periods\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Computes the difference between consecutive values in the Index object. If periods is greater than 1, computes the difference between values that are `periods` number of positions apart. Parameters ---------- periods : int, optional The number of positions between the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import pandas as pd\n\u003e\u003e\u003e idx = pd.Index([10, 20, 30, 40, 50])\n\u003e\u003e\u003e idx.diff()\nIndex([nan, 10.0, 10.0, 10.0, 10.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.difference", "label": "difference", "shape": "dot", "size": 20, "title": "NAME: difference\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a new Index with elements of index not in `other`. This is the set difference of two Index objects. Parameters ---------- other : Index or array-like sort : bool or None, default None Whether to sort the resulting index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([2, 1, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.difference(idx2)\nIndex([1, 2], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx1.difference(idx2, sort=False)\nIndex([2, 1], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.drop", "label": "drop", "shape": "dot", "size": 20, "title": "NAME: drop\n------------------------------\nINPUTS: self, codes, level, errors\nOUTPUTS: MultiIndex\n------------------------------\nDESCRIPTION: Make a new :class:`pandas.MultiIndex` with the passed list of codes deleted. Parameters ---------- codes : array-like Must be a list of tuples when ``level`` is not specified. level : int or level name, default None errors : str, default \u0027raise\u0027...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.MultiIndex.from_product([(0, 1, 2), (\u0027green\u0027, \u0027purple\u0027)],\n...                                  names=[\"number\", \"color\"])\n\u003e\u003e\u003e idx\nMultiIndex([(0,  \u0027green\u0027),\n            (0, \u0027purple\u0027),\n            (1,  \u0027green\u0027),\n            (1, \u0027purple\u0027),\n            (2,  \u0027green\u0027),\n            (2, \u0027purple\u0027)],\n           names=[\u0027number\u0027, \u0027color\u0027])\n\u003e\u003e\u003e idx.drop([(1, \u0027green\u0027), (2, \u0027purple\u0027)])\nMultiIndex([(0,  \u0027green\u0027),\n            (0, \u0027purple\u0027),\n            (1, \u0027purple\u0027),\n            (2,  \u0027green\u0027)],\n           names=[\u0027number\u0027, \u0027color\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.drop_duplicates", "label": "drop_duplicates", "shape": "dot", "size": 20, "title": "NAME: drop_duplicates\n------------------------------\nINPUTS: self, keep\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return Index with duplicate values removed. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, ``False``}, default \u0027first\u0027 - \u0027first\u0027 : Drop duplicates except for the first occurrence. - \u0027last\u0027 : Drop duplicates except for the last occurrence. - ``False`` : Drop all...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027lama\u0027, \u0027cow\u0027, \u0027lama\u0027, \u0027beetle\u0027, \u0027lama\u0027, \u0027hippo\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.droplevel", "label": "droplevel", "shape": "dot", "size": 20, "title": "NAME: droplevel\n------------------------------\nINPUTS: self, level\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return index with requested level(s) removed. If resulting index has only 1 level left, the result will be of Index type, not MultiIndex. The original index is not modified inplace. Parameters ---------- level : int, str, or list-like, default 0...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays(\n... [[1, 2], [3, 4], [5, 6]], names=[\u0027x\u0027, \u0027y\u0027, \u0027z\u0027])\n\u003e\u003e\u003e mi\nMultiIndex([(1, 3, 5),\n            (2, 4, 6)],\n           names=[\u0027x\u0027, \u0027y\u0027, \u0027z\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.dropna", "label": "dropna", "shape": "dot", "size": 20, "title": "NAME: dropna\n------------------------------\nINPUTS: self, how\nOUTPUTS: MultiIndex\n------------------------------\nDESCRIPTION: Return Index without NA/NaN values. Parameters ---------- how : {\u0027any\u0027, \u0027all\u0027}, default \u0027any\u0027 If the Index is a MultiIndex, drop the value when any or all levels are NaN. Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([1, np.nan, 3])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, np.nan, 3])\n\u003e\u003e\u003e idx.dropna()\nIndex([1.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.duplicated", "label": "duplicated", "shape": "dot", "size": 20, "title": "NAME: duplicated\n------------------------------\nINPUTS: self, keep\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Indicate duplicate index values. Duplicated values are indicated as ``True`` values in the resulting array. Either all duplicates, all except the first, or all except the last occurrence of duplicates can be indicated. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, False},...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027lama\u0027, \u0027cow\u0027, \u0027lama\u0027, \u0027beetle\u0027, \u0027lama\u0027])\n\u003e\u003e\u003e idx.duplicated()\narray([False, False,  True, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.equal_levels", "label": "equal_levels", "shape": "dot", "size": 20, "title": "NAME: equal_levels\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Return True if the levels of both MultiIndex objects are the same...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.equals", "label": "equals", "shape": "dot", "size": 20, "title": "NAME: equals\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Determines if two MultiIndex objects have the same labeling information (the levels themselves do not necessarily have to be the same) See Also -------- equal_levels...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.factorize", "label": "factorize", "shape": "dot", "size": 20, "title": "NAME: factorize\n------------------------------\nINPUTS: self, sort, use_na_sentinel\nOUTPUTS: tuple[npt.NDArray[np.intp], Index]\n------------------------------\nDESCRIPTION: Encode the object as an enumerated type or categorical variable. This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct values. `factorize` is available as both a top-level function :func:`pandas.factorize`, and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e codes, uniques = pd.factorize(np.array([\u0027b\u0027, \u0027b\u0027, \u0027a\u0027, \u0027c\u0027, \u0027b\u0027], dtype=\"O\"))\n\u003e\u003e\u003e codes\narray([0, 0, 1, 2, 0])\n\u003e\u003e\u003e uniques\narray([\u0027b\u0027, \u0027a\u0027, \u0027c\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.fillna", "label": "fillna", "shape": "dot", "size": 20, "title": "NAME: fillna\n------------------------------\nINPUTS: self, value, downcast\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: fillna is not implemented for MultiIndex...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.format", "label": "format", "shape": "dot", "size": 20, "title": "NAME: format\n------------------------------\nINPUTS: self, name, formatter, na_rep, names, space, sparsify, adjoin\nOUTPUTS: list\n------------------------------\nDESCRIPTION: Render a string representation of the Index....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.from_arrays", "label": "from_arrays", "shape": "dot", "size": 20, "title": "NAME: from_arrays\n------------------------------\nINPUTS: arrays, sortorder, names\nOUTPUTS: MultiIndex\n------------------------------\nDESCRIPTION: Convert arrays to MultiIndex. Parameters ---------- arrays : list / sequence of array-likes Each array-like gives one level\u0027s value for each data point. len(arrays) is the number of levels. sortorder : int or None Level of sortedness (must be lexicographically...\n\n\nEXAMPLE:\n\u003e\u003e\u003e arrays = [[1, 1, 2, 2], [\u0027red\u0027, \u0027blue\u0027, \u0027red\u0027, \u0027blue\u0027]]\n\u003e\u003e\u003e pd.MultiIndex.from_arrays(arrays, names=(\u0027number\u0027, \u0027color\u0027))\nMultiIndex([(1,  \u0027red\u0027),\n            (1, \u0027blue\u0027),\n            (2,  \u0027red\u0027),\n            (2, \u0027blue\u0027)],\n           names=[\u0027number\u0027, \u0027color\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.from_frame", "label": "from_frame", "shape": "dot", "size": 20, "title": "NAME: from_frame\n------------------------------\nINPUTS: df, sortorder, names\nOUTPUTS: MultiIndex\n------------------------------\nDESCRIPTION: Make a MultiIndex from a DataFrame. Parameters ---------- df : DataFrame DataFrame to be converted to MultiIndex. sortorder : int, optional Level of sortedness (must be lexicographically sorted by that level). names : list-like, optional If no names are provided,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[\u0027HI\u0027, \u0027Temp\u0027], [\u0027HI\u0027, \u0027Precip\u0027],\n...                    [\u0027NJ\u0027, \u0027Temp\u0027], [\u0027NJ\u0027, \u0027Precip\u0027]],\n...                   columns=[\u0027a\u0027, \u0027b\u0027])\n\u003e\u003e\u003e df\n      a       b\n0    HI    Temp\n1    HI  Precip\n2    NJ    Temp\n3    NJ  Precip"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.from_product", "label": "from_product", "shape": "dot", "size": 20, "title": "NAME: from_product\n------------------------------\nINPUTS: iterables, sortorder, names\nOUTPUTS: MultiIndex\n------------------------------\nDESCRIPTION: Make a MultiIndex from the cartesian product of multiple iterables. Parameters ---------- iterables : list / sequence of iterables Each iterable has unique labels for each level of the index. sortorder : int or None Level of sortedness (must be...\n\n\nEXAMPLE:\n\u003e\u003e\u003e numbers = [0, 1, 2]\n\u003e\u003e\u003e colors = [\u0027green\u0027, \u0027purple\u0027]\n\u003e\u003e\u003e pd.MultiIndex.from_product([numbers, colors],\n...                            names=[\u0027number\u0027, \u0027color\u0027])\nMultiIndex([(0,  \u0027green\u0027),\n            (0, \u0027purple\u0027),\n            (1,  \u0027green\u0027),\n            (1, \u0027purple\u0027),\n            (2,  \u0027green\u0027),\n            (2, \u0027purple\u0027)],\n           names=[\u0027number\u0027, \u0027color\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.from_tuples", "label": "from_tuples", "shape": "dot", "size": 20, "title": "NAME: from_tuples\n------------------------------\nINPUTS: tuples, sortorder, names\nOUTPUTS: MultiIndex\n------------------------------\nDESCRIPTION: Convert list of tuples to MultiIndex. Parameters ---------- tuples : list / sequence of tuple-likes Each tuple is the index of one row/column. sortorder : int or None Level of sortedness (must be lexicographically sorted by that level). names :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e tuples = [(1, \u0027red\u0027), (1, \u0027blue\u0027),\n...           (2, \u0027red\u0027), (2, \u0027blue\u0027)]\n\u003e\u003e\u003e pd.MultiIndex.from_tuples(tuples, names=(\u0027number\u0027, \u0027color\u0027))\nMultiIndex([(1,  \u0027red\u0027),\n            (1, \u0027blue\u0027),\n            (2,  \u0027red\u0027),\n            (2, \u0027blue\u0027)],\n           names=[\u0027number\u0027, \u0027color\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.get_indexer", "label": "get_indexer", "shape": "dot", "size": 20, "title": "NAME: get_indexer\n------------------------------\nINPUTS: self, target, method, limit, tolerance\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Compute indexer and mask for new index given the current index. The indexer should be then used as an input to ndarray.take to align the current data to the new index. Parameters ---------- target : Index method : {None, \u0027pad\u0027/\u0027ffill\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([\u0027c\u0027, \u0027a\u0027, \u0027b\u0027])\n\u003e\u003e\u003e index.get_indexer([\u0027a\u0027, \u0027b\u0027, \u0027x\u0027])\narray([ 1,  2, -1])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.get_indexer_for", "label": "get_indexer_for", "shape": "dot", "size": 20, "title": "NAME: get_indexer_for\n------------------------------\nINPUTS: self, target\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Guaranteed return of an indexer even when non-unique. This dispatches to get_indexer or get_indexer_non_unique as appropriate. Returns ------- np.ndarray[np.intp] List of indices. Examples -------- \u003e\u003e\u003e idx = pd.Index([np.nan, \u0027var1\u0027, np.nan]) \u003e\u003e\u003e idx.get_indexer_for([np.nan]) array([0, 2])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([np.nan, \u0027var1\u0027, np.nan])\n\u003e\u003e\u003e idx.get_indexer_for([np.nan])\narray([0, 2])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.get_indexer_non_unique", "label": "get_indexer_non_unique", "shape": "dot", "size": 20, "title": "NAME: get_indexer_non_unique\n------------------------------\nINPUTS: self, target\nOUTPUTS: tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]\n------------------------------\nDESCRIPTION: Compute indexer and mask for new index given the current index. The indexer should be then used as an input to ndarray.take to align the current data to the new index. Parameters ---------- target : Index Returns ------- indexer :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([\u0027c\u0027, \u0027b\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027])\n\u003e\u003e\u003e index.get_indexer_non_unique([\u0027b\u0027, \u0027b\u0027])\n(array([1, 3, 4, 1, 3, 4]), array([], dtype=int64))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.get_level_values", "label": "get_level_values", "shape": "dot", "size": 20, "title": "NAME: get_level_values\n------------------------------\nINPUTS: self, level\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Return vector of label values for requested level. Length of returned vector is equal to the length of the index. Parameters ---------- level : int or str ``level`` is either the integer position of the level in the MultiIndex, or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays((list(\u0027abc\u0027), list(\u0027def\u0027)))\n\u003e\u003e\u003e mi.names = [\u0027level_1\u0027, \u0027level_2\u0027]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.get_loc", "label": "get_loc", "shape": "dot", "size": 20, "title": "NAME: get_loc\n------------------------------\nINPUTS: self, key\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Get location for a label or a tuple of labels. The location is returned as an integer/slice or boolean mask. Parameters ---------- key : label or tuple of labels (one for each level) Returns ------- int, slice object or boolean...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays([list(\u0027abb\u0027), list(\u0027def\u0027)])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.get_loc_level", "label": "get_loc_level", "shape": "dot", "size": 20, "title": "NAME: get_loc_level\n------------------------------\nINPUTS: self, key, level, drop_level\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Get location and sliced index for requested label(s)/level(s). Parameters ---------- key : label or sequence of labels level : int/level name or list thereof, optional drop_level : bool, default True If ``False``, the resulting index will not drop any level....\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays([list(\u0027abb\u0027), list(\u0027def\u0027)],\n...                                names=[\u0027A\u0027, \u0027B\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.get_locs", "label": "get_locs", "shape": "dot", "size": 20, "title": "NAME: get_locs\n------------------------------\nINPUTS: self, seq\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Get location for a sequence of labels. Parameters ---------- seq : label, slice, list, mask or a sequence of such You should use one of the above for each level. If a level should not be used, set it to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays([list(\u0027abb\u0027), list(\u0027def\u0027)])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.get_slice_bound", "label": "get_slice_bound", "shape": "dot", "size": 20, "title": "NAME: get_slice_bound\n------------------------------\nINPUTS: self, label, side\nOUTPUTS: int\n------------------------------\nDESCRIPTION: For an ordered MultiIndex, compute slice bound that corresponds to given label. Returns leftmost (one-past-the-rightmost if `side==\u0027right\u0027) position of given label. Parameters ---------- label : object or tuple of objects side : {\u0027left\u0027, \u0027right\u0027} Returns ------- int Index of label....\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays([list(\u0027abbc\u0027), list(\u0027gefd\u0027)])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.groupby", "label": "groupby", "shape": "dot", "size": 20, "title": "NAME: groupby\n------------------------------\nINPUTS: self, values\nOUTPUTS: PrettyDict[Hashable, np.ndarray]\n------------------------------\nDESCRIPTION: Group the index labels by a given array of values. Parameters ---------- values : array Values used to determine the groups. Returns ------- dict {group name -\u003e group labels}...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.holds_integer", "label": "holds_integer", "shape": "dot", "size": 20, "title": "NAME: holds_integer\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Whether the type is an integer type. .. deprecated:: 2.0.0 Use `pandas.api.types.infer_dtype` instead...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.identical", "label": "identical", "shape": "dot", "size": 20, "title": "NAME: identical\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Similar to equals, but checks that object attributes and types are also equal. Returns ------- bool If two Index objects have equal elements and same type True, otherwise False. Examples -------- \u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027]) \u003e\u003e\u003e idx2 =...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx2 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx2.identical(idx1)\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.infer_objects", "label": "infer_objects", "shape": "dot", "size": 20, "title": "NAME: infer_objects\n------------------------------\nINPUTS: self, copy\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: If we have an object dtype, try to infer a non-object dtype. Parameters ---------- copy : bool, default True Whether to make a copy in cases where no inference occurs....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.insert", "label": "insert", "shape": "dot", "size": 20, "title": "NAME: insert\n------------------------------\nINPUTS: self, loc, item\nOUTPUTS: MultiIndex\n------------------------------\nDESCRIPTION: Make new MultiIndex inserting new item at location Parameters ---------- loc : int item : tuple Must be same length as number of levels in the MultiIndex Returns ------- new_index : Index...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.intersection", "label": "intersection", "shape": "dot", "size": 20, "title": "NAME: intersection\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Form the intersection of two Index objects. This returns a new Index with elements common to the index and `other`. Parameters ---------- other : Index or array-like sort : True, False or None, default False Whether to sort the resulting...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.intersection(idx2)\nIndex([3, 4], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.is_", "label": "is_", "shape": "dot", "size": 20, "title": "NAME: is_\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: More flexible, faster check like ``is`` but that works through views. Note: this is *not* the same as ``Index.identical()``, which checks that metadata is also the same. Parameters ---------- other : object Other object to compare against. Returns ------- bool...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx1.is_(idx1.view())\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.is_boolean", "label": "is_boolean", "shape": "dot", "size": 20, "title": "NAME: is_boolean\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of booleans. .. deprecated:: 2.0.0 Use `pandas.api.types.is_bool_dtype` instead. Returns ------- bool Whether or not the Index only consists of booleans. See Also -------- is_integer : Check if the Index only consists of integers (deprecated)....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([True, False, True])\n\u003e\u003e\u003e idx.is_boolean()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.is_categorical", "label": "is_categorical", "shape": "dot", "size": 20, "title": "NAME: is_categorical\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index holds categorical data. .. deprecated:: 2.0.0 Use `isinstance(index.dtype, pd.CategoricalDtype)` instead. Returns ------- bool True if the Index is categorical. See Also -------- CategoricalIndex : Index for categorical data. is_boolean : Check if the Index only consists...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n...                 \"Watermelon\"]).astype(\"category\")\n\u003e\u003e\u003e idx.is_categorical()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.is_floating", "label": "is_floating", "shape": "dot", "size": 20, "title": "NAME: is_floating\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index is a floating type. .. deprecated:: 2.0.0 Use `pandas.api.types.is_float_dtype` instead The Index may consist of only floats, NaNs, or a mix of floats, integers, or NaNs. Returns ------- bool Whether or not the Index only consists...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n\u003e\u003e\u003e idx.is_floating()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.is_integer", "label": "is_integer", "shape": "dot", "size": 20, "title": "NAME: is_integer\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of integers. .. deprecated:: 2.0.0 Use `pandas.api.types.is_integer_dtype` instead. Returns ------- bool Whether or not the Index only consists of integers. See Also -------- is_boolean : Check if the Index only consists of booleans (deprecated)....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx.is_integer()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.is_interval", "label": "is_interval", "shape": "dot", "size": 20, "title": "NAME: is_interval\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index holds Interval objects. .. deprecated:: 2.0.0 Use `isinstance(index.dtype, pd.IntervalDtype)` instead. Returns ------- bool Whether or not the Index holds Interval objects. See Also -------- IntervalIndex : Index for Interval objects. is_boolean : Check if the Index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([pd.Interval(left=0, right=5),\n...                 pd.Interval(left=5, right=10)])\n\u003e\u003e\u003e idx.is_interval()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.is_numeric", "label": "is_numeric", "shape": "dot", "size": 20, "title": "NAME: is_numeric\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of numeric data. .. deprecated:: 2.0.0 Use `pandas.api.types.is_numeric_dtype` instead. Returns ------- bool Whether or not the Index only consists of numeric data. See Also -------- is_boolean : Check if the Index only consists of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n\u003e\u003e\u003e idx.is_numeric()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.is_object", "label": "is_object", "shape": "dot", "size": 20, "title": "NAME: is_object\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index is of the object dtype. .. deprecated:: 2.0.0 Use `pandas.api.types.is_object_dtype` instead. Returns ------- bool Whether or not the Index is of the object dtype. See Also -------- is_boolean : Check if the Index only consists of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\"Apple\", \"Mango\", \"Watermelon\"])\n\u003e\u003e\u003e idx.is_object()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.isin", "label": "isin", "shape": "dot", "size": 20, "title": "NAME: isin\n------------------------------\nINPUTS: self, values, level\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Return a boolean array where the index values are in `values`. Compute boolean array of whether each index value is found in the passed set of values. The length of the returned boolean array matches the length of the index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1,2,3])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.isna", "label": "isna", "shape": "dot", "size": 20, "title": "NAME: isna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get mapped to ``True`` values. Everything else get mapped to ``False`` values. Characters such as empty strings `\u0027\u0027`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.isna()\narray([False, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.isnull", "label": "isnull", "shape": "dot", "size": 20, "title": "NAME: isnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get mapped to ``True`` values. Everything else get mapped to ``False`` values. Characters such as empty strings `\u0027\u0027`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.isna()\narray([False, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.item", "label": "item", "shape": "dot", "size": 20, "title": "NAME: item\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the first element of the underlying data as a Python scalar. Returns ------- scalar The first element of Series or Index. Raises ------ ValueError If the data is not length = 1. Examples -------- \u003e\u003e\u003e s = pd.Series([1]) \u003e\u003e\u003e...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1])\n\u003e\u003e\u003e s.item()\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.join", "label": "join", "shape": "dot", "size": 20, "title": "NAME: join\n------------------------------\nINPUTS: self, other, how, level, return_indexers, sort\nOUTPUTS: Index | tuple[Index, npt.NDArray[np.intp] | None, npt.NDArray[np.intp] | None]\n------------------------------\nDESCRIPTION: Compute join_index and indexers to conform data structures to the new index. Parameters ---------- other : Index how : {\u0027left\u0027, \u0027right\u0027, \u0027inner\u0027, \u0027outer\u0027} level : int or level name, default None return_indexers : bool, default False sort : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx2 = pd.Index([4, 5, 6])\n\u003e\u003e\u003e idx1.join(idx2, how=\u0027outer\u0027)\nIndex([1, 2, 3, 4, 5, 6], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.map", "label": "map", "shape": "dot", "size": 20, "title": "NAME: map\n------------------------------\nINPUTS: self, mapper, na_action\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Map values using an input mapping or function. Parameters ---------- mapper : function, dict, or Series Mapping correspondence. na_action : {None, \u0027ignore\u0027} If \u0027ignore\u0027, propagate NA values, without passing them to the mapping correspondence. Returns ------- Union[Index, MultiIndex] The output...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.map({1: \u0027a\u0027, 2: \u0027b\u0027, 3: \u0027c\u0027})\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.max", "label": "max", "shape": "dot", "size": 20, "title": "NAME: max\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the maximum value of the Index. Parameters ---------- axis : int, optional For compatibility with NumPy. Only 0 or None are allowed. skipna : bool, default True Exclude NA/null values when showing the result. *args, **kwargs Additional arguments and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([3, 2, 1])\n\u003e\u003e\u003e idx.max()\n3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.memory_usage", "label": "memory_usage", "shape": "dot", "size": 20, "title": "NAME: memory_usage\n------------------------------\nINPUTS: self, deep\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Memory usage of the values. Parameters ---------- deep : bool, default False Introspect the data deeply, interrogate `object` dtypes for system-level memory consumption. Returns ------- bytes used See Also -------- numpy.ndarray.nbytes : Total bytes consumed by the elements of the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.memory_usage()\n24"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.min", "label": "min", "shape": "dot", "size": 20, "title": "NAME: min\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the minimum value of the Index. Parameters ---------- axis : {None} Dummy argument for consistency with Series. skipna : bool, default True Exclude NA/null values when showing the result. *args, **kwargs Additional arguments and keywords for compatibility with NumPy....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([3, 2, 1])\n\u003e\u003e\u003e idx.min()\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.notna", "label": "notna", "shape": "dot", "size": 20, "title": "NAME: notna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to ``True``. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values. NA values, such as None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.notna()\narray([ True,  True, False])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.notnull", "label": "notnull", "shape": "dot", "size": 20, "title": "NAME: notnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to ``True``. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values. NA values, such as None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.notna()\narray([ True,  True, False])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.nunique", "label": "nunique", "shape": "dot", "size": 20, "title": "NAME: nunique\n------------------------------\nINPUTS: self, dropna\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return number of unique elements in the object. Excludes NA values by default. Parameters ---------- dropna : bool, default True Don\u0027t include NaN in the count. Returns ------- int See Also -------- DataFrame.nunique: Method nunique for DataFrame. Series.count: Count non-NA/null...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 3, 5, 7, 7])\n\u003e\u003e\u003e s\n0    1\n1    3\n2    5\n3    7\n4    7\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.putmask", "label": "putmask", "shape": "dot", "size": 20, "title": "NAME: putmask\n------------------------------\nINPUTS: self, mask, value\nOUTPUTS: MultiIndex\n------------------------------\nDESCRIPTION: Return a new MultiIndex of the values set with the mask. Parameters ---------- mask : array like value : MultiIndex Must either be the same length as self or length one Returns ------- MultiIndex...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.ravel", "label": "ravel", "shape": "dot", "size": 20, "title": "NAME: ravel\n------------------------------\nINPUTS: self, order\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a view on self. Returns ------- Index See Also -------- numpy.ndarray.ravel : Return a flattened array. Examples -------- \u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e s.index.ravel() Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e s.index.ravel()\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.reindex", "label": "reindex", "shape": "dot", "size": 20, "title": "NAME: reindex\n------------------------------\nINPUTS: self, target, method, level, limit, tolerance\nOUTPUTS: tuple[Index, npt.NDArray[np.intp] | None]\n------------------------------\nDESCRIPTION: Create index with target\u0027s values. Parameters ---------- target : an iterable method : {None, \u0027pad\u0027/\u0027ffill\u0027, \u0027backfill\u0027/\u0027bfill\u0027, \u0027nearest\u0027}, optional * default: exact matches only. * pad / ffill: find the PREVIOUS index value if no exact match. * backfill / bfill:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.reindex([\u0027car\u0027, \u0027bike\u0027])\n(Index([\u0027car\u0027, \u0027bike\u0027], dtype=\u0027object\u0027), array([0, 1]))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.remove_unused_levels", "label": "remove_unused_levels", "shape": "dot", "size": 20, "title": "NAME: remove_unused_levels\n------------------------------\nINPUTS: self\nOUTPUTS: MultiIndex\n------------------------------\nDESCRIPTION: Create new MultiIndex from current that removes unused levels. Unused level(s) means levels that are not expressed in the labels. The resulting MultiIndex will have the same outward appearance, meaning the same .values and ordering. It will also be .equals()...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_product([range(2), list(\u0027ab\u0027)])\n\u003e\u003e\u003e mi\nMultiIndex([(0, \u0027a\u0027),\n            (0, \u0027b\u0027),\n            (1, \u0027a\u0027),\n            (1, \u0027b\u0027)],\n           )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.rename", "label": "rename", "shape": "dot", "size": 20, "title": "NAME: rename\n------------------------------\nINPUTS: self, names, level, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Set Index or MultiIndex name. Able to set new names partially and by level. Parameters ---------- names : label or list of label or dict-like for MultiIndex Name(s) to set. .. versionchanged:: 1.3.0 level : int, label or list of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx.set_names(\u0027quarter\u0027)\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027, name=\u0027quarter\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.reorder_levels", "label": "reorder_levels", "shape": "dot", "size": 20, "title": "NAME: reorder_levels\n------------------------------\nINPUTS: self, order\nOUTPUTS: MultiIndex\n------------------------------\nDESCRIPTION: Rearrange levels using input order. May not drop or duplicate levels. Parameters ---------- order : list of int or list of str List representing new level order. Reference level by number (position) or by key (label). Returns ------- MultiIndex Examples...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays([[1, 2], [3, 4]], names=[\u0027x\u0027, \u0027y\u0027])\n\u003e\u003e\u003e mi\nMultiIndex([(1, 3),\n            (2, 4)],\n           names=[\u0027x\u0027, \u0027y\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.repeat", "label": "repeat", "shape": "dot", "size": 20, "title": "NAME: repeat\n------------------------------\nINPUTS: self, repeats, axis\nOUTPUTS: MultiIndex\n------------------------------\nDESCRIPTION: Repeat elements of a MultiIndex. Returns a new MultiIndex where each element of the current MultiIndex is repeated consecutively a given number of times. Parameters ---------- repeats : int or array of ints The number of repetitions for each element....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.repeat(2)\nIndex([\u0027a\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027c\u0027, \u0027c\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.repeat([1, 2, 3])\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027c\u0027, \u0027c\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.round", "label": "round", "shape": "dot", "size": 20, "title": "NAME: round\n------------------------------\nINPUTS: self, decimals\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Round each value in the Index to the given number of decimals. Parameters ---------- decimals : int, optional Number of decimal places to round to. If decimals is negative, it specifies the number of positions to the left of the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import pandas as pd\n\u003e\u003e\u003e idx = pd.Index([10.1234, 20.5678, 30.9123, 40.4567, 50.7890])\n\u003e\u003e\u003e idx.round(decimals=2)\nIndex([10.12, 20.57, 30.91, 40.46, 50.79], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.searchsorted", "label": "searchsorted", "shape": "dot", "size": 20, "title": "NAME: searchsorted\n------------------------------\nINPUTS: self, value, side, sorter\nOUTPUTS: npt.NDArray[np.intp] | np.intp\n------------------------------\nDESCRIPTION: Find indices where elements should be inserted to maintain order. Find the indices into a sorted Index `self` such that, if the corresponding elements in `value` were inserted before the indices, the order of `self` would be preserved. .. note::...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([1, 2, 3])\n\u003e\u003e\u003e ser\n0    1\n1    2\n2    3\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.set_codes", "label": "set_codes", "shape": "dot", "size": 20, "title": "NAME: set_codes\n------------------------------\nINPUTS: self, codes, level, verify_integrity\nOUTPUTS: MultiIndex\n------------------------------\nDESCRIPTION: Set new codes on MultiIndex. Defaults to returning new index. Parameters ---------- codes : sequence or list of sequence New codes to apply. level : int, level name, or sequence of int/level names (default None) Level(s) to set (None for...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.MultiIndex.from_tuples(\n...     [(1, \"one\"), (1, \"two\"), (2, \"one\"), (2, \"two\")], names=[\"foo\", \"bar\"]\n... )\n\u003e\u003e\u003e idx\nMultiIndex([(1, \u0027one\u0027),\n    (1, \u0027two\u0027),\n    (2, \u0027one\u0027),\n    (2, \u0027two\u0027)],\n   names=[\u0027foo\u0027, \u0027bar\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.set_levels", "label": "set_levels", "shape": "dot", "size": 20, "title": "NAME: set_levels\n------------------------------\nINPUTS: self, levels, level, verify_integrity\nOUTPUTS: MultiIndex\n------------------------------\nDESCRIPTION: Set new levels on MultiIndex. Defaults to returning new index. Parameters ---------- levels : sequence or list of sequence New level(s) to apply. level : int, level name, or sequence of int/level names (default None) Level(s) to set (None for...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.MultiIndex.from_tuples(\n...     [\n...         (1, \"one\"),\n...         (1, \"two\"),\n...         (2, \"one\"),\n...         (2, \"two\"),\n...         (3, \"one\"),\n...         (3, \"two\")\n...     ],\n...     names=[\"foo\", \"bar\"]\n... )\n\u003e\u003e\u003e idx\nMultiIndex([(1, \u0027one\u0027),\n    (1, \u0027two\u0027),\n    (2, \u0027one\u0027),\n    (2, \u0027two\u0027),\n    (3, \u0027one\u0027),\n    (3, \u0027two\u0027)],\n   names=[\u0027foo\u0027, \u0027bar\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.set_names", "label": "set_names", "shape": "dot", "size": 20, "title": "NAME: set_names\n------------------------------\nINPUTS: self, names, level, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Set Index or MultiIndex name. Able to set new names partially and by level. Parameters ---------- names : label or list of label or dict-like for MultiIndex Name(s) to set. .. versionchanged:: 1.3.0 level : int, label or list of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx.set_names(\u0027quarter\u0027)\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027, name=\u0027quarter\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.shift", "label": "shift", "shape": "dot", "size": 20, "title": "NAME: shift\n------------------------------\nINPUTS: self, periods, freq\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Shift index by desired number of time frequency increments. This method is for shifting the values of datetime-like indexes by a specified time increment a given number of times. Parameters ---------- periods : int, default 1 Number of periods (or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e month_starts = pd.date_range(\u00271/1/2011\u0027, periods=5, freq=\u0027MS\u0027)\n\u003e\u003e\u003e month_starts\nDatetimeIndex([\u00272011-01-01\u0027, \u00272011-02-01\u0027, \u00272011-03-01\u0027, \u00272011-04-01\u0027,\n               \u00272011-05-01\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=\u0027MS\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.slice_indexer", "label": "slice_indexer", "shape": "dot", "size": 20, "title": "NAME: slice_indexer\n------------------------------\nINPUTS: self, start, end, step\nOUTPUTS: slice\n------------------------------\nDESCRIPTION: Compute the slice indexer for input labels and step. Index needs to be ordered and unique. Parameters ---------- start : label, default None If None, defaults to the beginning. end : label, default None If None, defaults to the end....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abcd\u0027))\n\u003e\u003e\u003e idx.slice_indexer(start=\u0027b\u0027, end=\u0027c\u0027)\nslice(1, 3, None)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.slice_locs", "label": "slice_locs", "shape": "dot", "size": 20, "title": "NAME: slice_locs\n------------------------------\nINPUTS: self, start, end, step\nOUTPUTS: tuple[int, int]\n------------------------------\nDESCRIPTION: For an ordered MultiIndex, compute the slice locations for input labels. The input labels can be tuples representing partial levels, e.g. for a MultiIndex with 3 levels, you can pass a single value (corresponding to the first level), or a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays([list(\u0027abbd\u0027), list(\u0027deff\u0027)],\n...                                names=[\u0027A\u0027, \u0027B\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.sort", "label": "sort", "shape": "dot", "size": 20, "title": "NAME: sort\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Use sort_values instead....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.sort_values", "label": "sort_values", "shape": "dot", "size": 20, "title": "NAME: sort_values\n------------------------------\nINPUTS: self, return_indexer, ascending, na_position, key\nOUTPUTS: Self | tuple[Self, np.ndarray]\n------------------------------\nDESCRIPTION: Return a sorted copy of the index. Return a sorted copy of the index, and optionally return the indices that sorted the index itself. Parameters ---------- return_indexer : bool, default False Should the indices that would sort the index be...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([10, 100, 1, 1000])\n\u003e\u003e\u003e idx\nIndex([10, 100, 1, 1000], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.sortlevel", "label": "sortlevel", "shape": "dot", "size": 20, "title": "NAME: sortlevel\n------------------------------\nINPUTS: self, level, ascending, sort_remaining, na_position\nOUTPUTS: tuple[MultiIndex, npt.NDArray[np.intp]]\n------------------------------\nDESCRIPTION: Sort MultiIndex at the requested level. The result will respect the original ordering of the associated factor at that level. Parameters ---------- level : list-like, int or str, default 0 If a string is given, must be a name of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays([[0, 0], [2, 1]])\n\u003e\u003e\u003e mi\nMultiIndex([(0, 2),\n            (0, 1)],\n           )"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.MultiIndex.str", "label": "str", "shape": "dot", "size": 20, "title": "NAME: str\n------------------------------\nINPUTS: data\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Vectorized string functions for Series and Index. NAs stay NA unless handled otherwise by a particular method. Patterned after Python\u0027s string methods, with some inspiration from R\u0027s stringr package. Examples -------- \u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"]) \u003e\u003e\u003e s 0 A_Str_Series dtype:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"])\n\u003e\u003e\u003e s\n0    A_Str_Series\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.swaplevel", "label": "swaplevel", "shape": "dot", "size": 20, "title": "NAME: swaplevel\n------------------------------\nINPUTS: self, i, j\nOUTPUTS: MultiIndex\n------------------------------\nDESCRIPTION: Swap level i with level j. Calling this method does not change the ordering of the values. Parameters ---------- i : int, str, default -2 First level of index to be swapped. Can pass level name as string. Type of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex(levels=[[\u0027a\u0027, \u0027b\u0027], [\u0027bb\u0027, \u0027aa\u0027]],\n...                    codes=[[0, 0, 1, 1], [0, 1, 0, 1]])\n\u003e\u003e\u003e mi\nMultiIndex([(\u0027a\u0027, \u0027bb\u0027),\n            (\u0027a\u0027, \u0027aa\u0027),\n            (\u0027b\u0027, \u0027bb\u0027),\n            (\u0027b\u0027, \u0027aa\u0027)],\n           )\n\u003e\u003e\u003e mi.swaplevel(0, 1)\nMultiIndex([(\u0027bb\u0027, \u0027a\u0027),\n            (\u0027aa\u0027, \u0027a\u0027),\n            (\u0027bb\u0027, \u0027b\u0027),\n            (\u0027aa\u0027, \u0027b\u0027)],\n           )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.symmetric_difference", "label": "symmetric_difference", "shape": "dot", "size": 20, "title": "NAME: symmetric_difference\n------------------------------\nINPUTS: self, other, result_name, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Compute the symmetric difference of two Index objects. Parameters ---------- other : Index or array-like result_name : str sort : bool or None, default None Whether to sort the resulting index. By default, the values are attempted to be sorted,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([2, 3, 4, 5])\n\u003e\u003e\u003e idx1.symmetric_difference(idx2)\nIndex([1, 5], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.take", "label": "take", "shape": "dot", "size": 20, "title": "NAME: take\n------------------------------\nINPUTS: self, indices, axis, allow_fill, fill_value, kwargs\nOUTPUTS: MultiIndex\n------------------------------\nDESCRIPTION: Return a new MultiIndex of the values selected by the indices. For internal compatibility with numpy arrays. Parameters ---------- indices : array-like Indices to be taken. axis : int, optional The axis over which to select values, always 0. allow_fill...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.take([2, 2, 1, 2])\nIndex([\u0027c\u0027, \u0027c\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.to_flat_index", "label": "to_flat_index", "shape": "dot", "size": 20, "title": "NAME: to_flat_index\n------------------------------\nINPUTS: self\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Convert a MultiIndex to an Index of Tuples containing the level values. Returns ------- pd.Index Index with the MultiIndex data represented in Tuples. See Also -------- MultiIndex.from_tuples : Convert flat index back to MultiIndex. Notes ----- This method will simply...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.MultiIndex.from_product(\n...     [[\u0027foo\u0027, \u0027bar\u0027], [\u0027baz\u0027, \u0027qux\u0027]],\n...     names=[\u0027a\u0027, \u0027b\u0027])\n\u003e\u003e\u003e index.to_flat_index()\nIndex([(\u0027foo\u0027, \u0027baz\u0027), (\u0027foo\u0027, \u0027qux\u0027),\n       (\u0027bar\u0027, \u0027baz\u0027), (\u0027bar\u0027, \u0027qux\u0027)],\n      dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.to_frame", "label": "to_frame", "shape": "dot", "size": 20, "title": "NAME: to_frame\n------------------------------\nINPUTS: self, index, name, allow_duplicates\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Create a DataFrame with the levels of the MultiIndex as columns. Column ordering is determined by the DataFrame constructor with data as a dict. Parameters ---------- index : bool, default True Set the index of the returned DataFrame as the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays([[\u0027a\u0027, \u0027b\u0027], [\u0027c\u0027, \u0027d\u0027]])\n\u003e\u003e\u003e mi\nMultiIndex([(\u0027a\u0027, \u0027c\u0027),\n            (\u0027b\u0027, \u0027d\u0027)],\n           )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.to_list", "label": "to_list", "shape": "dot", "size": 20, "title": "NAME: to_list\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list See Also -------- numpy.ndarray.tolist : Return the array as an...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.to_list()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.to_numpy", "label": "to_numpy", "shape": "dot", "size": 20, "title": "NAME: to_numpy\n------------------------------\nINPUTS: self, dtype, copy, na_value, kwargs\nOUTPUTS: np.ndarray\n------------------------------\nDESCRIPTION: A NumPy ndarray representing the values in this Series or Index. Parameters ---------- dtype : str or numpy.dtype, optional The dtype to pass to :meth:`numpy.asarray`. copy : bool, default False Whether to ensure that the returned value is not a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series(pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027]))\n\u003e\u003e\u003e ser.to_numpy()\narray([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.to_series", "label": "to_series", "shape": "dot", "size": 20, "title": "NAME: to_series\n------------------------------\nINPUTS: self, index, name\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Create a Series with both index and values equal to the index keys. Useful with map for returning an indexer based on an index. Parameters ---------- index : Index, optional Index of resulting Series. If None, defaults to original index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027Ant\u0027, \u0027Bear\u0027, \u0027Cow\u0027], name=\u0027animal\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.tolist", "label": "tolist", "shape": "dot", "size": 20, "title": "NAME: tolist\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list See Also -------- numpy.ndarray.tolist : Return the array as an...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.to_list()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.transpose", "label": "transpose", "shape": "dot", "size": 20, "title": "NAME: transpose\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return the transpose, which is by definition self. Returns ------- %(klass)s...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.truncate", "label": "truncate", "shape": "dot", "size": 20, "title": "NAME: truncate\n------------------------------\nINPUTS: self, before, after\nOUTPUTS: MultiIndex\n------------------------------\nDESCRIPTION: Slice index between two labels / tuples, return new MultiIndex. Parameters ---------- before : label or tuple, can be partial. Default None None defaults to start. after : label or tuple, can be partial. Default None None defaults to end....\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays([[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], [\u0027x\u0027, \u0027y\u0027, \u0027z\u0027]])\n\u003e\u003e\u003e mi\nMultiIndex([(\u0027a\u0027, \u0027x\u0027), (\u0027b\u0027, \u0027y\u0027), (\u0027c\u0027, \u0027z\u0027)],\n           )\n\u003e\u003e\u003e mi.truncate(before=\u0027a\u0027, after=\u0027b\u0027)\nMultiIndex([(\u0027a\u0027, \u0027x\u0027), (\u0027b\u0027, \u0027y\u0027)],\n           )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.union", "label": "union", "shape": "dot", "size": 20, "title": "NAME: union\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Form the union of two Index objects. If the Index objects are incompatible, both Index objects will be cast to dtype(\u0027object\u0027) first. Parameters ---------- other : Index or array-like sort : bool or None, default None Whether to sort the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.union(idx2)\nIndex([1, 2, 3, 4, 5, 6], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.unique", "label": "unique", "shape": "dot", "size": 20, "title": "NAME: unique\n------------------------------\nINPUTS: self, level\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return unique values in the index. Unique values are returned in order of appearance, this does NOT sort. Parameters ---------- level : int or hashable, optional Only return values from specified level (for MultiIndex). If int, gets the level by...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 1, 2, 3, 3])\n\u003e\u003e\u003e idx.unique()\nIndex([1, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.value_counts", "label": "value_counts", "shape": "dot", "size": 20, "title": "NAME: value_counts\n------------------------------\nINPUTS: self, normalize, sort, ascending, bins, dropna\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return a Series containing counts of unique values. The resulting object will be in descending order so that the first element is the most frequently-occurring element. Excludes NA values by default. Parameters ---------- normalize : bool, default False If True...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([3, 1, 2, 3, 4, np.nan])\n\u003e\u003e\u003e index.value_counts()\n3.0    2\n1.0    1\n2.0    1\n4.0    1\nName: count, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.view", "label": "view", "shape": "dot", "size": 20, "title": "NAME: view\n------------------------------\nINPUTS: self, cls\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: this is defined as a copy with the same identity...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.MultiIndex.where", "label": "where", "shape": "dot", "size": 20, "title": "NAME: where\n------------------------------\nINPUTS: self, cond, other\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Replace values where the condition is False. The replacement is taken from other. Parameters ---------- cond : bool array-like with the same length as self Condition to select the values on. other : scalar, or array-like, default None Replacement if...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.where(idx.isin([\u0027car\u0027, \u0027train\u0027]), \u0027other\u0027)\nIndex([\u0027car\u0027, \u0027other\u0027, \u0027train\u0027, \u0027other\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Period.now", "label": "now", "shape": "dot", "size": 20, "title": "NAME: now\n------------------------------\nINPUTS: freq\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the period of now\u0027s date. Parameters ---------- freq : str, BaseOffset Frequency to use for the returned period. Examples -------- \u003e\u003e\u003e pd.Period.now(\u0027h\u0027) # doctest: +SKIP Period(\u00272023-06-12 11:00\u0027, \u0027h\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Period.now(\u0027h\u0027)  # doctest: +SKIP\nPeriod(\u00272023-06-12 11:00\u0027, \u0027h\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodDtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: \nOUTPUTS: type_t[PeriodArray]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodDtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: PeriodDtype\n------------------------------\nDESCRIPTION: Strict construction from a string, raise a TypeError if not possible...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodDtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodDtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Return a boolean if we if the passed type is an actual dtype that we can match (via string or type)...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodDtype.reset_cache", "label": "reset_cache", "shape": "dot", "size": 20, "title": "NAME: reset_cache\n------------------------------\nINPUTS: \nOUTPUTS: None\n------------------------------\nDESCRIPTION: clear the cache...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.PeriodDtype.type", "label": "type", "shape": "dot", "size": 20, "title": "NAME: type\n------------------------------\nINPUTS: value, freq, ordinal, year, month, quarter, day, hour, minute, second\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Represents a period of time. Parameters ---------- value : Period, str, datetime, date or pandas.Timestamp, default None The time period represented (e.g., \u00274Q2005\u0027). This represents neither the start or the end of the period, but rather the entire period itself....\n\n\nEXAMPLE:\n\u003e\u003e\u003e period = pd.Period(\u00272012-1-1\u0027, freq=\u0027D\u0027)\n\u003e\u003e\u003e period\nPeriod(\u00272012-01-01\u0027, \u0027D\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.all", "label": "all", "shape": "dot", "size": 20, "title": "NAME: all\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return whether all elements are Truthy. Parameters ---------- *args Required for compatibility with numpy. **kwargs Required for compatibility with numpy. Returns ------- bool or array-like (if axis is specified) A single element array-like may be converted to bool. See Also...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Index([1, 2, 3]).all()\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.any", "label": "any", "shape": "dot", "size": 20, "title": "NAME: any\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return whether any element is Truthy. Parameters ---------- *args Required for compatibility with numpy. **kwargs Required for compatibility with numpy. Returns ------- bool or array-like (if axis is specified) A single element array-like may be converted to bool. See Also...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([0, 1, 2])\n\u003e\u003e\u003e index.any()\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.append", "label": "append", "shape": "dot", "size": 20, "title": "NAME: append\n------------------------------\nINPUTS: self, other\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Append a collection of Index options together. Parameters ---------- other : Index or list/tuple of indices Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([1, 2, 3]) \u003e\u003e\u003e idx.append(pd.Index([4])) Index([1, 2, 3, 4], dtype=\u0027int64\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.append(pd.Index([4]))\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.argmax", "label": "argmax", "shape": "dot", "size": 20, "title": "NAME: argmax\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the largest value in the Series. If the maximum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.argmin", "label": "argmin", "shape": "dot", "size": 20, "title": "NAME: argmin\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the smallest value in the Series. If the minimum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.argsort", "label": "argsort", "shape": "dot", "size": 20, "title": "NAME: argsort\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Return the integer indices that would sort the index. Parameters ---------- *args Passed to `numpy.ndarray.argsort`. **kwargs Passed to `numpy.ndarray.argsort`. Returns ------- np.ndarray[np.intp] Integer indices that would sort the index if used as an indexer. See Also -------- numpy.argsort : Similar...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027b\u0027, \u0027a\u0027, \u0027d\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027b\u0027, \u0027a\u0027, \u0027d\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.asfreq", "label": "asfreq", "shape": "dot", "size": 20, "title": "NAME: asfreq\n------------------------------\nINPUTS: self, freq, how\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Convert the PeriodArray to the specified frequency `freq`. Equivalent to applying :meth:`pandas.Period.asfreq` with the given arguments to each :class:`~pandas.Period` in this PeriodArray. Parameters ---------- freq : str A frequency. how : str {\u0027E\u0027, \u0027S\u0027}, default \u0027E\u0027 Whether the elements should...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pidx = pd.period_range(\u00272010-01-01\u0027, \u00272015-01-01\u0027, freq=\u0027Y\u0027)\n\u003e\u003e\u003e pidx\nPeriodIndex([\u00272010\u0027, \u00272011\u0027, \u00272012\u0027, \u00272013\u0027, \u00272014\u0027, \u00272015\u0027],\ndtype=\u0027period[Y-DEC]\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.asof", "label": "asof", "shape": "dot", "size": 20, "title": "NAME: asof\n------------------------------\nINPUTS: self, label\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the label from the index, or, if not present, the previous one. Assuming that the index is sorted, return the passed index label if it is in the index, or return the previous index label if the passed one...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u00272013-12-31\u0027, \u00272014-01-02\u0027, \u00272014-01-03\u0027])\n\u003e\u003e\u003e idx.asof(\u00272014-01-01\u0027)\n\u00272013-12-31\u0027"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.asof_locs", "label": "asof_locs", "shape": "dot", "size": 20, "title": "NAME: asof_locs\n------------------------------\nINPUTS: self, where, mask\nOUTPUTS: np.ndarray\n------------------------------\nDESCRIPTION: where : array of timestamps mask : np.ndarray[bool] Array of booleans where data is not NA....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.astype", "label": "astype", "shape": "dot", "size": 20, "title": "NAME: astype\n------------------------------\nINPUTS: self, dtype, copy\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Create an Index with values cast to dtypes. The class of a new Index is determined by dtype. When conversion is impossible, a TypeError exception is raised. Parameters ---------- dtype : numpy dtype or pandas type Note that any signed...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx.astype(\u0027float\u0027)\nIndex([1.0, 2.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.copy", "label": "copy", "shape": "dot", "size": 20, "title": "NAME: copy\n------------------------------\nINPUTS: self, name, deep\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make a copy of this object. Name is set on the new object. Parameters ---------- name : Label, optional Set name for new object. deep : bool, default False Returns ------- Index Index refer to new object which is a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e new_idx = idx.copy()\n\u003e\u003e\u003e idx is new_idx\nFalse"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.delete", "label": "delete", "shape": "dot", "size": 20, "title": "NAME: delete\n------------------------------\nINPUTS: self, loc\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make new Index with passed location(-s) deleted. Parameters ---------- loc : int or list of int Location of item(-s) which will be deleted. Use a list of locations to delete more than one value at the same time. Returns -------...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.delete(1)\nIndex([\u0027a\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.diff", "label": "diff", "shape": "dot", "size": 20, "title": "NAME: diff\n------------------------------\nINPUTS: self, periods\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Computes the difference between consecutive values in the Index object. If periods is greater than 1, computes the difference between values that are `periods` number of positions apart. Parameters ---------- periods : int, optional The number of positions between the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import pandas as pd\n\u003e\u003e\u003e idx = pd.Index([10, 20, 30, 40, 50])\n\u003e\u003e\u003e idx.diff()\nIndex([nan, 10.0, 10.0, 10.0, 10.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.difference", "label": "difference", "shape": "dot", "size": 20, "title": "NAME: difference\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a new Index with elements of index not in `other`. This is the set difference of two Index objects. Parameters ---------- other : Index or array-like sort : bool or None, default None Whether to sort the resulting index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([2, 1, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.difference(idx2)\nIndex([1, 2], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx1.difference(idx2, sort=False)\nIndex([2, 1], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.drop", "label": "drop", "shape": "dot", "size": 20, "title": "NAME: drop\n------------------------------\nINPUTS: self, labels, errors\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Make new Index with passed list of labels deleted. Parameters ---------- labels : array-like or scalar errors : {\u0027ignore\u0027, \u0027raise\u0027}, default \u0027raise\u0027 If \u0027ignore\u0027, suppress error and existing labels are dropped. Returns ------- Index Will be same type as self,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.drop([\u0027a\u0027])\nIndex([\u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.drop_duplicates", "label": "drop_duplicates", "shape": "dot", "size": 20, "title": "NAME: drop_duplicates\n------------------------------\nINPUTS: self, keep\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return Index with duplicate values removed. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, ``False``}, default \u0027first\u0027 - \u0027first\u0027 : Drop duplicates except for the first occurrence. - \u0027last\u0027 : Drop duplicates except for the last occurrence. - ``False`` : Drop all...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027lama\u0027, \u0027cow\u0027, \u0027lama\u0027, \u0027beetle\u0027, \u0027lama\u0027, \u0027hippo\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.droplevel", "label": "droplevel", "shape": "dot", "size": 20, "title": "NAME: droplevel\n------------------------------\nINPUTS: self, level\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return index with requested level(s) removed. If resulting index has only 1 level left, the result will be of Index type, not MultiIndex. The original index is not modified inplace. Parameters ---------- level : int, str, or list-like, default 0...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays(\n... [[1, 2], [3, 4], [5, 6]], names=[\u0027x\u0027, \u0027y\u0027, \u0027z\u0027])\n\u003e\u003e\u003e mi\nMultiIndex([(1, 3, 5),\n            (2, 4, 6)],\n           names=[\u0027x\u0027, \u0027y\u0027, \u0027z\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.dropna", "label": "dropna", "shape": "dot", "size": 20, "title": "NAME: dropna\n------------------------------\nINPUTS: self, how\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return Index without NA/NaN values. Parameters ---------- how : {\u0027any\u0027, \u0027all\u0027}, default \u0027any\u0027 If the Index is a MultiIndex, drop the value when any or all levels are NaN. Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([1, np.nan, 3])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, np.nan, 3])\n\u003e\u003e\u003e idx.dropna()\nIndex([1.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.duplicated", "label": "duplicated", "shape": "dot", "size": 20, "title": "NAME: duplicated\n------------------------------\nINPUTS: self, keep\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Indicate duplicate index values. Duplicated values are indicated as ``True`` values in the resulting array. Either all duplicates, all except the first, or all except the last occurrence of duplicates can be indicated. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, False},...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027lama\u0027, \u0027cow\u0027, \u0027lama\u0027, \u0027beetle\u0027, \u0027lama\u0027])\n\u003e\u003e\u003e idx.duplicated()\narray([False, False,  True, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.equals", "label": "equals", "shape": "dot", "size": 20, "title": "NAME: equals\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Determines if two Index objects contain the same elements....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.factorize", "label": "factorize", "shape": "dot", "size": 20, "title": "NAME: factorize\n------------------------------\nINPUTS: self, sort, use_na_sentinel\nOUTPUTS: tuple[npt.NDArray[np.intp], Index]\n------------------------------\nDESCRIPTION: Encode the object as an enumerated type or categorical variable. This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct values. `factorize` is available as both a top-level function :func:`pandas.factorize`, and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e codes, uniques = pd.factorize(np.array([\u0027b\u0027, \u0027b\u0027, \u0027a\u0027, \u0027c\u0027, \u0027b\u0027], dtype=\"O\"))\n\u003e\u003e\u003e codes\narray([0, 0, 1, 2, 0])\n\u003e\u003e\u003e uniques\narray([\u0027b\u0027, \u0027a\u0027, \u0027c\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.fillna", "label": "fillna", "shape": "dot", "size": 20, "title": "NAME: fillna\n------------------------------\nINPUTS: self, value, downcast\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Fill NA/NaN values with the specified value. Parameters ---------- value : scalar Scalar value to use to fill holes (e.g. 0). This value cannot be a list-likes. downcast : dict, default is None A dict of item-\u003edtype of what to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([np.nan, np.nan, 3])\n\u003e\u003e\u003e idx.fillna(0)\nIndex([0.0, 0.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.format", "label": "format", "shape": "dot", "size": 20, "title": "NAME: format\n------------------------------\nINPUTS: self, name, formatter, na_rep, date_format\nOUTPUTS: list[str]\n------------------------------\nDESCRIPTION: Render a string representation of the Index....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.from_fields", "label": "from_fields", "shape": "dot", "size": 20, "title": "NAME: from_fields\n------------------------------\nINPUTS: year, quarter, month, day, hour, minute, second, freq\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.from_ordinals", "label": "from_ordinals", "shape": "dot", "size": 20, "title": "NAME: from_ordinals\n------------------------------\nINPUTS: ordinals, freq, name\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.get_indexer", "label": "get_indexer", "shape": "dot", "size": 20, "title": "NAME: get_indexer\n------------------------------\nINPUTS: self, target, method, limit, tolerance\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Compute indexer and mask for new index given the current index. The indexer should be then used as an input to ndarray.take to align the current data to the new index. Parameters ---------- target : Index method : {None, \u0027pad\u0027/\u0027ffill\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([\u0027c\u0027, \u0027a\u0027, \u0027b\u0027])\n\u003e\u003e\u003e index.get_indexer([\u0027a\u0027, \u0027b\u0027, \u0027x\u0027])\narray([ 1,  2, -1])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.get_indexer_for", "label": "get_indexer_for", "shape": "dot", "size": 20, "title": "NAME: get_indexer_for\n------------------------------\nINPUTS: self, target\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Guaranteed return of an indexer even when non-unique. This dispatches to get_indexer or get_indexer_non_unique as appropriate. Returns ------- np.ndarray[np.intp] List of indices. Examples -------- \u003e\u003e\u003e idx = pd.Index([np.nan, \u0027var1\u0027, np.nan]) \u003e\u003e\u003e idx.get_indexer_for([np.nan]) array([0, 2])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([np.nan, \u0027var1\u0027, np.nan])\n\u003e\u003e\u003e idx.get_indexer_for([np.nan])\narray([0, 2])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.get_indexer_non_unique", "label": "get_indexer_non_unique", "shape": "dot", "size": 20, "title": "NAME: get_indexer_non_unique\n------------------------------\nINPUTS: self, target\nOUTPUTS: tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]\n------------------------------\nDESCRIPTION: Compute indexer and mask for new index given the current index. The indexer should be then used as an input to ndarray.take to align the current data to the new index. Parameters ---------- target : Index Returns ------- indexer :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([\u0027c\u0027, \u0027b\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027])\n\u003e\u003e\u003e index.get_indexer_non_unique([\u0027b\u0027, \u0027b\u0027])\n(array([1, 3, 4, 1, 3, 4]), array([], dtype=int64))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.get_level_values", "label": "get_level_values", "shape": "dot", "size": 20, "title": "NAME: get_level_values\n------------------------------\nINPUTS: self, level\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Return an Index of values for requested level. This is primarily useful to get an individual level of values from a MultiIndex, but is provided on Index as well for compatibility. Parameters ---------- level : int or str It is...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abc\u0027))\n\u003e\u003e\u003e idx\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.get_loc", "label": "get_loc", "shape": "dot", "size": 20, "title": "NAME: get_loc\n------------------------------\nINPUTS: self, key\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Get integer location for requested label. Parameters ---------- key : Period, NaT, str, or datetime String or datetime key must be parsable as Period. Returns ------- loc : int or ndarray[int64] Raises ------ KeyError Key is not present in the...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.get_slice_bound", "label": "get_slice_bound", "shape": "dot", "size": 20, "title": "NAME: get_slice_bound\n------------------------------\nINPUTS: self, label, side\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Calculate slice bound that corresponds to given label. Returns leftmost (one-past-the-rightmost if ``side==\u0027right\u0027``) position of given label. Parameters ---------- label : object side : {\u0027left\u0027, \u0027right\u0027} Returns ------- int Index of label. See Also -------- Index.get_loc : Get integer location,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.RangeIndex(5)\n\u003e\u003e\u003e idx.get_slice_bound(3, \u0027left\u0027)\n3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.groupby", "label": "groupby", "shape": "dot", "size": 20, "title": "NAME: groupby\n------------------------------\nINPUTS: self, values\nOUTPUTS: PrettyDict[Hashable, np.ndarray]\n------------------------------\nDESCRIPTION: Group the index labels by a given array of values. Parameters ---------- values : array Values used to determine the groups. Returns ------- dict {group name -\u003e group labels}...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.holds_integer", "label": "holds_integer", "shape": "dot", "size": 20, "title": "NAME: holds_integer\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Whether the type is an integer type. .. deprecated:: 2.0.0 Use `pandas.api.types.infer_dtype` instead...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.identical", "label": "identical", "shape": "dot", "size": 20, "title": "NAME: identical\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Similar to equals, but checks that object attributes and types are also equal. Returns ------- bool If two Index objects have equal elements and same type True, otherwise False. Examples -------- \u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027]) \u003e\u003e\u003e idx2 =...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx2 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx2.identical(idx1)\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.infer_objects", "label": "infer_objects", "shape": "dot", "size": 20, "title": "NAME: infer_objects\n------------------------------\nINPUTS: self, copy\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: If we have an object dtype, try to infer a non-object dtype. Parameters ---------- copy : bool, default True Whether to make a copy in cases where no inference occurs....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.insert", "label": "insert", "shape": "dot", "size": 20, "title": "NAME: insert\n------------------------------\nINPUTS: self, loc, item\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Make new Index inserting new item at location. Follows Python numpy.insert semantics for negative values. Parameters ---------- loc : int item : object Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e idx.insert(1, \u0027x\u0027) Index([\u0027a\u0027, \u0027x\u0027, \u0027b\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.insert(1, \u0027x\u0027)\nIndex([\u0027a\u0027, \u0027x\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.intersection", "label": "intersection", "shape": "dot", "size": 20, "title": "NAME: intersection\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Form the intersection of two Index objects. This returns a new Index with elements common to the index and `other`. Parameters ---------- other : Index or array-like sort : True, False or None, default False Whether to sort the resulting...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.intersection(idx2)\nIndex([3, 4], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.is_", "label": "is_", "shape": "dot", "size": 20, "title": "NAME: is_\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: More flexible, faster check like ``is`` but that works through views. Note: this is *not* the same as ``Index.identical()``, which checks that metadata is also the same. Parameters ---------- other : object Other object to compare against. Returns ------- bool...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx1.is_(idx1.view())\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.is_boolean", "label": "is_boolean", "shape": "dot", "size": 20, "title": "NAME: is_boolean\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of booleans. .. deprecated:: 2.0.0 Use `pandas.api.types.is_bool_dtype` instead. Returns ------- bool Whether or not the Index only consists of booleans. See Also -------- is_integer : Check if the Index only consists of integers (deprecated)....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([True, False, True])\n\u003e\u003e\u003e idx.is_boolean()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.is_categorical", "label": "is_categorical", "shape": "dot", "size": 20, "title": "NAME: is_categorical\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index holds categorical data. .. deprecated:: 2.0.0 Use `isinstance(index.dtype, pd.CategoricalDtype)` instead. Returns ------- bool True if the Index is categorical. See Also -------- CategoricalIndex : Index for categorical data. is_boolean : Check if the Index only consists...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n...                 \"Watermelon\"]).astype(\"category\")\n\u003e\u003e\u003e idx.is_categorical()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.is_floating", "label": "is_floating", "shape": "dot", "size": 20, "title": "NAME: is_floating\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index is a floating type. .. deprecated:: 2.0.0 Use `pandas.api.types.is_float_dtype` instead The Index may consist of only floats, NaNs, or a mix of floats, integers, or NaNs. Returns ------- bool Whether or not the Index only consists...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n\u003e\u003e\u003e idx.is_floating()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.is_integer", "label": "is_integer", "shape": "dot", "size": 20, "title": "NAME: is_integer\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of integers. .. deprecated:: 2.0.0 Use `pandas.api.types.is_integer_dtype` instead. Returns ------- bool Whether or not the Index only consists of integers. See Also -------- is_boolean : Check if the Index only consists of booleans (deprecated)....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx.is_integer()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.is_interval", "label": "is_interval", "shape": "dot", "size": 20, "title": "NAME: is_interval\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index holds Interval objects. .. deprecated:: 2.0.0 Use `isinstance(index.dtype, pd.IntervalDtype)` instead. Returns ------- bool Whether or not the Index holds Interval objects. See Also -------- IntervalIndex : Index for Interval objects. is_boolean : Check if the Index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([pd.Interval(left=0, right=5),\n...                 pd.Interval(left=5, right=10)])\n\u003e\u003e\u003e idx.is_interval()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.is_numeric", "label": "is_numeric", "shape": "dot", "size": 20, "title": "NAME: is_numeric\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of numeric data. .. deprecated:: 2.0.0 Use `pandas.api.types.is_numeric_dtype` instead. Returns ------- bool Whether or not the Index only consists of numeric data. See Also -------- is_boolean : Check if the Index only consists of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n\u003e\u003e\u003e idx.is_numeric()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.is_object", "label": "is_object", "shape": "dot", "size": 20, "title": "NAME: is_object\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index is of the object dtype. .. deprecated:: 2.0.0 Use `pandas.api.types.is_object_dtype` instead. Returns ------- bool Whether or not the Index is of the object dtype. See Also -------- is_boolean : Check if the Index only consists of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\"Apple\", \"Mango\", \"Watermelon\"])\n\u003e\u003e\u003e idx.is_object()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.isin", "label": "isin", "shape": "dot", "size": 20, "title": "NAME: isin\n------------------------------\nINPUTS: self, values, level\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Return a boolean array where the index values are in `values`. Compute boolean array of whether each index value is found in the passed set of values. The length of the returned boolean array matches the length of the index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1,2,3])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.isna", "label": "isna", "shape": "dot", "size": 20, "title": "NAME: isna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get mapped to ``True`` values. Everything else get mapped to ``False`` values. Characters such as empty strings `\u0027\u0027`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.isna()\narray([False, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.isnull", "label": "isnull", "shape": "dot", "size": 20, "title": "NAME: isnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get mapped to ``True`` values. Everything else get mapped to ``False`` values. Characters such as empty strings `\u0027\u0027`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.isna()\narray([False, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.item", "label": "item", "shape": "dot", "size": 20, "title": "NAME: item\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the first element of the underlying data as a Python scalar. Returns ------- scalar The first element of Series or Index. Raises ------ ValueError If the data is not length = 1. Examples -------- \u003e\u003e\u003e s = pd.Series([1]) \u003e\u003e\u003e...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1])\n\u003e\u003e\u003e s.item()\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.join", "label": "join", "shape": "dot", "size": 20, "title": "NAME: join\n------------------------------\nINPUTS: self, other, how, level, return_indexers, sort\nOUTPUTS: Index | tuple[Index, npt.NDArray[np.intp] | None, npt.NDArray[np.intp] | None]\n------------------------------\nDESCRIPTION: Compute join_index and indexers to conform data structures to the new index. Parameters ---------- other : Index how : {\u0027left\u0027, \u0027right\u0027, \u0027inner\u0027, \u0027outer\u0027} level : int or level name, default None return_indexers : bool, default False sort : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx2 = pd.Index([4, 5, 6])\n\u003e\u003e\u003e idx1.join(idx2, how=\u0027outer\u0027)\nIndex([1, 2, 3, 4, 5, 6], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.map", "label": "map", "shape": "dot", "size": 20, "title": "NAME: map\n------------------------------\nINPUTS: self, mapper, na_action\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Map values using an input mapping or function. Parameters ---------- mapper : function, dict, or Series Mapping correspondence. na_action : {None, \u0027ignore\u0027} If \u0027ignore\u0027, propagate NA values, without passing them to the mapping correspondence. Returns ------- Union[Index, MultiIndex] The output...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.map({1: \u0027a\u0027, 2: \u0027b\u0027, 3: \u0027c\u0027})\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.max", "label": "max", "shape": "dot", "size": 20, "title": "NAME: max\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the maximum value of the Index. Parameters ---------- axis : int, optional For compatibility with NumPy. Only 0 or None are allowed. skipna : bool, default True Exclude NA/null values when showing the result. *args, **kwargs Additional arguments and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([3, 2, 1])\n\u003e\u003e\u003e idx.max()\n3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.mean", "label": "mean", "shape": "dot", "size": 20, "title": "NAME: mean\n------------------------------\nINPUTS: self, skipna, axis\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the mean value of the Array. Parameters ---------- skipna : bool, default True Whether to ignore any NaT elements. axis : int, optional, default 0 Returns ------- scalar Timestamp or Timedelta. See Also -------- numpy.ndarray.mean : Returns the average...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.date_range(\u00272001-01-01 00:00\u0027, periods=3)\n\u003e\u003e\u003e idx\nDatetimeIndex([\u00272001-01-01\u0027, \u00272001-01-02\u0027, \u00272001-01-03\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=\u0027D\u0027)\n\u003e\u003e\u003e idx.mean()\nTimestamp(\u00272001-01-02 00:00:00\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.memory_usage", "label": "memory_usage", "shape": "dot", "size": 20, "title": "NAME: memory_usage\n------------------------------\nINPUTS: self, deep\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Memory usage of the values. Parameters ---------- deep : bool, default False Introspect the data deeply, interrogate `object` dtypes for system-level memory consumption. Returns ------- bytes used See Also -------- numpy.ndarray.nbytes : Total bytes consumed by the elements of the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.memory_usage()\n24"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.min", "label": "min", "shape": "dot", "size": 20, "title": "NAME: min\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the minimum value of the Index. Parameters ---------- axis : {None} Dummy argument for consistency with Series. skipna : bool, default True Exclude NA/null values when showing the result. *args, **kwargs Additional arguments and keywords for compatibility with NumPy....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([3, 2, 1])\n\u003e\u003e\u003e idx.min()\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.notna", "label": "notna", "shape": "dot", "size": 20, "title": "NAME: notna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to ``True``. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values. NA values, such as None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.notna()\narray([ True,  True, False])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.notnull", "label": "notnull", "shape": "dot", "size": 20, "title": "NAME: notnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to ``True``. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values. NA values, such as None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.notna()\narray([ True,  True, False])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.nunique", "label": "nunique", "shape": "dot", "size": 20, "title": "NAME: nunique\n------------------------------\nINPUTS: self, dropna\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return number of unique elements in the object. Excludes NA values by default. Parameters ---------- dropna : bool, default True Don\u0027t include NaN in the count. Returns ------- int See Also -------- DataFrame.nunique: Method nunique for DataFrame. Series.count: Count non-NA/null...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 3, 5, 7, 7])\n\u003e\u003e\u003e s\n0    1\n1    3\n2    5\n3    7\n4    7\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.putmask", "label": "putmask", "shape": "dot", "size": 20, "title": "NAME: putmask\n------------------------------\nINPUTS: self, mask, value\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Return a new Index of the values set with the mask. Returns ------- Index See Also -------- numpy.ndarray.putmask : Changes elements of an array based on conditional and input values. Examples -------- \u003e\u003e\u003e idx1 = pd.Index([1, 2, 3]) \u003e\u003e\u003e idx2...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx2 = pd.Index([5, 6, 7])\n\u003e\u003e\u003e idx1.putmask([True, False, False], idx2)\nIndex([5, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.ravel", "label": "ravel", "shape": "dot", "size": 20, "title": "NAME: ravel\n------------------------------\nINPUTS: self, order\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a view on self. Returns ------- Index See Also -------- numpy.ndarray.ravel : Return a flattened array. Examples -------- \u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e s.index.ravel() Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e s.index.ravel()\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.reindex", "label": "reindex", "shape": "dot", "size": 20, "title": "NAME: reindex\n------------------------------\nINPUTS: self, target, method, level, limit, tolerance\nOUTPUTS: tuple[Index, npt.NDArray[np.intp] | None]\n------------------------------\nDESCRIPTION: Create index with target\u0027s values. Parameters ---------- target : an iterable method : {None, \u0027pad\u0027/\u0027ffill\u0027, \u0027backfill\u0027/\u0027bfill\u0027, \u0027nearest\u0027}, optional * default: exact matches only. * pad / ffill: find the PREVIOUS index value if no exact match. * backfill / bfill:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.reindex([\u0027car\u0027, \u0027bike\u0027])\n(Index([\u0027car\u0027, \u0027bike\u0027], dtype=\u0027object\u0027), array([0, 1]))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.rename", "label": "rename", "shape": "dot", "size": 20, "title": "NAME: rename\n------------------------------\nINPUTS: self, name, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Alter Index or MultiIndex name. Able to set new names without level. Defaults to returning new index. Length of names must match number of levels in MultiIndex. Parameters ---------- name : label or list of labels Name(s) to set. inplace...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027A\u0027, \u0027C\u0027, \u0027A\u0027, \u0027B\u0027], name=\u0027score\u0027)\n\u003e\u003e\u003e idx.rename(\u0027grade\u0027)\nIndex([\u0027A\u0027, \u0027C\u0027, \u0027A\u0027, \u0027B\u0027], dtype=\u0027object\u0027, name=\u0027grade\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.repeat", "label": "repeat", "shape": "dot", "size": 20, "title": "NAME: repeat\n------------------------------\nINPUTS: self, repeats, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Repeat elements of a Index. Returns a new Index where each element of the current Index is repeated consecutively a given number of times. Parameters ---------- repeats : int or array of ints The number of repetitions for each element....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.repeat(2)\nIndex([\u0027a\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027c\u0027, \u0027c\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.repeat([1, 2, 3])\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027c\u0027, \u0027c\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.round", "label": "round", "shape": "dot", "size": 20, "title": "NAME: round\n------------------------------\nINPUTS: self, decimals\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Round each value in the Index to the given number of decimals. Parameters ---------- decimals : int, optional Number of decimal places to round to. If decimals is negative, it specifies the number of positions to the left of the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import pandas as pd\n\u003e\u003e\u003e idx = pd.Index([10.1234, 20.5678, 30.9123, 40.4567, 50.7890])\n\u003e\u003e\u003e idx.round(decimals=2)\nIndex([10.12, 20.57, 30.91, 40.46, 50.79], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.searchsorted", "label": "searchsorted", "shape": "dot", "size": 20, "title": "NAME: searchsorted\n------------------------------\nINPUTS: self, value, side, sorter\nOUTPUTS: npt.NDArray[np.intp] | np.intp\n------------------------------\nDESCRIPTION: Find indices where elements should be inserted to maintain order. Find the indices into a sorted Index `self` such that, if the corresponding elements in `value` were inserted before the indices, the order of `self` would be preserved. .. note::...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([1, 2, 3])\n\u003e\u003e\u003e ser\n0    1\n1    2\n2    3\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.set_names", "label": "set_names", "shape": "dot", "size": 20, "title": "NAME: set_names\n------------------------------\nINPUTS: self, names, level, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Set Index or MultiIndex name. Able to set new names partially and by level. Parameters ---------- names : label or list of label or dict-like for MultiIndex Name(s) to set. .. versionchanged:: 1.3.0 level : int, label or list of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx.set_names(\u0027quarter\u0027)\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027, name=\u0027quarter\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.shift", "label": "shift", "shape": "dot", "size": 20, "title": "NAME: shift\n------------------------------\nINPUTS: self, periods, freq\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Shift index by desired number of time frequency increments. This method is for shifting the values of datetime-like indexes by a specified time increment a given number of times. Parameters ---------- periods : int, default 1 Number of periods (or...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.slice_indexer", "label": "slice_indexer", "shape": "dot", "size": 20, "title": "NAME: slice_indexer\n------------------------------\nINPUTS: self, start, end, step\nOUTPUTS: slice\n------------------------------\nDESCRIPTION: Compute the slice indexer for input labels and step. Index needs to be ordered and unique. Parameters ---------- start : label, default None If None, defaults to the beginning. end : label, default None If None, defaults to the end....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abcd\u0027))\n\u003e\u003e\u003e idx.slice_indexer(start=\u0027b\u0027, end=\u0027c\u0027)\nslice(1, 3, None)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.slice_locs", "label": "slice_locs", "shape": "dot", "size": 20, "title": "NAME: slice_locs\n------------------------------\nINPUTS: self, start, end, step\nOUTPUTS: tuple[int, int]\n------------------------------\nDESCRIPTION: Compute slice locations for input labels. Parameters ---------- start : label, default None If None, defaults to the beginning. end : label, default None If None, defaults to the end. step : int, defaults None If None, defaults to 1....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abcd\u0027))\n\u003e\u003e\u003e idx.slice_locs(start=\u0027b\u0027, end=\u0027c\u0027)\n(1, 3)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.sort", "label": "sort", "shape": "dot", "size": 20, "title": "NAME: sort\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Use sort_values instead....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.sort_values", "label": "sort_values", "shape": "dot", "size": 20, "title": "NAME: sort_values\n------------------------------\nINPUTS: self, return_indexer, ascending, na_position, key\nOUTPUTS: Self | tuple[Self, np.ndarray]\n------------------------------\nDESCRIPTION: Return a sorted copy of the index. Return a sorted copy of the index, and optionally return the indices that sorted the index itself. Parameters ---------- return_indexer : bool, default False Should the indices that would sort the index be...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([10, 100, 1, 1000])\n\u003e\u003e\u003e idx\nIndex([10, 100, 1, 1000], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.sortlevel", "label": "sortlevel", "shape": "dot", "size": 20, "title": "NAME: sortlevel\n------------------------------\nINPUTS: self, level, ascending, sort_remaining, na_position\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: For internal compatibility with the Index API. Sort the Index. This is for compat with MultiIndex Parameters ---------- ascending : bool, default True False to sort in descending order na_position : {\u0027first\u0027 or \u0027last\u0027}, default \u0027first\u0027 Argument \u0027first\u0027 puts NaNs...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.PeriodIndex.str", "label": "str", "shape": "dot", "size": 20, "title": "NAME: str\n------------------------------\nINPUTS: data\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Vectorized string functions for Series and Index. NAs stay NA unless handled otherwise by a particular method. Patterned after Python\u0027s string methods, with some inspiration from R\u0027s stringr package. Examples -------- \u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"]) \u003e\u003e\u003e s 0 A_Str_Series dtype:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"])\n\u003e\u003e\u003e s\n0    A_Str_Series\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.strftime", "label": "strftime", "shape": "dot", "size": 20, "title": "NAME: strftime\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Convert to Index using specified date_format. Return an Index of formatted strings specified by date_format, which supports the same string format as the python standard library. Details of the string format can be found in `python string format doc \u003chttps://docs.python.org/3/library/datetime.html#strftime-and-strptime-behavior\u003e`__....\n\n\nEXAMPLE:\n\u003e\u003e\u003e rng = pd.date_range(pd.Timestamp(\"2018-03-10 09:00\"),\n...                     periods=3, freq=\u0027s\u0027)\n\u003e\u003e\u003e rng.strftime(\u0027%B %d, %Y, %r\u0027)\nIndex([\u0027March 10, 2018, 09:00:00 AM\u0027, \u0027March 10, 2018, 09:00:01 AM\u0027,\n       \u0027March 10, 2018, 09:00:02 AM\u0027],\n      dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.symmetric_difference", "label": "symmetric_difference", "shape": "dot", "size": 20, "title": "NAME: symmetric_difference\n------------------------------\nINPUTS: self, other, result_name, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Compute the symmetric difference of two Index objects. Parameters ---------- other : Index or array-like result_name : str sort : bool or None, default None Whether to sort the resulting index. By default, the values are attempted to be sorted,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([2, 3, 4, 5])\n\u003e\u003e\u003e idx1.symmetric_difference(idx2)\nIndex([1, 5], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.take", "label": "take", "shape": "dot", "size": 20, "title": "NAME: take\n------------------------------\nINPUTS: self, indices, axis, allow_fill, fill_value, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a new Index of the values selected by the indices. For internal compatibility with numpy arrays. Parameters ---------- indices : array-like Indices to be taken. axis : int, optional The axis over which to select values, always 0. allow_fill...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.take([2, 2, 1, 2])\nIndex([\u0027c\u0027, \u0027c\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.to_flat_index", "label": "to_flat_index", "shape": "dot", "size": 20, "title": "NAME: to_flat_index\n------------------------------\nINPUTS: self\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Identity method. This is implemented for compatibility with subclass implementations when chaining. Returns ------- pd.Index Caller. See Also -------- MultiIndex.to_flat_index : Subclass implementation....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.to_frame", "label": "to_frame", "shape": "dot", "size": 20, "title": "NAME: to_frame\n------------------------------\nINPUTS: self, index, name\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Create a DataFrame with a column containing the Index. Parameters ---------- index : bool, default True Set the index of the returned DataFrame as the original Index. name : object, defaults to index.name The passed name should substitute for the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027Ant\u0027, \u0027Bear\u0027, \u0027Cow\u0027], name=\u0027animal\u0027)\n\u003e\u003e\u003e idx.to_frame()\n       animal\nanimal\nAnt       Ant\nBear     Bear\nCow       Cow"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.to_list", "label": "to_list", "shape": "dot", "size": 20, "title": "NAME: to_list\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list See Also -------- numpy.ndarray.tolist : Return the array as an...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.to_list()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.to_numpy", "label": "to_numpy", "shape": "dot", "size": 20, "title": "NAME: to_numpy\n------------------------------\nINPUTS: self, dtype, copy, na_value, kwargs\nOUTPUTS: np.ndarray\n------------------------------\nDESCRIPTION: A NumPy ndarray representing the values in this Series or Index. Parameters ---------- dtype : str or numpy.dtype, optional The dtype to pass to :meth:`numpy.asarray`. copy : bool, default False Whether to ensure that the returned value is not a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series(pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027]))\n\u003e\u003e\u003e ser.to_numpy()\narray([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.to_series", "label": "to_series", "shape": "dot", "size": 20, "title": "NAME: to_series\n------------------------------\nINPUTS: self, index, name\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Create a Series with both index and values equal to the index keys. Useful with map for returning an indexer based on an index. Parameters ---------- index : Index, optional Index of resulting Series. If None, defaults to original index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027Ant\u0027, \u0027Bear\u0027, \u0027Cow\u0027], name=\u0027animal\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.to_timestamp", "label": "to_timestamp", "shape": "dot", "size": 20, "title": "NAME: to_timestamp\n------------------------------\nINPUTS: self, freq, how\nOUTPUTS: DatetimeIndex\n------------------------------\nDESCRIPTION: Cast to DatetimeArray/Index. Parameters ---------- freq : str or DateOffset, optional Target frequency. The default is \u0027D\u0027 for week or longer, \u0027s\u0027 otherwise. how : {\u0027s\u0027, \u0027e\u0027, \u0027start\u0027, \u0027end\u0027} Whether to use the start or end of the time period...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.PeriodIndex([\"2023-01\", \"2023-02\", \"2023-03\"], freq=\"M\")\n\u003e\u003e\u003e idx.to_timestamp()\nDatetimeIndex([\u00272023-01-01\u0027, \u00272023-02-01\u0027, \u00272023-03-01\u0027],\ndtype=\u0027datetime64[ns]\u0027, freq=\u0027MS\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.tolist", "label": "tolist", "shape": "dot", "size": 20, "title": "NAME: tolist\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list See Also -------- numpy.ndarray.tolist : Return the array as an...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.to_list()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.transpose", "label": "transpose", "shape": "dot", "size": 20, "title": "NAME: transpose\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return the transpose, which is by definition self. Returns ------- %(klass)s...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.union", "label": "union", "shape": "dot", "size": 20, "title": "NAME: union\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Form the union of two Index objects. If the Index objects are incompatible, both Index objects will be cast to dtype(\u0027object\u0027) first. Parameters ---------- other : Index or array-like sort : bool or None, default None Whether to sort the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.union(idx2)\nIndex([1, 2, 3, 4, 5, 6], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.unique", "label": "unique", "shape": "dot", "size": 20, "title": "NAME: unique\n------------------------------\nINPUTS: self, level\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return unique values in the index. Unique values are returned in order of appearance, this does NOT sort. Parameters ---------- level : int or hashable, optional Only return values from specified level (for MultiIndex). If int, gets the level by...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 1, 2, 3, 3])\n\u003e\u003e\u003e idx.unique()\nIndex([1, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.value_counts", "label": "value_counts", "shape": "dot", "size": 20, "title": "NAME: value_counts\n------------------------------\nINPUTS: self, normalize, sort, ascending, bins, dropna\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return a Series containing counts of unique values. The resulting object will be in descending order so that the first element is the most frequently-occurring element. Excludes NA values by default. Parameters ---------- normalize : bool, default False If True...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([3, 1, 2, 3, 4, np.nan])\n\u003e\u003e\u003e index.value_counts()\n3.0    2\n1.0    1\n2.0    1\n4.0    1\nName: count, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.view", "label": "view", "shape": "dot", "size": 20, "title": "NAME: view\n------------------------------\nINPUTS: self, cls\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.PeriodIndex.where", "label": "where", "shape": "dot", "size": 20, "title": "NAME: where\n------------------------------\nINPUTS: self, cond, other\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Replace values where the condition is False. The replacement is taken from other. Parameters ---------- cond : bool array-like with the same length as self Condition to select the values on. other : scalar, or array-like, default None Replacement if...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.where(idx.isin([\u0027car\u0027, \u0027train\u0027]), \u0027other\u0027)\nIndex([\u0027car\u0027, \u0027other\u0027, \u0027train\u0027, \u0027other\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.all", "label": "all", "shape": "dot", "size": 20, "title": "NAME: all\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Return whether all elements are Truthy. Parameters ---------- *args Required for compatibility with numpy. **kwargs Required for compatibility with numpy. Returns ------- bool or array-like (if axis is specified) A single element array-like may be converted to bool. See Also...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Index([1, 2, 3]).all()\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.any", "label": "any", "shape": "dot", "size": 20, "title": "NAME: any\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Return whether any element is Truthy. Parameters ---------- *args Required for compatibility with numpy. **kwargs Required for compatibility with numpy. Returns ------- bool or array-like (if axis is specified) A single element array-like may be converted to bool. See Also...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([0, 1, 2])\n\u003e\u003e\u003e index.any()\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.append", "label": "append", "shape": "dot", "size": 20, "title": "NAME: append\n------------------------------\nINPUTS: self, other\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Append a collection of Index options together. Parameters ---------- other : Index or list/tuple of indices Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([1, 2, 3]) \u003e\u003e\u003e idx.append(pd.Index([4])) Index([1, 2, 3, 4], dtype=\u0027int64\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.append(pd.Index([4]))\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.argmax", "label": "argmax", "shape": "dot", "size": 20, "title": "NAME: argmax\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the largest value in the Series. If the maximum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.argmin", "label": "argmin", "shape": "dot", "size": 20, "title": "NAME: argmin\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the smallest value in the Series. If the minimum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.argsort", "label": "argsort", "shape": "dot", "size": 20, "title": "NAME: argsort\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Returns the indices that would sort the index and its underlying data. Returns ------- np.ndarray[np.intp] See Also -------- numpy.ndarray.argsort...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.asof", "label": "asof", "shape": "dot", "size": 20, "title": "NAME: asof\n------------------------------\nINPUTS: self, label\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the label from the index, or, if not present, the previous one. Assuming that the index is sorted, return the passed index label if it is in the index, or return the previous index label if the passed one...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u00272013-12-31\u0027, \u00272014-01-02\u0027, \u00272014-01-03\u0027])\n\u003e\u003e\u003e idx.asof(\u00272014-01-01\u0027)\n\u00272013-12-31\u0027"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.asof_locs", "label": "asof_locs", "shape": "dot", "size": 20, "title": "NAME: asof_locs\n------------------------------\nINPUTS: self, where, mask\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Return the locations (indices) of labels in the index. As in the :meth:`pandas.Index.asof`, if the label (a particular entry in ``where``) is not in the index, the latest index label up to the passed label is chosen and its index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.date_range(\u00272023-06-01\u0027, periods=3, freq=\u0027D\u0027)\n\u003e\u003e\u003e where = pd.DatetimeIndex([\u00272023-05-30 00:12:00\u0027, \u00272023-06-01 00:00:00\u0027,\n...                           \u00272023-06-02 23:59:59\u0027])\n\u003e\u003e\u003e mask = np.ones(3, dtype=bool)\n\u003e\u003e\u003e idx.asof_locs(where, mask)\narray([-1,  0,  1])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.astype", "label": "astype", "shape": "dot", "size": 20, "title": "NAME: astype\n------------------------------\nINPUTS: self, dtype, copy\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Create an Index with values cast to dtypes. The class of a new Index is determined by dtype. When conversion is impossible, a TypeError exception is raised. Parameters ---------- dtype : numpy dtype or pandas type Note that any signed...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx.astype(\u0027float\u0027)\nIndex([1.0, 2.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.copy", "label": "copy", "shape": "dot", "size": 20, "title": "NAME: copy\n------------------------------\nINPUTS: self, name, deep\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make a copy of this object. Name is set on the new object. Parameters ---------- name : Label, optional Set name for new object. deep : bool, default False Returns ------- Index Index refer to new object which is a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e new_idx = idx.copy()\n\u003e\u003e\u003e idx is new_idx\nFalse"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.delete", "label": "delete", "shape": "dot", "size": 20, "title": "NAME: delete\n------------------------------\nINPUTS: self, loc\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Make new Index with passed location(-s) deleted. Parameters ---------- loc : int or list of int Location of item(-s) which will be deleted. Use a list of locations to delete more than one value at the same time. Returns -------...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.delete(1)\nIndex([\u0027a\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.diff", "label": "diff", "shape": "dot", "size": 20, "title": "NAME: diff\n------------------------------\nINPUTS: self, periods\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Computes the difference between consecutive values in the Index object. If periods is greater than 1, computes the difference between values that are `periods` number of positions apart. Parameters ---------- periods : int, optional The number of positions between the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import pandas as pd\n\u003e\u003e\u003e idx = pd.Index([10, 20, 30, 40, 50])\n\u003e\u003e\u003e idx.diff()\nIndex([nan, 10.0, 10.0, 10.0, 10.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.difference", "label": "difference", "shape": "dot", "size": 20, "title": "NAME: difference\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a new Index with elements of index not in `other`. This is the set difference of two Index objects. Parameters ---------- other : Index or array-like sort : bool or None, default None Whether to sort the resulting index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([2, 1, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.difference(idx2)\nIndex([1, 2], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx1.difference(idx2, sort=False)\nIndex([2, 1], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.drop", "label": "drop", "shape": "dot", "size": 20, "title": "NAME: drop\n------------------------------\nINPUTS: self, labels, errors\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Make new Index with passed list of labels deleted. Parameters ---------- labels : array-like or scalar errors : {\u0027ignore\u0027, \u0027raise\u0027}, default \u0027raise\u0027 If \u0027ignore\u0027, suppress error and existing labels are dropped. Returns ------- Index Will be same type as self,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.drop([\u0027a\u0027])\nIndex([\u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.drop_duplicates", "label": "drop_duplicates", "shape": "dot", "size": 20, "title": "NAME: drop_duplicates\n------------------------------\nINPUTS: self, keep\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return Index with duplicate values removed. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, ``False``}, default \u0027first\u0027 - \u0027first\u0027 : Drop duplicates except for the first occurrence. - \u0027last\u0027 : Drop duplicates except for the last occurrence. - ``False`` : Drop all...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027lama\u0027, \u0027cow\u0027, \u0027lama\u0027, \u0027beetle\u0027, \u0027lama\u0027, \u0027hippo\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.droplevel", "label": "droplevel", "shape": "dot", "size": 20, "title": "NAME: droplevel\n------------------------------\nINPUTS: self, level\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return index with requested level(s) removed. If resulting index has only 1 level left, the result will be of Index type, not MultiIndex. The original index is not modified inplace. Parameters ---------- level : int, str, or list-like, default 0...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays(\n... [[1, 2], [3, 4], [5, 6]], names=[\u0027x\u0027, \u0027y\u0027, \u0027z\u0027])\n\u003e\u003e\u003e mi\nMultiIndex([(1, 3, 5),\n            (2, 4, 6)],\n           names=[\u0027x\u0027, \u0027y\u0027, \u0027z\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.dropna", "label": "dropna", "shape": "dot", "size": 20, "title": "NAME: dropna\n------------------------------\nINPUTS: self, how\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return Index without NA/NaN values. Parameters ---------- how : {\u0027any\u0027, \u0027all\u0027}, default \u0027any\u0027 If the Index is a MultiIndex, drop the value when any or all levels are NaN. Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([1, np.nan, 3])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, np.nan, 3])\n\u003e\u003e\u003e idx.dropna()\nIndex([1.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.duplicated", "label": "duplicated", "shape": "dot", "size": 20, "title": "NAME: duplicated\n------------------------------\nINPUTS: self, keep\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Indicate duplicate index values. Duplicated values are indicated as ``True`` values in the resulting array. Either all duplicates, all except the first, or all except the last occurrence of duplicates can be indicated. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, False},...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027lama\u0027, \u0027cow\u0027, \u0027lama\u0027, \u0027beetle\u0027, \u0027lama\u0027])\n\u003e\u003e\u003e idx.duplicated()\narray([False, False,  True, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.equals", "label": "equals", "shape": "dot", "size": 20, "title": "NAME: equals\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Determines if two Index objects contain the same elements....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.factorize", "label": "factorize", "shape": "dot", "size": 20, "title": "NAME: factorize\n------------------------------\nINPUTS: self, sort, use_na_sentinel\nOUTPUTS: tuple[npt.NDArray[np.intp], RangeIndex]\n------------------------------\nDESCRIPTION: Encode the object as an enumerated type or categorical variable. This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct values. `factorize` is available as both a top-level function :func:`pandas.factorize`, and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e codes, uniques = pd.factorize(np.array([\u0027b\u0027, \u0027b\u0027, \u0027a\u0027, \u0027c\u0027, \u0027b\u0027], dtype=\"O\"))\n\u003e\u003e\u003e codes\narray([0, 0, 1, 2, 0])\n\u003e\u003e\u003e uniques\narray([\u0027b\u0027, \u0027a\u0027, \u0027c\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.fillna", "label": "fillna", "shape": "dot", "size": 20, "title": "NAME: fillna\n------------------------------\nINPUTS: self, value, downcast\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Fill NA/NaN values with the specified value. Parameters ---------- value : scalar Scalar value to use to fill holes (e.g. 0). This value cannot be a list-likes. downcast : dict, default is None A dict of item-\u003edtype of what to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([np.nan, np.nan, 3])\n\u003e\u003e\u003e idx.fillna(0)\nIndex([0.0, 0.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.format", "label": "format", "shape": "dot", "size": 20, "title": "NAME: format\n------------------------------\nINPUTS: self, name, formatter, na_rep\nOUTPUTS: list[str_t]\n------------------------------\nDESCRIPTION: Render a string representation of the Index....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.from_range", "label": "from_range", "shape": "dot", "size": 20, "title": "NAME: from_range\n------------------------------\nINPUTS: data, name, dtype\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Create :class:`pandas.RangeIndex` from a ``range`` object. Returns ------- RangeIndex Examples -------- \u003e\u003e\u003e pd.RangeIndex.from_range(range(5)) RangeIndex(start=0, stop=5, step=1) \u003e\u003e\u003e pd.RangeIndex.from_range(range(2, -10, -3)) RangeIndex(start=2, stop=-10, step=-3)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.RangeIndex.from_range(range(5))\nRangeIndex(start=0, stop=5, step=1)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.get_indexer", "label": "get_indexer", "shape": "dot", "size": 20, "title": "NAME: get_indexer\n------------------------------\nINPUTS: self, target, method, limit, tolerance\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Compute indexer and mask for new index given the current index. The indexer should be then used as an input to ndarray.take to align the current data to the new index. Parameters ---------- target : Index method : {None, \u0027pad\u0027/\u0027ffill\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([\u0027c\u0027, \u0027a\u0027, \u0027b\u0027])\n\u003e\u003e\u003e index.get_indexer([\u0027a\u0027, \u0027b\u0027, \u0027x\u0027])\narray([ 1,  2, -1])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.get_indexer_for", "label": "get_indexer_for", "shape": "dot", "size": 20, "title": "NAME: get_indexer_for\n------------------------------\nINPUTS: self, target\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Guaranteed return of an indexer even when non-unique. This dispatches to get_indexer or get_indexer_non_unique as appropriate. Returns ------- np.ndarray[np.intp] List of indices. Examples -------- \u003e\u003e\u003e idx = pd.Index([np.nan, \u0027var1\u0027, np.nan]) \u003e\u003e\u003e idx.get_indexer_for([np.nan]) array([0, 2])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([np.nan, \u0027var1\u0027, np.nan])\n\u003e\u003e\u003e idx.get_indexer_for([np.nan])\narray([0, 2])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.get_indexer_non_unique", "label": "get_indexer_non_unique", "shape": "dot", "size": 20, "title": "NAME: get_indexer_non_unique\n------------------------------\nINPUTS: self, target\nOUTPUTS: tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]\n------------------------------\nDESCRIPTION: Compute indexer and mask for new index given the current index. The indexer should be then used as an input to ndarray.take to align the current data to the new index. Parameters ---------- target : Index Returns ------- indexer :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([\u0027c\u0027, \u0027b\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027])\n\u003e\u003e\u003e index.get_indexer_non_unique([\u0027b\u0027, \u0027b\u0027])\n(array([1, 3, 4, 1, 3, 4]), array([], dtype=int64))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.get_level_values", "label": "get_level_values", "shape": "dot", "size": 20, "title": "NAME: get_level_values\n------------------------------\nINPUTS: self, level\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Return an Index of values for requested level. This is primarily useful to get an individual level of values from a MultiIndex, but is provided on Index as well for compatibility. Parameters ---------- level : int or str It is...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abc\u0027))\n\u003e\u003e\u003e idx\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.get_loc", "label": "get_loc", "shape": "dot", "size": 20, "title": "NAME: get_loc\n------------------------------\nINPUTS: self, key\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Get integer location, slice or boolean mask for requested label. Parameters ---------- key : label Returns ------- int if unique index, slice if monotonic index, else mask Examples -------- \u003e\u003e\u003e unique_index = pd.Index(list(\u0027abc\u0027)) \u003e\u003e\u003e unique_index.get_loc(\u0027b\u0027) 1 \u003e\u003e\u003e monotonic_index = pd.Index(list(\u0027abbc\u0027))...\n\n\nEXAMPLE:\n\u003e\u003e\u003e unique_index = pd.Index(list(\u0027abc\u0027))\n\u003e\u003e\u003e unique_index.get_loc(\u0027b\u0027)\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.get_slice_bound", "label": "get_slice_bound", "shape": "dot", "size": 20, "title": "NAME: get_slice_bound\n------------------------------\nINPUTS: self, label, side\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Calculate slice bound that corresponds to given label. Returns leftmost (one-past-the-rightmost if ``side==\u0027right\u0027``) position of given label. Parameters ---------- label : object side : {\u0027left\u0027, \u0027right\u0027} Returns ------- int Index of label. See Also -------- Index.get_loc : Get integer location,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.RangeIndex(5)\n\u003e\u003e\u003e idx.get_slice_bound(3, \u0027left\u0027)\n3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.groupby", "label": "groupby", "shape": "dot", "size": 20, "title": "NAME: groupby\n------------------------------\nINPUTS: self, values\nOUTPUTS: PrettyDict[Hashable, np.ndarray]\n------------------------------\nDESCRIPTION: Group the index labels by a given array of values. Parameters ---------- values : array Values used to determine the groups. Returns ------- dict {group name -\u003e group labels}...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.holds_integer", "label": "holds_integer", "shape": "dot", "size": 20, "title": "NAME: holds_integer\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Whether the type is an integer type. .. deprecated:: 2.0.0 Use `pandas.api.types.infer_dtype` instead...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.identical", "label": "identical", "shape": "dot", "size": 20, "title": "NAME: identical\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Similar to equals, but checks that object attributes and types are also equal. Returns ------- bool If two Index objects have equal elements and same type True, otherwise False. Examples -------- \u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027]) \u003e\u003e\u003e idx2 =...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx2 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx2.identical(idx1)\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.infer_objects", "label": "infer_objects", "shape": "dot", "size": 20, "title": "NAME: infer_objects\n------------------------------\nINPUTS: self, copy\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: If we have an object dtype, try to infer a non-object dtype. Parameters ---------- copy : bool, default True Whether to make a copy in cases where no inference occurs....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.insert", "label": "insert", "shape": "dot", "size": 20, "title": "NAME: insert\n------------------------------\nINPUTS: self, loc, item\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Make new Index inserting new item at location. Follows Python numpy.insert semantics for negative values. Parameters ---------- loc : int item : object Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e idx.insert(1, \u0027x\u0027) Index([\u0027a\u0027, \u0027x\u0027, \u0027b\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.insert(1, \u0027x\u0027)\nIndex([\u0027a\u0027, \u0027x\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.intersection", "label": "intersection", "shape": "dot", "size": 20, "title": "NAME: intersection\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Form the intersection of two Index objects. This returns a new Index with elements common to the index and `other`. Parameters ---------- other : Index or array-like sort : True, False or None, default False Whether to sort the resulting...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.intersection(idx2)\nIndex([3, 4], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.is_", "label": "is_", "shape": "dot", "size": 20, "title": "NAME: is_\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: More flexible, faster check like ``is`` but that works through views. Note: this is *not* the same as ``Index.identical()``, which checks that metadata is also the same. Parameters ---------- other : object Other object to compare against. Returns ------- bool...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx1.is_(idx1.view())\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.is_boolean", "label": "is_boolean", "shape": "dot", "size": 20, "title": "NAME: is_boolean\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of booleans. .. deprecated:: 2.0.0 Use `pandas.api.types.is_bool_dtype` instead. Returns ------- bool Whether or not the Index only consists of booleans. See Also -------- is_integer : Check if the Index only consists of integers (deprecated)....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([True, False, True])\n\u003e\u003e\u003e idx.is_boolean()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.is_categorical", "label": "is_categorical", "shape": "dot", "size": 20, "title": "NAME: is_categorical\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index holds categorical data. .. deprecated:: 2.0.0 Use `isinstance(index.dtype, pd.CategoricalDtype)` instead. Returns ------- bool True if the Index is categorical. See Also -------- CategoricalIndex : Index for categorical data. is_boolean : Check if the Index only consists...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n...                 \"Watermelon\"]).astype(\"category\")\n\u003e\u003e\u003e idx.is_categorical()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.is_floating", "label": "is_floating", "shape": "dot", "size": 20, "title": "NAME: is_floating\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index is a floating type. .. deprecated:: 2.0.0 Use `pandas.api.types.is_float_dtype` instead The Index may consist of only floats, NaNs, or a mix of floats, integers, or NaNs. Returns ------- bool Whether or not the Index only consists...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n\u003e\u003e\u003e idx.is_floating()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.is_integer", "label": "is_integer", "shape": "dot", "size": 20, "title": "NAME: is_integer\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of integers. .. deprecated:: 2.0.0 Use `pandas.api.types.is_integer_dtype` instead. Returns ------- bool Whether or not the Index only consists of integers. See Also -------- is_boolean : Check if the Index only consists of booleans (deprecated)....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx.is_integer()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.is_interval", "label": "is_interval", "shape": "dot", "size": 20, "title": "NAME: is_interval\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index holds Interval objects. .. deprecated:: 2.0.0 Use `isinstance(index.dtype, pd.IntervalDtype)` instead. Returns ------- bool Whether or not the Index holds Interval objects. See Also -------- IntervalIndex : Index for Interval objects. is_boolean : Check if the Index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([pd.Interval(left=0, right=5),\n...                 pd.Interval(left=5, right=10)])\n\u003e\u003e\u003e idx.is_interval()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.is_numeric", "label": "is_numeric", "shape": "dot", "size": 20, "title": "NAME: is_numeric\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of numeric data. .. deprecated:: 2.0.0 Use `pandas.api.types.is_numeric_dtype` instead. Returns ------- bool Whether or not the Index only consists of numeric data. See Also -------- is_boolean : Check if the Index only consists of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n\u003e\u003e\u003e idx.is_numeric()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.is_object", "label": "is_object", "shape": "dot", "size": 20, "title": "NAME: is_object\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index is of the object dtype. .. deprecated:: 2.0.0 Use `pandas.api.types.is_object_dtype` instead. Returns ------- bool Whether or not the Index is of the object dtype. See Also -------- is_boolean : Check if the Index only consists of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\"Apple\", \"Mango\", \"Watermelon\"])\n\u003e\u003e\u003e idx.is_object()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.isin", "label": "isin", "shape": "dot", "size": 20, "title": "NAME: isin\n------------------------------\nINPUTS: self, values, level\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Return a boolean array where the index values are in `values`. Compute boolean array of whether each index value is found in the passed set of values. The length of the returned boolean array matches the length of the index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1,2,3])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.isna", "label": "isna", "shape": "dot", "size": 20, "title": "NAME: isna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get mapped to ``True`` values. Everything else get mapped to ``False`` values. Characters such as empty strings `\u0027\u0027`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.isna()\narray([False, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.isnull", "label": "isnull", "shape": "dot", "size": 20, "title": "NAME: isnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get mapped to ``True`` values. Everything else get mapped to ``False`` values. Characters such as empty strings `\u0027\u0027`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.isna()\narray([False, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.item", "label": "item", "shape": "dot", "size": 20, "title": "NAME: item\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the first element of the underlying data as a Python scalar. Returns ------- scalar The first element of Series or Index. Raises ------ ValueError If the data is not length = 1. Examples -------- \u003e\u003e\u003e s = pd.Series([1]) \u003e\u003e\u003e...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1])\n\u003e\u003e\u003e s.item()\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.join", "label": "join", "shape": "dot", "size": 20, "title": "NAME: join\n------------------------------\nINPUTS: self, other, how, level, return_indexers, sort\nOUTPUTS: Index | tuple[Index, npt.NDArray[np.intp] | None, npt.NDArray[np.intp] | None]\n------------------------------\nDESCRIPTION: Compute join_index and indexers to conform data structures to the new index. Parameters ---------- other : Index how : {\u0027left\u0027, \u0027right\u0027, \u0027inner\u0027, \u0027outer\u0027} level : int or level name, default None return_indexers : bool, default False sort : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx2 = pd.Index([4, 5, 6])\n\u003e\u003e\u003e idx1.join(idx2, how=\u0027outer\u0027)\nIndex([1, 2, 3, 4, 5, 6], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.map", "label": "map", "shape": "dot", "size": 20, "title": "NAME: map\n------------------------------\nINPUTS: self, mapper, na_action\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Map values using an input mapping or function. Parameters ---------- mapper : function, dict, or Series Mapping correspondence. na_action : {None, \u0027ignore\u0027} If \u0027ignore\u0027, propagate NA values, without passing them to the mapping correspondence. Returns ------- Union[Index, MultiIndex] The output...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.map({1: \u0027a\u0027, 2: \u0027b\u0027, 3: \u0027c\u0027})\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.max", "label": "max", "shape": "dot", "size": 20, "title": "NAME: max\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: The maximum value of the RangeIndex...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.memory_usage", "label": "memory_usage", "shape": "dot", "size": 20, "title": "NAME: memory_usage\n------------------------------\nINPUTS: self, deep\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Memory usage of my values Parameters ---------- deep : bool Introspect the data deeply, interrogate `object` dtypes for system-level memory consumption Returns ------- bytes used Notes ----- Memory usage does not include memory consumed by elements that are not components...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.min", "label": "min", "shape": "dot", "size": 20, "title": "NAME: min\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: The minimum value of the RangeIndex...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.notna", "label": "notna", "shape": "dot", "size": 20, "title": "NAME: notna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to ``True``. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values. NA values, such as None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.notna()\narray([ True,  True, False])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.notnull", "label": "notnull", "shape": "dot", "size": 20, "title": "NAME: notnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to ``True``. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values. NA values, such as None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.notna()\narray([ True,  True, False])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.nunique", "label": "nunique", "shape": "dot", "size": 20, "title": "NAME: nunique\n------------------------------\nINPUTS: self, dropna\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return number of unique elements in the object. Excludes NA values by default. Parameters ---------- dropna : bool, default True Don\u0027t include NaN in the count. Returns ------- int See Also -------- DataFrame.nunique: Method nunique for DataFrame. Series.count: Count non-NA/null...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 3, 5, 7, 7])\n\u003e\u003e\u003e s\n0    1\n1    3\n2    5\n3    7\n4    7\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.putmask", "label": "putmask", "shape": "dot", "size": 20, "title": "NAME: putmask\n------------------------------\nINPUTS: self, mask, value\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Return a new Index of the values set with the mask. Returns ------- Index See Also -------- numpy.ndarray.putmask : Changes elements of an array based on conditional and input values. Examples -------- \u003e\u003e\u003e idx1 = pd.Index([1, 2, 3]) \u003e\u003e\u003e idx2...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx2 = pd.Index([5, 6, 7])\n\u003e\u003e\u003e idx1.putmask([True, False, False], idx2)\nIndex([5, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.ravel", "label": "ravel", "shape": "dot", "size": 20, "title": "NAME: ravel\n------------------------------\nINPUTS: self, order\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a view on self. Returns ------- Index See Also -------- numpy.ndarray.ravel : Return a flattened array. Examples -------- \u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e s.index.ravel() Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e s.index.ravel()\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.reindex", "label": "reindex", "shape": "dot", "size": 20, "title": "NAME: reindex\n------------------------------\nINPUTS: self, target, method, level, limit, tolerance\nOUTPUTS: tuple[Index, npt.NDArray[np.intp] | None]\n------------------------------\nDESCRIPTION: Create index with target\u0027s values. Parameters ---------- target : an iterable method : {None, \u0027pad\u0027/\u0027ffill\u0027, \u0027backfill\u0027/\u0027bfill\u0027, \u0027nearest\u0027}, optional * default: exact matches only. * pad / ffill: find the PREVIOUS index value if no exact match. * backfill / bfill:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.reindex([\u0027car\u0027, \u0027bike\u0027])\n(Index([\u0027car\u0027, \u0027bike\u0027], dtype=\u0027object\u0027), array([0, 1]))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.rename", "label": "rename", "shape": "dot", "size": 20, "title": "NAME: rename\n------------------------------\nINPUTS: self, name, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Alter Index or MultiIndex name. Able to set new names without level. Defaults to returning new index. Length of names must match number of levels in MultiIndex. Parameters ---------- name : label or list of labels Name(s) to set. inplace...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027A\u0027, \u0027C\u0027, \u0027A\u0027, \u0027B\u0027], name=\u0027score\u0027)\n\u003e\u003e\u003e idx.rename(\u0027grade\u0027)\nIndex([\u0027A\u0027, \u0027C\u0027, \u0027A\u0027, \u0027B\u0027], dtype=\u0027object\u0027, name=\u0027grade\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.repeat", "label": "repeat", "shape": "dot", "size": 20, "title": "NAME: repeat\n------------------------------\nINPUTS: self, repeats, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Repeat elements of a Index. Returns a new Index where each element of the current Index is repeated consecutively a given number of times. Parameters ---------- repeats : int or array of ints The number of repetitions for each element....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.repeat(2)\nIndex([\u0027a\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027c\u0027, \u0027c\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.repeat([1, 2, 3])\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027c\u0027, \u0027c\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.round", "label": "round", "shape": "dot", "size": 20, "title": "NAME: round\n------------------------------\nINPUTS: self, decimals\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Round each value in the Index to the given number of decimals. Parameters ---------- decimals : int, optional Number of decimal places to round to. If decimals is negative, it specifies the number of positions to the left of the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import pandas as pd\n\u003e\u003e\u003e idx = pd.Index([10.1234, 20.5678, 30.9123, 40.4567, 50.7890])\n\u003e\u003e\u003e idx.round(decimals=2)\nIndex([10.12, 20.57, 30.91, 40.46, 50.79], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.searchsorted", "label": "searchsorted", "shape": "dot", "size": 20, "title": "NAME: searchsorted\n------------------------------\nINPUTS: self, value, side, sorter\nOUTPUTS: npt.NDArray[np.intp] | np.intp\n------------------------------\nDESCRIPTION: Find indices where elements should be inserted to maintain order. Find the indices into a sorted Index `self` such that, if the corresponding elements in `value` were inserted before the indices, the order of `self` would be preserved. .. note::...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([1, 2, 3])\n\u003e\u003e\u003e ser\n0    1\n1    2\n2    3\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.set_names", "label": "set_names", "shape": "dot", "size": 20, "title": "NAME: set_names\n------------------------------\nINPUTS: self, names, level, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Set Index or MultiIndex name. Able to set new names partially and by level. Parameters ---------- names : label or list of label or dict-like for MultiIndex Name(s) to set. .. versionchanged:: 1.3.0 level : int, label or list of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx.set_names(\u0027quarter\u0027)\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027, name=\u0027quarter\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.shift", "label": "shift", "shape": "dot", "size": 20, "title": "NAME: shift\n------------------------------\nINPUTS: self, periods, freq\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Shift index by desired number of time frequency increments. This method is for shifting the values of datetime-like indexes by a specified time increment a given number of times. Parameters ---------- periods : int, default 1 Number of periods (or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e month_starts = pd.date_range(\u00271/1/2011\u0027, periods=5, freq=\u0027MS\u0027)\n\u003e\u003e\u003e month_starts\nDatetimeIndex([\u00272011-01-01\u0027, \u00272011-02-01\u0027, \u00272011-03-01\u0027, \u00272011-04-01\u0027,\n               \u00272011-05-01\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=\u0027MS\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.slice_indexer", "label": "slice_indexer", "shape": "dot", "size": 20, "title": "NAME: slice_indexer\n------------------------------\nINPUTS: self, start, end, step\nOUTPUTS: slice\n------------------------------\nDESCRIPTION: Compute the slice indexer for input labels and step. Index needs to be ordered and unique. Parameters ---------- start : label, default None If None, defaults to the beginning. end : label, default None If None, defaults to the end....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abcd\u0027))\n\u003e\u003e\u003e idx.slice_indexer(start=\u0027b\u0027, end=\u0027c\u0027)\nslice(1, 3, None)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.slice_locs", "label": "slice_locs", "shape": "dot", "size": 20, "title": "NAME: slice_locs\n------------------------------\nINPUTS: self, start, end, step\nOUTPUTS: tuple[int, int]\n------------------------------\nDESCRIPTION: Compute slice locations for input labels. Parameters ---------- start : label, default None If None, defaults to the beginning. end : label, default None If None, defaults to the end. step : int, defaults None If None, defaults to 1....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abcd\u0027))\n\u003e\u003e\u003e idx.slice_locs(start=\u0027b\u0027, end=\u0027c\u0027)\n(1, 3)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.sort", "label": "sort", "shape": "dot", "size": 20, "title": "NAME: sort\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Use sort_values instead....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.sort_values", "label": "sort_values", "shape": "dot", "size": 20, "title": "NAME: sort_values\n------------------------------\nINPUTS: self, return_indexer, ascending, na_position, key\nOUTPUTS: Self | tuple[Self, np.ndarray | RangeIndex]\n------------------------------\nDESCRIPTION: Return a sorted copy of the index. Return a sorted copy of the index, and optionally return the indices that sorted the index itself. Parameters ---------- return_indexer : bool, default False Should the indices that would sort the index be...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([10, 100, 1, 1000])\n\u003e\u003e\u003e idx\nIndex([10, 100, 1, 1000], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.sortlevel", "label": "sortlevel", "shape": "dot", "size": 20, "title": "NAME: sortlevel\n------------------------------\nINPUTS: self, level, ascending, sort_remaining, na_position\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: For internal compatibility with the Index API. Sort the Index. This is for compat with MultiIndex Parameters ---------- ascending : bool, default True False to sort in descending order na_position : {\u0027first\u0027 or \u0027last\u0027}, default \u0027first\u0027 Argument \u0027first\u0027 puts NaNs...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.RangeIndex.str", "label": "str", "shape": "dot", "size": 20, "title": "NAME: str\n------------------------------\nINPUTS: data\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Vectorized string functions for Series and Index. NAs stay NA unless handled otherwise by a particular method. Patterned after Python\u0027s string methods, with some inspiration from R\u0027s stringr package. Examples -------- \u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"]) \u003e\u003e\u003e s 0 A_Str_Series dtype:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"])\n\u003e\u003e\u003e s\n0    A_Str_Series\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.symmetric_difference", "label": "symmetric_difference", "shape": "dot", "size": 20, "title": "NAME: symmetric_difference\n------------------------------\nINPUTS: self, other, result_name, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Compute the symmetric difference of two Index objects. Parameters ---------- other : Index or array-like result_name : str sort : bool or None, default None Whether to sort the resulting index. By default, the values are attempted to be sorted,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([2, 3, 4, 5])\n\u003e\u003e\u003e idx1.symmetric_difference(idx2)\nIndex([1, 5], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.take", "label": "take", "shape": "dot", "size": 20, "title": "NAME: take\n------------------------------\nINPUTS: self, indices, axis, allow_fill, fill_value, kwargs\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Return a new Index of the values selected by the indices. For internal compatibility with numpy arrays. Parameters ---------- indices : array-like Indices to be taken. axis : int, optional The axis over which to select values, always 0. allow_fill...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.take([2, 2, 1, 2])\nIndex([\u0027c\u0027, \u0027c\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.to_flat_index", "label": "to_flat_index", "shape": "dot", "size": 20, "title": "NAME: to_flat_index\n------------------------------\nINPUTS: self\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Identity method. This is implemented for compatibility with subclass implementations when chaining. Returns ------- pd.Index Caller. See Also -------- MultiIndex.to_flat_index : Subclass implementation....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.to_frame", "label": "to_frame", "shape": "dot", "size": 20, "title": "NAME: to_frame\n------------------------------\nINPUTS: self, index, name\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Create a DataFrame with a column containing the Index. Parameters ---------- index : bool, default True Set the index of the returned DataFrame as the original Index. name : object, defaults to index.name The passed name should substitute for the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027Ant\u0027, \u0027Bear\u0027, \u0027Cow\u0027], name=\u0027animal\u0027)\n\u003e\u003e\u003e idx.to_frame()\n       animal\nanimal\nAnt       Ant\nBear     Bear\nCow       Cow"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.to_list", "label": "to_list", "shape": "dot", "size": 20, "title": "NAME: to_list\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list See Also -------- numpy.ndarray.tolist : Return the array as an...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.to_list()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.to_numpy", "label": "to_numpy", "shape": "dot", "size": 20, "title": "NAME: to_numpy\n------------------------------\nINPUTS: self, dtype, copy, na_value, kwargs\nOUTPUTS: np.ndarray\n------------------------------\nDESCRIPTION: A NumPy ndarray representing the values in this Series or Index. Parameters ---------- dtype : str or numpy.dtype, optional The dtype to pass to :meth:`numpy.asarray`. copy : bool, default False Whether to ensure that the returned value is not a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series(pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027]))\n\u003e\u003e\u003e ser.to_numpy()\narray([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.to_series", "label": "to_series", "shape": "dot", "size": 20, "title": "NAME: to_series\n------------------------------\nINPUTS: self, index, name\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Create a Series with both index and values equal to the index keys. Useful with map for returning an indexer based on an index. Parameters ---------- index : Index, optional Index of resulting Series. If None, defaults to original index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027Ant\u0027, \u0027Bear\u0027, \u0027Cow\u0027], name=\u0027animal\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.tolist", "label": "tolist", "shape": "dot", "size": 20, "title": "NAME: tolist\n------------------------------\nINPUTS: self\nOUTPUTS: list[int]\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list See Also -------- numpy.ndarray.tolist : Return the array as an...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.to_list()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.transpose", "label": "transpose", "shape": "dot", "size": 20, "title": "NAME: transpose\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return the transpose, which is by definition self. Returns ------- %(klass)s...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.union", "label": "union", "shape": "dot", "size": 20, "title": "NAME: union\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Form the union of two Index objects. If the Index objects are incompatible, both Index objects will be cast to dtype(\u0027object\u0027) first. Parameters ---------- other : Index or array-like sort : bool or None, default None Whether to sort the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.union(idx2)\nIndex([1, 2, 3, 4, 5, 6], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.unique", "label": "unique", "shape": "dot", "size": 20, "title": "NAME: unique\n------------------------------\nINPUTS: self, level\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return unique values in the index. Unique values are returned in order of appearance, this does NOT sort. Parameters ---------- level : int or hashable, optional Only return values from specified level (for MultiIndex). If int, gets the level by...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 1, 2, 3, 3])\n\u003e\u003e\u003e idx.unique()\nIndex([1, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.value_counts", "label": "value_counts", "shape": "dot", "size": 20, "title": "NAME: value_counts\n------------------------------\nINPUTS: self, normalize, sort, ascending, bins, dropna\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return a Series containing counts of unique values. The resulting object will be in descending order so that the first element is the most frequently-occurring element. Excludes NA values by default. Parameters ---------- normalize : bool, default False If True...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([3, 1, 2, 3, 4, np.nan])\n\u003e\u003e\u003e index.value_counts()\n3.0    2\n1.0    1\n2.0    1\n4.0    1\nName: count, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.view", "label": "view", "shape": "dot", "size": 20, "title": "NAME: view\n------------------------------\nINPUTS: self, cls\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.RangeIndex.where", "label": "where", "shape": "dot", "size": 20, "title": "NAME: where\n------------------------------\nINPUTS: self, cond, other\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Replace values where the condition is False. The replacement is taken from other. Parameters ---------- cond : bool array-like with the same length as self Condition to select the values on. other : scalar, or array-like, default None Replacement if...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.where(idx.isin([\u0027car\u0027, \u0027train\u0027]), \u0027other\u0027)\nIndex([\u0027car\u0027, \u0027other\u0027, \u0027train\u0027, \u0027other\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.abs", "label": "abs", "shape": "dot", "size": 20, "title": "NAME: abs\n------------------------------\nINPUTS: self\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a Series/DataFrame with absolute numeric value of each element. This function only applies to elements that are all numeric. Returns ------- abs Series/DataFrame containing the absolute value of each element. See Also -------- numpy.absolute : Calculate the absolute value...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([-1.10, 2, -3.33, 4])\n\u003e\u003e\u003e s.abs()\n0    1.10\n1    2.00\n2    3.33\n3    4.00\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.add", "label": "add", "shape": "dot", "size": 20, "title": "NAME: add\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Addition of series and other, element-wise (binary operator `add`). Equivalent to ``series + other``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value level...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.add(b, fill_value=0)\na    2.0\nb    1.0\nc    1.0\nd    1.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.add_prefix", "label": "add_prefix", "shape": "dot", "size": 20, "title": "NAME: add_prefix\n------------------------------\nINPUTS: self, prefix, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Prefix labels with string `prefix`. For Series, the row labels are prefixed. For DataFrame, the column labels are prefixed. Parameters ---------- prefix : str The string to add before each label. axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027, None},...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3, 4])\n\u003e\u003e\u003e s\n0    1\n1    2\n2    3\n3    4\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.add_suffix", "label": "add_suffix", "shape": "dot", "size": 20, "title": "NAME: add_suffix\n------------------------------\nINPUTS: self, suffix, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Suffix labels with string `suffix`. For Series, the row labels are suffixed. For DataFrame, the column labels are suffixed. Parameters ---------- suffix : str The string to add after each label. axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027, None},...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3, 4])\n\u003e\u003e\u003e s\n0    1\n1    2\n2    3\n3    4\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.agg", "label": "agg", "shape": "dot", "size": 20, "title": "NAME: agg\n------------------------------\nINPUTS: self, func, axis, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Aggregate using one or more operations over the specified axis. Parameters ---------- func : function, str, list or dict Function to use for aggregating the data. If a function, must either work when passed a Series or when passed to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3, 4])\n\u003e\u003e\u003e s\n0    1\n1    2\n2    3\n3    4\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.aggregate", "label": "aggregate", "shape": "dot", "size": 20, "title": "NAME: aggregate\n------------------------------\nINPUTS: self, func, axis, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Aggregate using one or more operations over the specified axis. Parameters ---------- func : function, str, list or dict Function to use for aggregating the data. If a function, must either work when passed a Series or when passed to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3, 4])\n\u003e\u003e\u003e s\n0    1\n1    2\n2    3\n3    4\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.align", "label": "align", "shape": "dot", "size": 20, "title": "NAME: align\n------------------------------\nINPUTS: self, other, join, axis, level, copy, fill_value, method, limit, fill_axis, broadcast_axis\nOUTPUTS: tuple[Self, NDFrameT]\n------------------------------\nDESCRIPTION: Align two objects on their axes with the specified join method. Join method is specified for each axis Index. Parameters ---------- other : DataFrame or Series join : {\u0027outer\u0027, \u0027inner\u0027, \u0027left\u0027, \u0027right\u0027}, default \u0027outer\u0027 Type of alignment to be performed....\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(\n...     [[1, 2, 3, 4], [6, 7, 8, 9]], columns=[\"D\", \"B\", \"E\", \"A\"], index=[1, 2]\n... )\n\u003e\u003e\u003e other = pd.DataFrame(\n...     [[10, 20, 30, 40], [60, 70, 80, 90], [600, 700, 800, 900]],\n...     columns=[\"A\", \"B\", \"C\", \"D\"],\n...     index=[2, 3, 4],\n... )\n\u003e\u003e\u003e df\n   D  B  E  A\n1  1  2  3  4\n2  6  7  8  9\n\u003e\u003e\u003e other\n    A    B    C    D\n2   10   20   30   40\n3   60   70   80   90\n4  600  700  800  900"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.all", "label": "all", "shape": "dot", "size": 20, "title": "NAME: all\n------------------------------\nINPUTS: self, axis, bool_only, skipna, kwargs\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Return whether all elements are True, potentially over an axis. Returns True unless there at least one element within a series or along a Dataframe axis that is False or equivalent (e.g. zero or empty). Parameters ---------- axis : {0...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Series([True, True]).all()\nTrue\n\u003e\u003e\u003e pd.Series([True, False]).all()\nFalse\n\u003e\u003e\u003e pd.Series([], dtype=\"float64\").all()\nTrue\n\u003e\u003e\u003e pd.Series([np.nan]).all()\nTrue\n\u003e\u003e\u003e pd.Series([np.nan]).all(skipna=False)\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.any", "label": "any", "shape": "dot", "size": 20, "title": "NAME: any\n------------------------------\nINPUTS: self, axis, bool_only, skipna, kwargs\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Return whether any element is True, potentially over an axis. Returns False unless there is at least one element within a series or along a Dataframe axis that is True or equivalent (e.g. non-zero or non-empty). Parameters ---------- axis :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Series([False, False]).any()\nFalse\n\u003e\u003e\u003e pd.Series([True, False]).any()\nTrue\n\u003e\u003e\u003e pd.Series([], dtype=\"float64\").any()\nFalse\n\u003e\u003e\u003e pd.Series([np.nan]).any()\nFalse\n\u003e\u003e\u003e pd.Series([np.nan]).any(skipna=False)\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.apply", "label": "apply", "shape": "dot", "size": 20, "title": "NAME: apply\n------------------------------\nINPUTS: self, func, convert_dtype, args, by_row, kwargs\nOUTPUTS: DataFrame | Series\n------------------------------\nDESCRIPTION: Invoke function on values of Series. Can be ufunc (a NumPy function that applies to the entire Series) or a Python function that only works on single values. Parameters ---------- func : function Python function or NumPy ufunc to apply....\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([20, 21, 12],\n...               index=[\u0027London\u0027, \u0027New York\u0027, \u0027Helsinki\u0027])\n\u003e\u003e\u003e s\nLondon      20\nNew York    21\nHelsinki    12\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.argmax", "label": "argmax", "shape": "dot", "size": 20, "title": "NAME: argmax\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the largest value in the Series. If the maximum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.argmin", "label": "argmin", "shape": "dot", "size": 20, "title": "NAME: argmin\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the smallest value in the Series. If the minimum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.argsort", "label": "argsort", "shape": "dot", "size": 20, "title": "NAME: argsort\n------------------------------\nINPUTS: self, axis, kind, order, stable\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return the integer indices that would sort the Series values. Override ndarray.argsort. Argsorts the value, omitting NA/null values, and places the result in the same locations as the non-NA values. Parameters ---------- axis : {0 or \u0027index\u0027} Unused. Parameter needed...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([3, 2, 1])\n\u003e\u003e\u003e s.argsort()\n0    2\n1    1\n2    0\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.asfreq", "label": "asfreq", "shape": "dot", "size": 20, "title": "NAME: asfreq\n------------------------------\nINPUTS: self, freq, method, how, normalize, fill_value\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Convert time series to specified frequency. Returns the original data conformed to a new index with the specified frequency. If the index of this Series/DataFrame is a :class:`~pandas.PeriodIndex`, the new index is the result of transforming the original index with...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.date_range(\u00271/1/2000\u0027, periods=4, freq=\u0027min\u0027)\n\u003e\u003e\u003e series = pd.Series([0.0, None, 2.0, 3.0], index=index)\n\u003e\u003e\u003e df = pd.DataFrame({\u0027s\u0027: series})\n\u003e\u003e\u003e df\n                       s\n2000-01-01 00:00:00    0.0\n2000-01-01 00:01:00    NaN\n2000-01-01 00:02:00    2.0\n2000-01-01 00:03:00    3.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.asof", "label": "asof", "shape": "dot", "size": 20, "title": "NAME: asof\n------------------------------\nINPUTS: self, where, subset\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the last row(s) without any NaNs before `where`. The last row (for each element in `where`, if list) without any NaN is taken. In case of a :class:`~pandas.DataFrame`, the last row without NaN considering only the subset of columns...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, np.nan, 4], index=[10, 20, 30, 40])\n\u003e\u003e\u003e s\n10    1.0\n20    2.0\n30    NaN\n40    4.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.astype", "label": "astype", "shape": "dot", "size": 20, "title": "NAME: astype\n------------------------------\nINPUTS: self, dtype, copy, errors\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Cast a pandas object to a specified dtype ``dtype``. Parameters ---------- dtype : str, data type, Series or Mapping of column name -\u003e data type Use a str, numpy.dtype, pandas.ExtensionDtype or Python type to cast entire pandas object to the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e d = {\u0027col1\u0027: [1, 2], \u0027col2\u0027: [3, 4]}\n\u003e\u003e\u003e df = pd.DataFrame(data=d)\n\u003e\u003e\u003e df.dtypes\ncol1    int64\ncol2    int64\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.at_time", "label": "at_time", "shape": "dot", "size": 20, "title": "NAME: at_time\n------------------------------\nINPUTS: self, time, asof, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Select values at particular time of day (e.g., 9:30AM). Parameters ---------- time : datetime.time or str The values to select. axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 For `Series` this parameter is unused and defaults to 0....\n\n\nEXAMPLE:\n\u003e\u003e\u003e i = pd.date_range(\u00272018-04-09\u0027, periods=4, freq=\u002712h\u0027)\n\u003e\u003e\u003e ts = pd.DataFrame({\u0027A\u0027: [1, 2, 3, 4]}, index=i)\n\u003e\u003e\u003e ts\n                     A\n2018-04-09 00:00:00  1\n2018-04-09 12:00:00  2\n2018-04-10 00:00:00  3\n2018-04-10 12:00:00  4"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.autocorr", "label": "autocorr", "shape": "dot", "size": 20, "title": "NAME: autocorr\n------------------------------\nINPUTS: self, lag\nOUTPUTS: float\n------------------------------\nDESCRIPTION: Compute the lag-N autocorrelation. This method computes the Pearson correlation between the Series and its shifted self. Parameters ---------- lag : int, default 1 Number of lags to apply before performing autocorrelation. Returns ------- float The Pearson correlation between self...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([0.25, 0.5, 0.2, -0.05])\n\u003e\u003e\u003e s.autocorr()  # doctest: +ELLIPSIS\n0.10355...\n\u003e\u003e\u003e s.autocorr(lag=2)  # doctest: +ELLIPSIS\n-0.99999..."}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.backfill", "label": "backfill", "shape": "dot", "size": 20, "title": "NAME: backfill\n------------------------------\nINPUTS: self, axis, inplace, limit, downcast\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Fill NA/NaN values by using the next valid observation to fill the gap. .. deprecated:: 2.0 Series/DataFrame.backfill is deprecated. Use Series/DataFrame.bfill instead. Returns ------- Series/DataFrame or None Object with missing values filled or None if ``inplace=True``. Examples -------- Please see...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.between", "label": "between", "shape": "dot", "size": 20, "title": "NAME: between\n------------------------------\nINPUTS: self, left, right, inclusive\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return boolean Series equivalent to left \u003c= series \u003c= right. This function returns a boolean vector containing `True` wherever the corresponding Series element is between the boundary values `left` and `right`. NA values are treated as `False`. Parameters ---------- left...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([2, 0, 4, 8, np.nan])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.between_time", "label": "between_time", "shape": "dot", "size": 20, "title": "NAME: between_time\n------------------------------\nINPUTS: self, start_time, end_time, inclusive, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Select values between particular times of the day (e.g., 9:00-9:30 AM). By setting ``start_time`` to be later than ``end_time``, you can get the times that are *not* between the two times. Parameters ---------- start_time : datetime.time or str Initial time...\n\n\nEXAMPLE:\n\u003e\u003e\u003e i = pd.date_range(\u00272018-04-09\u0027, periods=4, freq=\u00271D20min\u0027)\n\u003e\u003e\u003e ts = pd.DataFrame({\u0027A\u0027: [1, 2, 3, 4]}, index=i)\n\u003e\u003e\u003e ts\n                     A\n2018-04-09 00:00:00  1\n2018-04-10 00:20:00  2\n2018-04-11 00:40:00  3\n2018-04-12 01:00:00  4"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.bfill", "label": "bfill", "shape": "dot", "size": 20, "title": "NAME: bfill\n------------------------------\nINPUTS: self, axis, inplace, limit, limit_area, downcast\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Fill NA/NaN values by using the next valid observation to fill the gap. Parameters ---------- axis : {0 or \u0027index\u0027} for Series, {0 or \u0027index\u0027, 1 or \u0027columns\u0027} for DataFrame Axis along which to fill missing values. For `Series` this...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, None, None, 2])\n\u003e\u003e\u003e s.bfill()\n0    1.0\n1    2.0\n2    2.0\n3    2.0\ndtype: float64\n\u003e\u003e\u003e s.bfill(limit=1)\n0    1.0\n1    NaN\n2    2.0\n3    2.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.bool", "label": "bool", "shape": "dot", "size": 20, "title": "NAME: bool\n------------------------------\nINPUTS: self\nOUTPUTS: bool_t\n------------------------------\nDESCRIPTION: Return the bool of a single element Series or DataFrame. .. deprecated:: 2.1.0 bool is deprecated and will be removed in future version of pandas. For ``Series`` use ``pandas.Series.item``. This must be a boolean scalar value, either True or False....\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Series([True]).bool()  # doctest: +SKIP\nTrue\n\u003e\u003e\u003e pd.Series([False]).bool()  # doctest: +SKIP\nFalse"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.case_when", "label": "case_when", "shape": "dot", "size": 20, "title": "NAME: case_when\n------------------------------\nINPUTS: self, caselist\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Replace values where the conditions are True. Parameters ---------- caselist : A list of tuples of conditions and expected replacements Takes the form: ``(condition0, replacement0)``, ``(condition1, replacement1)``, ... . ``condition`` should be a 1-D boolean array-like object or a callable....\n\n\nEXAMPLE:\n\u003e\u003e\u003e c = pd.Series([6, 7, 8, 9], name=\u0027c\u0027)\n\u003e\u003e\u003e a = pd.Series([0, 0, 1, 2])\n\u003e\u003e\u003e b = pd.Series([0, 3, 4, 5])"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Series.cat", "label": "cat", "shape": "dot", "size": 20, "title": "NAME: cat\n------------------------------\nINPUTS: data\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Accessor object for categorical properties of the Series values. Parameters ---------- data : Series or CategoricalIndex Examples -------- \u003e\u003e\u003e s = pd.Series(list(\"abbccc\")).astype(\"category\") \u003e\u003e\u003e s 0 a 1 b 2 b 3 c 4 c 5 c dtype: category Categories (3,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(list(\"abbccc\")).astype(\"category\")\n\u003e\u003e\u003e s\n0    a\n1    b\n2    b\n3    c\n4    c\n5    c\ndtype: category\nCategories (3, object): [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.clip", "label": "clip", "shape": "dot", "size": 20, "title": "NAME: clip\n------------------------------\nINPUTS: self, lower, upper, axis, inplace, kwargs\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Trim values at input threshold(s). Assigns values outside boundary to boundary values. Thresholds can be singular values or array like, and in the latter case the clipping is performed element-wise in the specified axis. Parameters ---------- lower : float or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e data = {\u0027col_0\u0027: [9, -3, 0, -1, 5], \u0027col_1\u0027: [-2, -7, 6, 8, -5]}\n\u003e\u003e\u003e df = pd.DataFrame(data)\n\u003e\u003e\u003e df\n   col_0  col_1\n0      9     -2\n1     -3     -7\n2      0      6\n3     -1      8\n4      5     -5"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.combine", "label": "combine", "shape": "dot", "size": 20, "title": "NAME: combine\n------------------------------\nINPUTS: self, other, func, fill_value\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Combine the Series with a Series or scalar according to `func`. Combine the Series and `other` using `func` to perform elementwise selection for combined Series. `fill_value` is assumed when value is missing at some index from one of the two...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s1 = pd.Series({\u0027falcon\u0027: 330.0, \u0027eagle\u0027: 160.0})\n\u003e\u003e\u003e s1\nfalcon    330.0\neagle     160.0\ndtype: float64\n\u003e\u003e\u003e s2 = pd.Series({\u0027falcon\u0027: 345.0, \u0027eagle\u0027: 200.0, \u0027duck\u0027: 30.0})\n\u003e\u003e\u003e s2\nfalcon    345.0\neagle     200.0\nduck       30.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.combine_first", "label": "combine_first", "shape": "dot", "size": 20, "title": "NAME: combine_first\n------------------------------\nINPUTS: self, other\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Update null elements with value in the same location in \u0027other\u0027. Combine two Series objects by filling null values in one Series with non-null values from the other Series. Result index will be the union of the two indexes. Parameters...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s1 = pd.Series([1, np.nan])\n\u003e\u003e\u003e s2 = pd.Series([3, 4, 5])\n\u003e\u003e\u003e s1.combine_first(s2)\n0    1.0\n1    4.0\n2    5.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.compare", "label": "compare", "shape": "dot", "size": 20, "title": "NAME: compare\n------------------------------\nINPUTS: self, other, align_axis, keep_shape, keep_equal, result_names\nOUTPUTS: DataFrame | Series\n------------------------------\nDESCRIPTION: Compare to another Series and show the differences. Parameters ---------- other : Series Object to compare with. align_axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 1 Determine which axis to align the comparison on. * 0, or \u0027index\u0027 :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s1 = pd.Series([\"a\", \"b\", \"c\", \"d\", \"e\"])\n\u003e\u003e\u003e s2 = pd.Series([\"a\", \"a\", \"c\", \"b\", \"e\"])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.convert_dtypes", "label": "convert_dtypes", "shape": "dot", "size": 20, "title": "NAME: convert_dtypes\n------------------------------\nINPUTS: self, infer_objects, convert_string, convert_integer, convert_boolean, convert_floating, dtype_backend\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Convert columns to the best possible dtypes using dtypes supporting ``pd.NA``. Parameters ---------- infer_objects : bool, default True Whether object dtypes should be converted to the best possible types. convert_string : bool, default True Whether object dtypes should be converted...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(\n...     {\n...         \"a\": pd.Series([1, 2, 3], dtype=np.dtype(\"int32\")),\n...         \"b\": pd.Series([\"x\", \"y\", \"z\"], dtype=np.dtype(\"O\")),\n...         \"c\": pd.Series([True, False, np.nan], dtype=np.dtype(\"O\")),\n...         \"d\": pd.Series([\"h\", \"i\", np.nan], dtype=np.dtype(\"O\")),\n...         \"e\": pd.Series([10, np.nan, 20], dtype=np.dtype(\"float\")),\n...         \"f\": pd.Series([np.nan, 100.5, 200], dtype=np.dtype(\"float\")),\n...     }\n... )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.copy", "label": "copy", "shape": "dot", "size": 20, "title": "NAME: copy\n------------------------------\nINPUTS: self, deep\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make a copy of this object\u0027s indices and data. When ``deep=True`` (default), a new object will be created with a copy of the calling object\u0027s data and indices. Modifications to the data or indices of the copy will not be...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2], index=[\"a\", \"b\"])\n\u003e\u003e\u003e s\na    1\nb    2\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.corr", "label": "corr", "shape": "dot", "size": 20, "title": "NAME: corr\n------------------------------\nINPUTS: self, other, method, min_periods\nOUTPUTS: float\n------------------------------\nDESCRIPTION: Compute correlation with `other` Series, excluding missing values. The two `Series` objects are not required to be the same length and will be aligned internally before the correlation function is applied. Parameters ---------- other : Series Series with which to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e def histogram_intersection(a, b):\n...     v = np.minimum(a, b).sum().round(decimals=1)\n...     return v\n\u003e\u003e\u003e s1 = pd.Series([.2, .0, .6, .2])\n\u003e\u003e\u003e s2 = pd.Series([.3, .6, .0, .1])\n\u003e\u003e\u003e s1.corr(s2, method=histogram_intersection)\n0.3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.count", "label": "count", "shape": "dot", "size": 20, "title": "NAME: count\n------------------------------\nINPUTS: self\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return number of non-NA/null observations in the Series. Returns ------- int Number of non-null values in the Series. See Also -------- DataFrame.count : Count non-NA cells for each column or row. Examples -------- \u003e\u003e\u003e s = pd.Series([0.0, 1.0, np.nan]) \u003e\u003e\u003e...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([0.0, 1.0, np.nan])\n\u003e\u003e\u003e s.count()\n2"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.cov", "label": "cov", "shape": "dot", "size": 20, "title": "NAME: cov\n------------------------------\nINPUTS: self, other, min_periods, ddof\nOUTPUTS: float\n------------------------------\nDESCRIPTION: Compute covariance with Series, excluding missing values. The two `Series` objects are not required to be the same length and will be aligned internally before the covariance is calculated. Parameters ---------- other : Series Series with which to compute the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s1 = pd.Series([0.90010907, 0.13484424, 0.62036035])\n\u003e\u003e\u003e s2 = pd.Series([0.12528585, 0.26962463, 0.51111198])\n\u003e\u003e\u003e s1.cov(s2)\n-0.01685762652715874"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.cummax", "label": "cummax", "shape": "dot", "size": 20, "title": "NAME: cummax\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return cumulative maximum over a DataFrame or Series axis. Returns a DataFrame or Series of the same size containing the cumulative maximum. Parameters ---------- axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 The index or the name of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([2, np.nan, 5, -1, 0])\n\u003e\u003e\u003e s\n0    2.0\n1    NaN\n2    5.0\n3   -1.0\n4    0.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.cummin", "label": "cummin", "shape": "dot", "size": 20, "title": "NAME: cummin\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return cumulative minimum over a DataFrame or Series axis. Returns a DataFrame or Series of the same size containing the cumulative minimum. Parameters ---------- axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 The index or the name of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([2, np.nan, 5, -1, 0])\n\u003e\u003e\u003e s\n0    2.0\n1    NaN\n2    5.0\n3   -1.0\n4    0.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.cumprod", "label": "cumprod", "shape": "dot", "size": 20, "title": "NAME: cumprod\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return cumulative product over a DataFrame or Series axis. Returns a DataFrame or Series of the same size containing the cumulative product. Parameters ---------- axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 The index or the name of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([2, np.nan, 5, -1, 0])\n\u003e\u003e\u003e s\n0    2.0\n1    NaN\n2    5.0\n3   -1.0\n4    0.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.cumsum", "label": "cumsum", "shape": "dot", "size": 20, "title": "NAME: cumsum\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return cumulative sum over a DataFrame or Series axis. Returns a DataFrame or Series of the same size containing the cumulative sum. Parameters ---------- axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 The index or the name of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([2, np.nan, 5, -1, 0])\n\u003e\u003e\u003e s\n0    2.0\n1    NaN\n2    5.0\n3   -1.0\n4    0.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.describe", "label": "describe", "shape": "dot", "size": 20, "title": "NAME: describe\n------------------------------\nINPUTS: self, percentiles, include, exclude\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Generate descriptive statistics. Descriptive statistics include those that summarize the central tendency, dispersion and shape of a dataset\u0027s distribution, excluding ``NaN`` values. Analyzes both numeric and object series, as well as ``DataFrame`` column sets of mixed data types. The output...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.describe()\ncount    3.0\nmean     2.0\nstd      1.0\nmin      1.0\n25%      1.5\n50%      2.0\n75%      2.5\nmax      3.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.diff", "label": "diff", "shape": "dot", "size": 20, "title": "NAME: diff\n------------------------------\nINPUTS: self, periods\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: First discrete difference of element. Calculates the difference of a Series element compared with another element in the Series (default is element in previous row). Parameters ---------- periods : int, default 1 Periods to shift for calculating difference, accepts negative...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 1, 2, 3, 5, 8])\n\u003e\u003e\u003e s.diff()\n0    NaN\n1    0.0\n2    1.0\n3    1.0\n4    2.0\n5    3.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.div", "label": "div", "shape": "dot", "size": 20, "title": "NAME: div\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Floating division of series and other, element-wise (binary operator `truediv`). Equivalent to ``series / other``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.divide(b, fill_value=0)\na    1.0\nb    inf\nc    inf\nd    0.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.divide", "label": "divide", "shape": "dot", "size": 20, "title": "NAME: divide\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Floating division of series and other, element-wise (binary operator `truediv`). Equivalent to ``series / other``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.divide(b, fill_value=0)\na    1.0\nb    inf\nc    inf\nd    0.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.divmod", "label": "divmod", "shape": "dot", "size": 20, "title": "NAME: divmod\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Integer division and modulo of series and other, element-wise (binary operator `divmod`). Equivalent to ``divmod(series, other)``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.divmod(b, fill_value=0)\n(a    1.0\n b    inf\n c    inf\n d    0.0\n e    NaN\n dtype: float64,\n a    0.0\n b    NaN\n c    NaN\n d    0.0\n e    NaN\n dtype: float64)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.dot", "label": "dot", "shape": "dot", "size": 20, "title": "NAME: dot\n------------------------------\nINPUTS: self, other\nOUTPUTS: Series | np.ndarray\n------------------------------\nDESCRIPTION: Compute the dot product between the Series and the columns of other. This method computes the dot product between the Series and another one, or the Series and each columns of a DataFrame, or the Series and each columns of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([0, 1, 2, 3])\n\u003e\u003e\u003e other = pd.Series([-1, 2, -3, 4])\n\u003e\u003e\u003e s.dot(other)\n8\n\u003e\u003e\u003e s @ other\n8\n\u003e\u003e\u003e df = pd.DataFrame([[0, 1], [-2, 3], [4, -5], [6, 7]])\n\u003e\u003e\u003e s.dot(df)\n0    24\n1    14\ndtype: int64\n\u003e\u003e\u003e arr = np.array([[0, 1], [-2, 3], [4, -5], [6, 7]])\n\u003e\u003e\u003e s.dot(arr)\narray([24, 14])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.drop", "label": "drop", "shape": "dot", "size": 20, "title": "NAME: drop\n------------------------------\nINPUTS: self, labels, axis, index, columns, level, inplace, errors\nOUTPUTS: Series | None\n------------------------------\nDESCRIPTION: Return Series with specified index labels removed. Remove elements of a Series based on specifying the index labels. When using a multi-index, labels on different levels can be removed by specifying the level. Parameters ---------- labels : single label or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(data=np.arange(3), index=[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027])\n\u003e\u003e\u003e s\nA  0\nB  1\nC  2\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.drop_duplicates", "label": "drop_duplicates", "shape": "dot", "size": 20, "title": "NAME: drop_duplicates\n------------------------------\nINPUTS: self, keep, inplace, ignore_index\nOUTPUTS: Series | None\n------------------------------\nDESCRIPTION: Return Series with duplicate values removed. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, ``False``}, default \u0027first\u0027 Method to handle dropping duplicates: - \u0027first\u0027 : Drop duplicates except for the first occurrence. - \u0027last\u0027 : Drop duplicates except for the last occurrence....\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\u0027llama\u0027, \u0027cow\u0027, \u0027llama\u0027, \u0027beetle\u0027, \u0027llama\u0027, \u0027hippo\u0027],\n...               name=\u0027animal\u0027)\n\u003e\u003e\u003e s\n0     llama\n1       cow\n2     llama\n3    beetle\n4     llama\n5     hippo\nName: animal, dtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.droplevel", "label": "droplevel", "shape": "dot", "size": 20, "title": "NAME: droplevel\n------------------------------\nINPUTS: self, level, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return Series/DataFrame with requested index / column level(s) removed. Parameters ---------- level : int, str, or list-like If a string is given, must be the name of a level If list-like, elements must be names or positional indexes of levels....\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([\n...     [1, 2, 3, 4],\n...     [5, 6, 7, 8],\n...     [9, 10, 11, 12]\n... ]).set_index([0, 1]).rename_axis([\u0027a\u0027, \u0027b\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.dropna", "label": "dropna", "shape": "dot", "size": 20, "title": "NAME: dropna\n------------------------------\nINPUTS: self, axis, inplace, how, ignore_index\nOUTPUTS: Series | None\n------------------------------\nDESCRIPTION: Return a new Series with missing values removed. See the :ref:`User Guide \u003cmissing_data\u003e` for more on which values are considered missing, and how to work with missing data. Parameters ---------- axis : {0 or \u0027index\u0027} Unused. Parameter needed for compatibility...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([1., 2., np.nan])\n\u003e\u003e\u003e ser\n0    1.0\n1    2.0\n2    NaN\ndtype: float64"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Series.dt", "label": "dt", "shape": "dot", "size": 20, "title": "NAME: dt\n------------------------------\nINPUTS: data\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Accessor object for datetimelike properties of the Series values. Examples -------- \u003e\u003e\u003e seconds_series = pd.Series(pd.date_range(\"2000-01-01\", periods=3, freq=\"s\")) \u003e\u003e\u003e seconds_series 0 2000-01-01 00:00:00 1 2000-01-01 00:00:01 2 2000-01-01 00:00:02 dtype: datetime64[ns] \u003e\u003e\u003e seconds_series.dt.second 0 0 1 1 2 2 dtype: int32...\n\n\nEXAMPLE:\n\u003e\u003e\u003e seconds_series = pd.Series(pd.date_range(\"2000-01-01\", periods=3, freq=\"s\"))\n\u003e\u003e\u003e seconds_series\n0   2000-01-01 00:00:00\n1   2000-01-01 00:00:01\n2   2000-01-01 00:00:02\ndtype: datetime64[ns]\n\u003e\u003e\u003e seconds_series.dt.second\n0    0\n1    1\n2    2\ndtype: int32"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.duplicated", "label": "duplicated", "shape": "dot", "size": 20, "title": "NAME: duplicated\n------------------------------\nINPUTS: self, keep\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Indicate duplicate Series values. Duplicated values are indicated as ``True`` values in the resulting Series. Either all duplicates, all except the first or all except the last occurrence of duplicates can be indicated. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, False},...\n\n\nEXAMPLE:\n\u003e\u003e\u003e animals = pd.Series([\u0027llama\u0027, \u0027cow\u0027, \u0027llama\u0027, \u0027beetle\u0027, \u0027llama\u0027])\n\u003e\u003e\u003e animals.duplicated()\n0    False\n1    False\n2     True\n3    False\n4     True\ndtype: bool"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.eq", "label": "eq", "shape": "dot", "size": 20, "title": "NAME: eq\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Equal to of series and other, element-wise (binary operator `eq`). Equivalent to ``series == other``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.eq(b, fill_value=0)\na     True\nb    False\nc    False\nd    False\ne    False\ndtype: bool"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.equals", "label": "equals", "shape": "dot", "size": 20, "title": "NAME: equals\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool_t\n------------------------------\nDESCRIPTION: Test whether two objects contain the same elements. This function allows two Series or DataFrames to be compared against each other to see if they have the same shape and elements. NaNs in the same location are considered equal. The...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({1: [10], 2: [20]})\n\u003e\u003e\u003e df\n    1   2\n0  10  20"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.ewm", "label": "ewm", "shape": "dot", "size": 20, "title": "NAME: ewm\n------------------------------\nINPUTS: self, com, span, halflife, alpha, min_periods, adjust, ignore_na, axis, times, method\nOUTPUTS: ExponentialMovingWindow\n------------------------------\nDESCRIPTION: Provide exponentially weighted (EW) calculations. Exactly one of ``com``, ``span``, ``halflife``, or ``alpha`` must be provided if ``times`` is not provided. If ``times`` is provided, ``halflife`` and one of ``com``, ``span`` or ``alpha`` may be provided. Parameters ---------- com :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027B\u0027: [0, 1, 2, np.nan, 4]})\n\u003e\u003e\u003e df\n     B\n0  0.0\n1  1.0\n2  2.0\n3  NaN\n4  4.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.expanding", "label": "expanding", "shape": "dot", "size": 20, "title": "NAME: expanding\n------------------------------\nINPUTS: self, min_periods, axis, method\nOUTPUTS: Expanding\n------------------------------\nDESCRIPTION: Provide expanding window calculations. Parameters ---------- min_periods : int, default 1 Minimum number of observations in window required to have a value; otherwise, result is ``np.nan``. axis : int or str, default 0 If ``0`` or ``\u0027index\u0027``, roll across the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"B\": [0, 1, 2, np.nan, 4]})\n\u003e\u003e\u003e df\n     B\n0  0.0\n1  1.0\n2  2.0\n3  NaN\n4  4.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.explode", "label": "explode", "shape": "dot", "size": 20, "title": "NAME: explode\n------------------------------\nINPUTS: self, ignore_index\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Transform each element of a list-like to a row. Parameters ---------- ignore_index : bool, default False If True, the resulting index will be labeled 0, 1, \u2026, n - 1. Returns ------- Series Exploded lists to rows; index will be...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([[1, 2, 3], \u0027foo\u0027, [], [3, 4]])\n\u003e\u003e\u003e s\n0    [1, 2, 3]\n1          foo\n2           []\n3       [3, 4]\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.factorize", "label": "factorize", "shape": "dot", "size": 20, "title": "NAME: factorize\n------------------------------\nINPUTS: self, sort, use_na_sentinel\nOUTPUTS: tuple[npt.NDArray[np.intp], Index]\n------------------------------\nDESCRIPTION: Encode the object as an enumerated type or categorical variable. This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct values. `factorize` is available as both a top-level function :func:`pandas.factorize`, and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e codes, uniques = pd.factorize(np.array([\u0027b\u0027, \u0027b\u0027, \u0027a\u0027, \u0027c\u0027, \u0027b\u0027], dtype=\"O\"))\n\u003e\u003e\u003e codes\narray([0, 0, 1, 2, 0])\n\u003e\u003e\u003e uniques\narray([\u0027b\u0027, \u0027a\u0027, \u0027c\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.ffill", "label": "ffill", "shape": "dot", "size": 20, "title": "NAME: ffill\n------------------------------\nINPUTS: self, axis, inplace, limit, limit_area, downcast\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Fill NA/NaN values by propagating the last valid observation to next valid. Parameters ---------- axis : {0 or \u0027index\u0027} for Series, {0 or \u0027index\u0027, 1 or \u0027columns\u0027} for DataFrame Axis along which to fill missing values. For `Series` this parameter...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[np.nan, 2, np.nan, 0],\n...                    [3, 4, np.nan, 1],\n...                    [np.nan, np.nan, np.nan, np.nan],\n...                    [np.nan, 3, np.nan, 4]],\n...                   columns=list(\"ABCD\"))\n\u003e\u003e\u003e df\n     A    B   C    D\n0  NaN  2.0 NaN  0.0\n1  3.0  4.0 NaN  1.0\n2  NaN  NaN NaN  NaN\n3  NaN  3.0 NaN  4.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.fillna", "label": "fillna", "shape": "dot", "size": 20, "title": "NAME: fillna\n------------------------------\nINPUTS: self, value, method, axis, inplace, limit, downcast\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Fill NA/NaN values using the specified method. Parameters ---------- value : scalar, dict, Series, or DataFrame Value to use to fill holes (e.g. 0), alternately a dict/Series/DataFrame of values specifying which value to use for each index (for a Series)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[np.nan, 2, np.nan, 0],\n...                    [3, 4, np.nan, 1],\n...                    [np.nan, np.nan, np.nan, np.nan],\n...                    [np.nan, 3, np.nan, 4]],\n...                   columns=list(\"ABCD\"))\n\u003e\u003e\u003e df\n     A    B   C    D\n0  NaN  2.0 NaN  0.0\n1  3.0  4.0 NaN  1.0\n2  NaN  NaN NaN  NaN\n3  NaN  3.0 NaN  4.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.filter", "label": "filter", "shape": "dot", "size": 20, "title": "NAME: filter\n------------------------------\nINPUTS: self, items, like, regex, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Subset the dataframe rows or columns according to the specified index labels. Note that this routine does not filter a dataframe on its contents. The filter is applied to the labels of the index. Parameters ---------- items : list-like Keep...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(np.array(([1, 2, 3], [4, 5, 6])),\n...                   index=[\u0027mouse\u0027, \u0027rabbit\u0027],\n...                   columns=[\u0027one\u0027, \u0027two\u0027, \u0027three\u0027])\n\u003e\u003e\u003e df\n        one  two  three\nmouse     1    2      3\nrabbit    4    5      6"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.first", "label": "first", "shape": "dot", "size": 20, "title": "NAME: first\n------------------------------\nINPUTS: self, offset\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Select initial periods of time series data based on a date offset. .. deprecated:: 2.1 :meth:`.first` is deprecated and will be removed in a future version. Please create a mask and filter using `.loc` instead. For a DataFrame with a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e i = pd.date_range(\u00272018-04-09\u0027, periods=4, freq=\u00272D\u0027)\n\u003e\u003e\u003e ts = pd.DataFrame({\u0027A\u0027: [1, 2, 3, 4]}, index=i)\n\u003e\u003e\u003e ts\n            A\n2018-04-09  1\n2018-04-11  2\n2018-04-13  3\n2018-04-15  4"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.first_valid_index", "label": "first_valid_index", "shape": "dot", "size": 20, "title": "NAME: first_valid_index\n------------------------------\nINPUTS: self\nOUTPUTS: Hashable | None\n------------------------------\nDESCRIPTION: Return index for first non-NA value or None, if no non-NA value is found. Returns ------- type of index Examples -------- For Series: \u003e\u003e\u003e s = pd.Series([None, 3, 4]) \u003e\u003e\u003e s.first_valid_index() 1 \u003e\u003e\u003e s.last_valid_index() 2 \u003e\u003e\u003e s = pd.Series([None, None])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([None, 3, 4])\n\u003e\u003e\u003e s.first_valid_index()\n1\n\u003e\u003e\u003e s.last_valid_index()\n2"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.floordiv", "label": "floordiv", "shape": "dot", "size": 20, "title": "NAME: floordiv\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Integer division of series and other, element-wise (binary operator `floordiv`). Equivalent to ``series // other``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.floordiv(b, fill_value=0)\na    1.0\nb    inf\nc    inf\nd    0.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.ge", "label": "ge", "shape": "dot", "size": 20, "title": "NAME: ge\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Greater than or equal to of series and other, element-wise (binary operator `ge`). Equivalent to ``series \u003e= other``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan, 1], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ne    1.0\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([0, 1, 2, np.nan, 1], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027f\u0027])\n\u003e\u003e\u003e b\na    0.0\nb    1.0\nc    2.0\nd    NaN\nf    1.0\ndtype: float64\n\u003e\u003e\u003e a.ge(b, fill_value=0)\na     True\nb     True\nc    False\nd    False\ne     True\nf    False\ndtype: bool"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.get", "label": "get", "shape": "dot", "size": 20, "title": "NAME: get\n------------------------------\nINPUTS: self, key, default\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Get item from object for given key (ex: DataFrame column). Returns default value if not found. Parameters ---------- key : object Returns ------- same type as items contained in object Examples -------- \u003e\u003e\u003e df = pd.DataFrame( ... [ ... [24.3,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(\n...     [\n...         [24.3, 75.7, \"high\"],\n...         [31, 87.8, \"high\"],\n...         [22, 71.6, \"medium\"],\n...         [35, 95, \"medium\"],\n...     ],\n...     columns=[\"temp_celsius\", \"temp_fahrenheit\", \"windspeed\"],\n...     index=pd.date_range(start=\"2014-02-12\", end=\"2014-02-15\", freq=\"D\"),\n... )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.groupby", "label": "groupby", "shape": "dot", "size": 20, "title": "NAME: groupby\n------------------------------\nINPUTS: self, by, axis, level, as_index, sort, group_keys, observed, dropna\nOUTPUTS: SeriesGroupBy\n------------------------------\nDESCRIPTION: Group Series using a mapper or by a Series of columns. A groupby operation involves some combination of splitting the object, applying a function, and combining the results. This can be used to group large amounts of data and compute...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([390., 350., 30., 20.],\n...                 index=[\u0027Falcon\u0027, \u0027Falcon\u0027, \u0027Parrot\u0027, \u0027Parrot\u0027],\n...                 name=\"Max Speed\")\n\u003e\u003e\u003e ser\nFalcon    390.0\nFalcon    350.0\nParrot     30.0\nParrot     20.0\nName: Max Speed, dtype: float64\n\u003e\u003e\u003e ser.groupby([\"a\", \"b\", \"a\", \"b\"]).mean()\na    210.0\nb    185.0\nName: Max Speed, dtype: float64\n\u003e\u003e\u003e ser.groupby(level=0).mean()\nFalcon    370.0\nParrot     25.0\nName: Max Speed, dtype: float64\n\u003e\u003e\u003e ser.groupby(ser \u003e 100).mean()\nMax Speed\nFalse     25.0\nTrue     370.0\nName: Max Speed, dtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.gt", "label": "gt", "shape": "dot", "size": 20, "title": "NAME: gt\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Greater than of series and other, element-wise (binary operator `gt`). Equivalent to ``series \u003e other``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan, 1], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ne    1.0\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([0, 1, 2, np.nan, 1], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027f\u0027])\n\u003e\u003e\u003e b\na    0.0\nb    1.0\nc    2.0\nd    NaN\nf    1.0\ndtype: float64\n\u003e\u003e\u003e a.gt(b, fill_value=0)\na     True\nb    False\nc    False\nd    False\ne     True\nf    False\ndtype: bool"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.head", "label": "head", "shape": "dot", "size": 20, "title": "NAME: head\n------------------------------\nINPUTS: self, n\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return the first `n` rows. This function returns the first `n` rows for the object based on position. It is useful for quickly testing if your object has the right type of data in it. For negative values of `n`,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027animal\u0027: [\u0027alligator\u0027, \u0027bee\u0027, \u0027falcon\u0027, \u0027lion\u0027,\n...                    \u0027monkey\u0027, \u0027parrot\u0027, \u0027shark\u0027, \u0027whale\u0027, \u0027zebra\u0027]})\n\u003e\u003e\u003e df\n      animal\n0  alligator\n1        bee\n2     falcon\n3       lion\n4     monkey\n5     parrot\n6      shark\n7      whale\n8      zebra"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.hist", "label": "hist", "shape": "dot", "size": 20, "title": "NAME: hist\n------------------------------\nINPUTS: self, by, ax, grid, xlabelsize, xrot, ylabelsize, yrot, figsize, bins, backend, legend, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Draw histogram of the input series using matplotlib. Parameters ---------- by : object, optional If passed, then used to form histograms for separate groups. ax : matplotlib axis object If not passed, uses gca(). grid : bool, default True Whether...\n\n\nEXAMPLE:\n\u003e\u003e\u003e lst = [\u0027a\u0027, \u0027a\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027b\u0027]\n    \u003e\u003e\u003e ser = pd.Series([1, 2, 2, 4, 6, 6], index=lst)\n    \u003e\u003e\u003e hist = ser.hist()"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.idxmax", "label": "idxmax", "shape": "dot", "size": 20, "title": "NAME: idxmax\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Hashable\n------------------------------\nDESCRIPTION: Return the row label of the maximum value. If multiple values equal the maximum, the first row label with that value is returned. Parameters ---------- axis : {0 or \u0027index\u0027} Unused. Parameter needed for compatibility with DataFrame. skipna : bool,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(data=[1, None, 4, 3, 4],\n...               index=[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027, \u0027D\u0027, \u0027E\u0027])\n\u003e\u003e\u003e s\nA    1.0\nB    NaN\nC    4.0\nD    3.0\nE    4.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.idxmin", "label": "idxmin", "shape": "dot", "size": 20, "title": "NAME: idxmin\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Hashable\n------------------------------\nDESCRIPTION: Return the row label of the minimum value. If multiple values equal the minimum, the first row label with that value is returned. Parameters ---------- axis : {0 or \u0027index\u0027} Unused. Parameter needed for compatibility with DataFrame. skipna : bool,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(data=[1, None, 4, 1],\n...               index=[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027, \u0027D\u0027])\n\u003e\u003e\u003e s\nA    1.0\nB    NaN\nC    4.0\nD    1.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.infer_objects", "label": "infer_objects", "shape": "dot", "size": 20, "title": "NAME: infer_objects\n------------------------------\nINPUTS: self, copy\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Attempt to infer better dtypes for object columns. Attempts soft conversion of object-dtyped columns, leaving non-object and unconvertible columns unchanged. The inference rules are the same as during normal Series/DataFrame construction. Parameters ---------- copy : bool, default True Whether to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"A\": [\"a\", 1, 2, 3]})\n\u003e\u003e\u003e df = df.iloc[1:]\n\u003e\u003e\u003e df\n   A\n1  1\n2  2\n3  3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.info", "label": "info", "shape": "dot", "size": 20, "title": "NAME: info\n------------------------------\nINPUTS: self, verbose, buf, max_cols, memory_usage, show_counts\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Print a concise summary of a Series. This method prints information about a Series including the index dtype, non-null values and memory usage. .. versionadded:: 1.4.0 Parameters ---------- verbose : bool, optional Whether to print the full summary. By default,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e int_values = [1, 2, 3, 4, 5]\n\u003e\u003e\u003e text_values = [\u0027alpha\u0027, \u0027beta\u0027, \u0027gamma\u0027, \u0027delta\u0027, \u0027epsilon\u0027]\n\u003e\u003e\u003e s = pd.Series(text_values, index=int_values)\n\u003e\u003e\u003e s.info()\n\u003cclass \u0027pandas.core.series.Series\u0027\u003e\nIndex: 5 entries, 1 to 5\nSeries name: None\nNon-Null Count  Dtype\n--------------  -----\n5 non-null      object\ndtypes: object(1)\nmemory usage: 80.0+ bytes"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.interpolate", "label": "interpolate", "shape": "dot", "size": 20, "title": "NAME: interpolate\n------------------------------\nINPUTS: self, method, axis, limit, inplace, limit_direction, limit_area, downcast, kwargs\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Fill NaN values using an interpolation method. Please note that only ``method=\u0027linear\u0027`` is supported for DataFrame/Series with a MultiIndex. Parameters ---------- method : str, default \u0027linear\u0027 Interpolation technique to use. One of: * \u0027linear\u0027: Ignore the index and treat the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([0, 1, np.nan, 3])\n\u003e\u003e\u003e s\n0    0.0\n1    1.0\n2    NaN\n3    3.0\ndtype: float64\n\u003e\u003e\u003e s.interpolate()\n0    0.0\n1    1.0\n2    2.0\n3    3.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.isin", "label": "isin", "shape": "dot", "size": 20, "title": "NAME: isin\n------------------------------\nINPUTS: self, values\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Whether elements in Series are contained in `values`. Return a boolean Series showing whether each element in the Series matches an element in the passed sequence of `values` exactly. Parameters ---------- values : set or list-like The sequence of values...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\u0027llama\u0027, \u0027cow\u0027, \u0027llama\u0027, \u0027beetle\u0027, \u0027llama\u0027,\n...                \u0027hippo\u0027], name=\u0027animal\u0027)\n\u003e\u003e\u003e s.isin([\u0027cow\u0027, \u0027llama\u0027])\n0     True\n1     True\n2     True\n3    False\n4     True\n5    False\nName: animal, dtype: bool"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.isna", "label": "isna", "shape": "dot", "size": 20, "title": "NAME: isna\n------------------------------\nINPUTS: self\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as None or :attr:`numpy.NaN`, gets mapped to True values. Everything else gets mapped to False values. Characters such as empty strings ``\u0027\u0027`` or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(dict(age=[5, 6, np.nan],\n...                        born=[pd.NaT, pd.Timestamp(\u00271939-05-27\u0027),\n...                              pd.Timestamp(\u00271940-04-25\u0027)],\n...                        name=[\u0027Alfred\u0027, \u0027Batman\u0027, \u0027\u0027],\n...                        toy=[None, \u0027Batmobile\u0027, \u0027Joker\u0027]))\n\u003e\u003e\u003e df\n   age       born    name        toy\n0  5.0        NaT  Alfred       None\n1  6.0 1939-05-27  Batman  Batmobile\n2  NaN 1940-04-25              Joker"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.isnull", "label": "isnull", "shape": "dot", "size": 20, "title": "NAME: isnull\n------------------------------\nINPUTS: self\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Series.isnull is an alias for Series.isna. Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as None or :attr:`numpy.NaN`, gets mapped to True values. Everything else gets mapped to False values. Characters...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(dict(age=[5, 6, np.nan],\n...                        born=[pd.NaT, pd.Timestamp(\u00271939-05-27\u0027),\n...                              pd.Timestamp(\u00271940-04-25\u0027)],\n...                        name=[\u0027Alfred\u0027, \u0027Batman\u0027, \u0027\u0027],\n...                        toy=[None, \u0027Batmobile\u0027, \u0027Joker\u0027]))\n\u003e\u003e\u003e df\n   age       born    name        toy\n0  5.0        NaT  Alfred       None\n1  6.0 1939-05-27  Batman  Batmobile\n2  NaN 1940-04-25              Joker"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.item", "label": "item", "shape": "dot", "size": 20, "title": "NAME: item\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the first element of the underlying data as a Python scalar. Returns ------- scalar The first element of Series or Index. Raises ------ ValueError If the data is not length = 1. Examples -------- \u003e\u003e\u003e s = pd.Series([1]) \u003e\u003e\u003e...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1])\n\u003e\u003e\u003e s.item()\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.items", "label": "items", "shape": "dot", "size": 20, "title": "NAME: items\n------------------------------\nINPUTS: self\nOUTPUTS: Iterable[tuple[Hashable, Any]]\n------------------------------\nDESCRIPTION: Lazily iterate over (index, value) tuples. This method returns an iterable tuple (index, value). This is convenient if you want to create a lazy iterator. Returns ------- iterable Iterable of tuples containing the (index, value) pairs from a Series. See...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\u0027A\u0027, \u0027B\u0027, \u0027C\u0027])\n\u003e\u003e\u003e for index, value in s.items():\n...     print(f\"Index : {index}, Value : {value}\")\nIndex : 0, Value : A\nIndex : 1, Value : B\nIndex : 2, Value : C"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.keys", "label": "keys", "shape": "dot", "size": 20, "title": "NAME: keys\n------------------------------\nINPUTS: self\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Return alias for index. Returns ------- Index Index of the Series. Examples -------- \u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[0, 1, 2]) \u003e\u003e\u003e s.keys() Index([0, 1, 2], dtype=\u0027int64\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[0, 1, 2])\n\u003e\u003e\u003e s.keys()\nIndex([0, 1, 2], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.kurt", "label": "kurt", "shape": "dot", "size": 20, "title": "NAME: kurt\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return unbiased kurtosis over requested axis. Kurtosis obtained using Fisher\u0027s definition of kurtosis (kurtosis of normal == 0.0). Normalized by N-1. Parameters ---------- axis : {index (0)} Axis for the function to be applied on. For `Series` this parameter is...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 2, 3], index=[\u0027cat\u0027, \u0027dog\u0027, \u0027dog\u0027, \u0027mouse\u0027])\n            \u003e\u003e\u003e s\n            cat    1\n            dog    2\n            dog    2\n            mouse  3\n            dtype: int64\n            \u003e\u003e\u003e s.kurt()\n            1.5"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.kurtosis", "label": "kurtosis", "shape": "dot", "size": 20, "title": "NAME: kurtosis\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return unbiased kurtosis over requested axis. Kurtosis obtained using Fisher\u0027s definition of kurtosis (kurtosis of normal == 0.0). Normalized by N-1. Parameters ---------- axis : {index (0)} Axis for the function to be applied on. For `Series` this parameter is...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 2, 3], index=[\u0027cat\u0027, \u0027dog\u0027, \u0027dog\u0027, \u0027mouse\u0027])\n            \u003e\u003e\u003e s\n            cat    1\n            dog    2\n            dog    2\n            mouse  3\n            dtype: int64\n            \u003e\u003e\u003e s.kurt()\n            1.5"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.last", "label": "last", "shape": "dot", "size": 20, "title": "NAME: last\n------------------------------\nINPUTS: self, offset\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Select final periods of time series data based on a date offset. .. deprecated:: 2.1 :meth:`.last` is deprecated and will be removed in a future version. Please create a mask and filter using `.loc` instead. For a DataFrame with a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e i = pd.date_range(\u00272018-04-09\u0027, periods=4, freq=\u00272D\u0027)\n\u003e\u003e\u003e ts = pd.DataFrame({\u0027A\u0027: [1, 2, 3, 4]}, index=i)\n\u003e\u003e\u003e ts\n            A\n2018-04-09  1\n2018-04-11  2\n2018-04-13  3\n2018-04-15  4"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.last_valid_index", "label": "last_valid_index", "shape": "dot", "size": 20, "title": "NAME: last_valid_index\n------------------------------\nINPUTS: self\nOUTPUTS: Hashable | None\n------------------------------\nDESCRIPTION: Return index for last non-NA value or None, if no non-NA value is found. Returns ------- type of index Examples -------- For Series: \u003e\u003e\u003e s = pd.Series([None, 3, 4]) \u003e\u003e\u003e s.first_valid_index() 1 \u003e\u003e\u003e s.last_valid_index() 2 \u003e\u003e\u003e s = pd.Series([None, None])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([None, 3, 4])\n\u003e\u003e\u003e s.first_valid_index()\n1\n\u003e\u003e\u003e s.last_valid_index()\n2"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.le", "label": "le", "shape": "dot", "size": 20, "title": "NAME: le\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Less than or equal to of series and other, element-wise (binary operator `le`). Equivalent to ``series \u003c= other``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan, 1], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ne    1.0\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([0, 1, 2, np.nan, 1], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027f\u0027])\n\u003e\u003e\u003e b\na    0.0\nb    1.0\nc    2.0\nd    NaN\nf    1.0\ndtype: float64\n\u003e\u003e\u003e a.le(b, fill_value=0)\na    False\nb     True\nc     True\nd    False\ne    False\nf     True\ndtype: bool"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Series.list", "label": "list", "shape": "dot", "size": 20, "title": "NAME: list\n------------------------------\nINPUTS: data\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Accessor object for list data properties of the Series values. Parameters ---------- data : Series Series containing Arrow list data....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.lt", "label": "lt", "shape": "dot", "size": 20, "title": "NAME: lt\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Less than of series and other, element-wise (binary operator `lt`). Equivalent to ``series \u003c other``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan, 1], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ne    1.0\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([0, 1, 2, np.nan, 1], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027f\u0027])\n\u003e\u003e\u003e b\na    0.0\nb    1.0\nc    2.0\nd    NaN\nf    1.0\ndtype: float64\n\u003e\u003e\u003e a.lt(b, fill_value=0)\na    False\nb    False\nc     True\nd    False\ne    False\nf     True\ndtype: bool"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.map", "label": "map", "shape": "dot", "size": 20, "title": "NAME: map\n------------------------------\nINPUTS: self, arg, na_action\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Map values of Series according to an input mapping or function. Used for substituting each value in a Series with another value, that may be derived from a function, a ``dict`` or a :class:`Series`. Parameters ---------- arg : function, collections.abc.Mapping...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\u0027cat\u0027, \u0027dog\u0027, np.nan, \u0027rabbit\u0027])\n\u003e\u003e\u003e s\n0      cat\n1      dog\n2      NaN\n3   rabbit\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.mask", "label": "mask", "shape": "dot", "size": 20, "title": "NAME: mask\n------------------------------\nINPUTS: self, cond, other, inplace, axis, level\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Replace values where the condition is True. Parameters ---------- cond : bool Series/DataFrame, array-like, or callable Where `cond` is False, keep the original value. Where True, replace with corresponding value from `other`. If `cond` is callable, it is computed on...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(range(5))\n\u003e\u003e\u003e s.where(s \u003e 0)\n0    NaN\n1    1.0\n2    2.0\n3    3.0\n4    4.0\ndtype: float64\n\u003e\u003e\u003e s.mask(s \u003e 0)\n0    0.0\n1    NaN\n2    NaN\n3    NaN\n4    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.max", "label": "max", "shape": "dot", "size": 20, "title": "NAME: max\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the maximum of the values over the requested axis. If you want the *index* of the maximum, use ``idxmax``. This is the equivalent of the ``numpy.ndarray`` method ``argmax``. Parameters ---------- axis : {index (0)} Axis for the function to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.MultiIndex.from_arrays([\n...     [\u0027warm\u0027, \u0027warm\u0027, \u0027cold\u0027, \u0027cold\u0027],\n...     [\u0027dog\u0027, \u0027falcon\u0027, \u0027fish\u0027, \u0027spider\u0027]],\n...     names=[\u0027blooded\u0027, \u0027animal\u0027])\n\u003e\u003e\u003e s = pd.Series([4, 2, 0, 8], name=\u0027legs\u0027, index=idx)\n\u003e\u003e\u003e s\nblooded  animal\nwarm     dog       4\n         falcon    2\ncold     fish      0\n         spider    8\nName: legs, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.mean", "label": "mean", "shape": "dot", "size": 20, "title": "NAME: mean\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the mean of the values over the requested axis. Parameters ---------- axis : {index (0)} Axis for the function to be applied on. For `Series` this parameter is unused and defaults to 0. For DataFrames, specifying ``axis=None`` will apply...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n            \u003e\u003e\u003e s.mean()\n            2.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.median", "label": "median", "shape": "dot", "size": 20, "title": "NAME: median\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the median of the values over the requested axis. Parameters ---------- axis : {index (0)} Axis for the function to be applied on. For `Series` this parameter is unused and defaults to 0. For DataFrames, specifying ``axis=None`` will apply...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n            \u003e\u003e\u003e s.median()\n            2.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.memory_usage", "label": "memory_usage", "shape": "dot", "size": 20, "title": "NAME: memory_usage\n------------------------------\nINPUTS: self, index, deep\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return the memory usage of the Series. The memory usage can optionally include the contribution of the index and of elements of `object` dtype. Parameters ---------- index : bool, default True Specifies whether to include the memory usage of the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(range(3))\n\u003e\u003e\u003e s.memory_usage()\n152"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.min", "label": "min", "shape": "dot", "size": 20, "title": "NAME: min\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the minimum of the values over the requested axis. If you want the *index* of the minimum, use ``idxmin``. This is the equivalent of the ``numpy.ndarray`` method ``argmin``. Parameters ---------- axis : {index (0)} Axis for the function to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.MultiIndex.from_arrays([\n...     [\u0027warm\u0027, \u0027warm\u0027, \u0027cold\u0027, \u0027cold\u0027],\n...     [\u0027dog\u0027, \u0027falcon\u0027, \u0027fish\u0027, \u0027spider\u0027]],\n...     names=[\u0027blooded\u0027, \u0027animal\u0027])\n\u003e\u003e\u003e s = pd.Series([4, 2, 0, 8], name=\u0027legs\u0027, index=idx)\n\u003e\u003e\u003e s\nblooded  animal\nwarm     dog       4\n         falcon    2\ncold     fish      0\n         spider    8\nName: legs, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.mod", "label": "mod", "shape": "dot", "size": 20, "title": "NAME: mod\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Modulo of series and other, element-wise (binary operator `mod`). Equivalent to ``series % other``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value level...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.mod(b, fill_value=0)\na    0.0\nb    NaN\nc    NaN\nd    0.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.mode", "label": "mode", "shape": "dot", "size": 20, "title": "NAME: mode\n------------------------------\nINPUTS: self, dropna\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return the mode(s) of the Series. The mode is the value that appears most often. There can be multiple modes. Always returns Series even if only one value is returned. Parameters ---------- dropna : bool, default True Don\u0027t consider counts...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([2, 4, 2, 2, 4, None])\n\u003e\u003e\u003e s.mode()\n0    2.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.mul", "label": "mul", "shape": "dot", "size": 20, "title": "NAME: mul\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Multiplication of series and other, element-wise (binary operator `mul`). Equivalent to ``series * other``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value level...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.multiply(b, fill_value=0)\na    1.0\nb    0.0\nc    0.0\nd    0.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.multiply", "label": "multiply", "shape": "dot", "size": 20, "title": "NAME: multiply\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Multiplication of series and other, element-wise (binary operator `mul`). Equivalent to ``series * other``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value level...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.multiply(b, fill_value=0)\na    1.0\nb    0.0\nc    0.0\nd    0.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.ne", "label": "ne", "shape": "dot", "size": 20, "title": "NAME: ne\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Not equal to of series and other, element-wise (binary operator `ne`). Equivalent to ``series != other``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.ne(b, fill_value=0)\na    False\nb     True\nc     True\nd     True\ne     True\ndtype: bool"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.nlargest", "label": "nlargest", "shape": "dot", "size": 20, "title": "NAME: nlargest\n------------------------------\nINPUTS: self, n, keep\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return the largest `n` elements. Parameters ---------- n : int, default 5 Return this many descending sorted values. keep : {\u0027first\u0027, \u0027last\u0027, \u0027all\u0027}, default \u0027first\u0027 When there are duplicate values that cannot all fit in a Series of `n` elements:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e countries_population = {\"Italy\": 59000000, \"France\": 65000000,\n...                         \"Malta\": 434000, \"Maldives\": 434000,\n...                         \"Brunei\": 434000, \"Iceland\": 337000,\n...                         \"Nauru\": 11300, \"Tuvalu\": 11300,\n...                         \"Anguilla\": 11300, \"Montserrat\": 5200}\n\u003e\u003e\u003e s = pd.Series(countries_population)\n\u003e\u003e\u003e s\nItaly       59000000\nFrance      65000000\nMalta         434000\nMaldives      434000\nBrunei        434000\nIceland       337000\nNauru          11300\nTuvalu         11300\nAnguilla       11300\nMontserrat      5200\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.notna", "label": "notna", "shape": "dot", "size": 20, "title": "NAME: notna\n------------------------------\nINPUTS: self\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to True. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values (unless you set ``pandas.options.mode.use_inf_as_na =...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(dict(age=[5, 6, np.nan],\n...                        born=[pd.NaT, pd.Timestamp(\u00271939-05-27\u0027),\n...                              pd.Timestamp(\u00271940-04-25\u0027)],\n...                        name=[\u0027Alfred\u0027, \u0027Batman\u0027, \u0027\u0027],\n...                        toy=[None, \u0027Batmobile\u0027, \u0027Joker\u0027]))\n\u003e\u003e\u003e df\n   age       born    name        toy\n0  5.0        NaT  Alfred       None\n1  6.0 1939-05-27  Batman  Batmobile\n2  NaN 1940-04-25              Joker"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.notnull", "label": "notnull", "shape": "dot", "size": 20, "title": "NAME: notnull\n------------------------------\nINPUTS: self\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Series.notnull is an alias for Series.notna. Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to True. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(dict(age=[5, 6, np.nan],\n...                        born=[pd.NaT, pd.Timestamp(\u00271939-05-27\u0027),\n...                              pd.Timestamp(\u00271940-04-25\u0027)],\n...                        name=[\u0027Alfred\u0027, \u0027Batman\u0027, \u0027\u0027],\n...                        toy=[None, \u0027Batmobile\u0027, \u0027Joker\u0027]))\n\u003e\u003e\u003e df\n   age       born    name        toy\n0  5.0        NaT  Alfred       None\n1  6.0 1939-05-27  Batman  Batmobile\n2  NaN 1940-04-25              Joker"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.nsmallest", "label": "nsmallest", "shape": "dot", "size": 20, "title": "NAME: nsmallest\n------------------------------\nINPUTS: self, n, keep\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return the smallest `n` elements. Parameters ---------- n : int, default 5 Return this many ascending sorted values. keep : {\u0027first\u0027, \u0027last\u0027, \u0027all\u0027}, default \u0027first\u0027 When there are duplicate values that cannot all fit in a Series of `n` elements:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e countries_population = {\"Italy\": 59000000, \"France\": 65000000,\n...                         \"Brunei\": 434000, \"Malta\": 434000,\n...                         \"Maldives\": 434000, \"Iceland\": 337000,\n...                         \"Nauru\": 11300, \"Tuvalu\": 11300,\n...                         \"Anguilla\": 11300, \"Montserrat\": 5200}\n\u003e\u003e\u003e s = pd.Series(countries_population)\n\u003e\u003e\u003e s\nItaly       59000000\nFrance      65000000\nBrunei        434000\nMalta         434000\nMaldives      434000\nIceland       337000\nNauru          11300\nTuvalu         11300\nAnguilla       11300\nMontserrat      5200\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.nunique", "label": "nunique", "shape": "dot", "size": 20, "title": "NAME: nunique\n------------------------------\nINPUTS: self, dropna\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return number of unique elements in the object. Excludes NA values by default. Parameters ---------- dropna : bool, default True Don\u0027t include NaN in the count. Returns ------- int See Also -------- DataFrame.nunique: Method nunique for DataFrame. Series.count: Count non-NA/null...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 3, 5, 7, 7])\n\u003e\u003e\u003e s\n0    1\n1    3\n2    5\n3    7\n4    7\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.pad", "label": "pad", "shape": "dot", "size": 20, "title": "NAME: pad\n------------------------------\nINPUTS: self, axis, inplace, limit, downcast\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Fill NA/NaN values by propagating the last valid observation to next valid. .. deprecated:: 2.0 Series/DataFrame.pad is deprecated. Use Series/DataFrame.ffill instead. Returns ------- Series/DataFrame or None Object with missing values filled or None if ``inplace=True``. Examples -------- Please see examples...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.pct_change", "label": "pct_change", "shape": "dot", "size": 20, "title": "NAME: pct_change\n------------------------------\nINPUTS: self, periods, fill_method, limit, freq, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Fractional change between the current and a prior element. Computes the fractional change from the immediately previous row by default. This is useful in comparing the fraction of change in a time series of elements. .. note:: Despite the name...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([90, 91, 85])\n\u003e\u003e\u003e s\n0    90\n1    91\n2    85\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.pipe", "label": "pipe", "shape": "dot", "size": 20, "title": "NAME: pipe\n------------------------------\nINPUTS: self, func, args, kwargs\nOUTPUTS: T\n------------------------------\nDESCRIPTION: Apply chainable functions that expect Series or DataFrames. Parameters ---------- func : function Function to apply to the Series/DataFrame. ``args``, and ``kwargs`` are passed into ``func``. Alternatively a ``(callable, data_keyword)`` tuple where ``data_keyword`` is a string indicating the keyword of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e data = [[8000, 1000], [9500, np.nan], [5000, 2000]]\n\u003e\u003e\u003e df = pd.DataFrame(data, columns=[\u0027Salary\u0027, \u0027Others\u0027])\n\u003e\u003e\u003e df\n   Salary  Others\n0    8000  1000.0\n1    9500     NaN\n2    5000  2000.0"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Series.plot", "label": "plot", "shape": "dot", "size": 20, "title": "NAME: plot\n------------------------------\nINPUTS: data\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Make plots of Series or DataFrame. Uses the backend specified by the option ``plotting.backend``. By default, matplotlib is used. Parameters ---------- data : Series or DataFrame The object for which the method is called. x : label or position, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([1, 2, 3, 3])\n    \u003e\u003e\u003e plot = ser.plot(kind=\u0027hist\u0027, title=\"My plot\")"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.pop", "label": "pop", "shape": "dot", "size": 20, "title": "NAME: pop\n------------------------------\nINPUTS: self, item\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return item and drops from series. Raise KeyError if not found. Parameters ---------- item : label Index of the element that needs to be removed. Returns ------- Value that is popped from series. Examples -------- \u003e\u003e\u003e ser = pd.Series([1, 2,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([1, 2, 3])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.pow", "label": "pow", "shape": "dot", "size": 20, "title": "NAME: pow\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Exponential power of series and other, element-wise (binary operator `pow`). Equivalent to ``series ** other``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.pow(b, fill_value=0)\na    1.0\nb    1.0\nc    1.0\nd    0.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.prod", "label": "prod", "shape": "dot", "size": 20, "title": "NAME: prod\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, min_count, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the product of the values over the requested axis. Parameters ---------- axis : {index (0)} Axis for the function to be applied on. For `Series` this parameter is unused and defaults to 0. .. warning:: The behavior of DataFrame.prod...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Series([], dtype=\"float64\").prod()\n1.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.product", "label": "product", "shape": "dot", "size": 20, "title": "NAME: product\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, min_count, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the product of the values over the requested axis. Parameters ---------- axis : {index (0)} Axis for the function to be applied on. For `Series` this parameter is unused and defaults to 0. .. warning:: The behavior of DataFrame.prod...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Series([], dtype=\"float64\").prod()\n1.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.quantile", "label": "quantile", "shape": "dot", "size": 20, "title": "NAME: quantile\n------------------------------\nINPUTS: self, q, interpolation\nOUTPUTS: float | Series\n------------------------------\nDESCRIPTION: Return value at the given quantile. Parameters ---------- q : float or array-like, default 0.5 (50% quantile) The quantile(s) to compute, which can lie in range: 0 \u003c= q \u003c= 1. interpolation : {\u0027linear\u0027, \u0027lower\u0027, \u0027higher\u0027, \u0027midpoint\u0027, \u0027nearest\u0027} This optional...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3, 4])\n\u003e\u003e\u003e s.quantile(.5)\n2.5\n\u003e\u003e\u003e s.quantile([.25, .5, .75])\n0.25    1.75\n0.50    2.50\n0.75    3.25\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.radd", "label": "radd", "shape": "dot", "size": 20, "title": "NAME: radd\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Addition of series and other, element-wise (binary operator `radd`). Equivalent to ``other + series``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value level...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.add(b, fill_value=0)\na    2.0\nb    1.0\nc    1.0\nd    1.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.rank", "label": "rank", "shape": "dot", "size": 20, "title": "NAME: rank\n------------------------------\nINPUTS: self, axis, method, numeric_only, na_option, ascending, pct\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Compute numerical data ranks (1 through n) along axis. By default, equal values are assigned a rank that is the average of the ranks of those values. Parameters ---------- axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default 0 Index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(data={\u0027Animal\u0027: [\u0027cat\u0027, \u0027penguin\u0027, \u0027dog\u0027,\n...                                    \u0027spider\u0027, \u0027snake\u0027],\n...                         \u0027Number_legs\u0027: [4, 2, 4, 8, np.nan]})\n\u003e\u003e\u003e df\n    Animal  Number_legs\n0      cat          4.0\n1  penguin          2.0\n2      dog          4.0\n3   spider          8.0\n4    snake          NaN"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.ravel", "label": "ravel", "shape": "dot", "size": 20, "title": "NAME: ravel\n------------------------------\nINPUTS: self, order\nOUTPUTS: ArrayLike\n------------------------------\nDESCRIPTION: Return the flattened underlying data as an ndarray or ExtensionArray. .. deprecated:: 2.2.0 Series.ravel is deprecated. The underlying array is already 1D, so ravel is not necessary. Use :meth:`to_numpy` for conversion to a numpy array instead. Returns ------- numpy.ndarray or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.ravel()  # doctest: +SKIP\narray([1, 2, 3])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.rdiv", "label": "rdiv", "shape": "dot", "size": 20, "title": "NAME: rdiv\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Floating division of series and other, element-wise (binary operator `rtruediv`). Equivalent to ``other / series``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.divide(b, fill_value=0)\na    1.0\nb    inf\nc    inf\nd    0.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.rdivmod", "label": "rdivmod", "shape": "dot", "size": 20, "title": "NAME: rdivmod\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Integer division and modulo of series and other, element-wise (binary operator `rdivmod`). Equivalent to ``other divmod series``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.divmod(b, fill_value=0)\n(a    1.0\n b    inf\n c    inf\n d    0.0\n e    NaN\n dtype: float64,\n a    0.0\n b    NaN\n c    NaN\n d    0.0\n e    NaN\n dtype: float64)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.reindex", "label": "reindex", "shape": "dot", "size": 20, "title": "NAME: reindex\n------------------------------\nINPUTS: self, index, axis, method, copy, level, fill_value, limit, tolerance\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Conform Series to new index with optional filling logic. Places NA/NaN in locations having no value in the previous index. A new object is produced unless the new index is equivalent to the current one and ``copy=False``. Parameters ---------- index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = [\u0027Firefox\u0027, \u0027Chrome\u0027, \u0027Safari\u0027, \u0027IE10\u0027, \u0027Konqueror\u0027]\n\u003e\u003e\u003e df = pd.DataFrame({\u0027http_status\u0027: [200, 200, 404, 404, 301],\n...                   \u0027response_time\u0027: [0.04, 0.02, 0.07, 0.08, 1.0]},\n...                   index=index)\n\u003e\u003e\u003e df\n           http_status  response_time\nFirefox            200           0.04\nChrome             200           0.02\nSafari             404           0.07\nIE10               404           0.08\nKonqueror          301           1.00"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.reindex_like", "label": "reindex_like", "shape": "dot", "size": 20, "title": "NAME: reindex_like\n------------------------------\nINPUTS: self, other, method, copy, limit, tolerance\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return an object with matching indices as other object. Conform the object to the same index on all axes. Optional filling logic, placing NaN in locations having no value in the previous index. A new object is produced unless the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df1 = pd.DataFrame([[24.3, 75.7, \u0027high\u0027],\n...                     [31, 87.8, \u0027high\u0027],\n...                     [22, 71.6, \u0027medium\u0027],\n...                     [35, 95, \u0027medium\u0027]],\n...                    columns=[\u0027temp_celsius\u0027, \u0027temp_fahrenheit\u0027,\n...                             \u0027windspeed\u0027],\n...                    index=pd.date_range(start=\u00272014-02-12\u0027,\n...                                        end=\u00272014-02-15\u0027, freq=\u0027D\u0027))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.rename", "label": "rename", "shape": "dot", "size": 20, "title": "NAME: rename\n------------------------------\nINPUTS: self, index, axis, copy, inplace, level, errors\nOUTPUTS: Series | None\n------------------------------\nDESCRIPTION: Alter Series index labels or name. Function / dict values must be unique (1-to-1). Labels not contained in a dict / Series will be left as-is. Extra labels listed don\u0027t throw an error. Alternatively, change ``Series.name`` with a scalar value....\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s\n0    1\n1    2\n2    3\ndtype: int64\n\u003e\u003e\u003e s.rename(\"my_name\")  # scalar, changes Series.name\n0    1\n1    2\n2    3\nName: my_name, dtype: int64\n\u003e\u003e\u003e s.rename(lambda x: x ** 2)  # function, changes labels\n0    1\n1    2\n4    3\ndtype: int64\n\u003e\u003e\u003e s.rename({1: 3, 2: 5})  # mapping, changes labels\n0    1\n3    2\n5    3\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.rename_axis", "label": "rename_axis", "shape": "dot", "size": 20, "title": "NAME: rename_axis\n------------------------------\nINPUTS: self, mapper, index, axis, copy, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Set the name of the axis for the index or columns. Parameters ---------- mapper : scalar, list-like, optional Value to set the axis name attribute. index, columns : scalar, list-like, dict-like or function, optional A scalar, list-like, dict-like or functions...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\"dog\", \"cat\", \"monkey\"])\n\u003e\u003e\u003e s\n0       dog\n1       cat\n2    monkey\ndtype: object\n\u003e\u003e\u003e s.rename_axis(\"animal\")\nanimal\n0    dog\n1    cat\n2    monkey\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.reorder_levels", "label": "reorder_levels", "shape": "dot", "size": 20, "title": "NAME: reorder_levels\n------------------------------\nINPUTS: self, order\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Rearrange index levels using input order. May not drop or duplicate levels. Parameters ---------- order : list of int representing new level order Reference level by number or key. Returns ------- type of caller (new object) Examples -------- \u003e\u003e\u003e arrays...\n\n\nEXAMPLE:\n\u003e\u003e\u003e arrays = [np.array([\"dog\", \"dog\", \"cat\", \"cat\", \"bird\", \"bird\"]),\n...           np.array([\"white\", \"black\", \"white\", \"black\", \"white\", \"black\"])]\n\u003e\u003e\u003e s = pd.Series([1, 2, 3, 3, 5, 2], index=arrays)\n\u003e\u003e\u003e s\ndog   white    1\n      black    2\ncat   white    3\n      black    3\nbird  white    5\n      black    2\ndtype: int64\n\u003e\u003e\u003e s.reorder_levels([1, 0])\nwhite  dog     1\nblack  dog     2\nwhite  cat     3\nblack  cat     3\nwhite  bird    5\nblack  bird    2\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.repeat", "label": "repeat", "shape": "dot", "size": 20, "title": "NAME: repeat\n------------------------------\nINPUTS: self, repeats, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Repeat elements of a Series. Returns a new Series where each element of the current Series is repeated consecutively a given number of times. Parameters ---------- repeats : int or array of ints The number of repetitions for each element....\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e s\n0    a\n1    b\n2    c\ndtype: object\n\u003e\u003e\u003e s.repeat(2)\n0    a\n0    a\n1    b\n1    b\n2    c\n2    c\ndtype: object\n\u003e\u003e\u003e s.repeat([1, 2, 3])\n0    a\n1    b\n1    b\n2    c\n2    c\n2    c\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.replace", "label": "replace", "shape": "dot", "size": 20, "title": "NAME: replace\n------------------------------\nINPUTS: self, to_replace, value, inplace, limit, regex, method\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Replace values given in `to_replace` with `value`. Values of the Series/DataFrame are replaced with other values dynamically. This differs from updating with ``.loc`` or ``.iloc``, which require you to specify a location to update with some value. Parameters ---------- to_replace...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3, 4, 5])\n\u003e\u003e\u003e s.replace(1, 5)\n0    5\n1    2\n2    3\n3    4\n4    5\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.resample", "label": "resample", "shape": "dot", "size": 20, "title": "NAME: resample\n------------------------------\nINPUTS: self, rule, axis, closed, label, convention, kind, on, level, origin, offset, group_keys\nOUTPUTS: Resampler\n------------------------------\nDESCRIPTION: Resample time-series data. Convenience method for frequency conversion and resampling of time series. The object must have a datetime-like index (`DatetimeIndex`, `PeriodIndex`, or `TimedeltaIndex`), or the caller must pass the label of a datetime-like series/index to the ``on``/``level`` keyword parameter....\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.date_range(\u00271/1/2000\u0027, periods=9, freq=\u0027min\u0027)\n\u003e\u003e\u003e series = pd.Series(range(9), index=index)\n\u003e\u003e\u003e series\n2000-01-01 00:00:00    0\n2000-01-01 00:01:00    1\n2000-01-01 00:02:00    2\n2000-01-01 00:03:00    3\n2000-01-01 00:04:00    4\n2000-01-01 00:05:00    5\n2000-01-01 00:06:00    6\n2000-01-01 00:07:00    7\n2000-01-01 00:08:00    8\nFreq: min, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.reset_index", "label": "reset_index", "shape": "dot", "size": 20, "title": "NAME: reset_index\n------------------------------\nINPUTS: self, level, drop, name, inplace, allow_duplicates\nOUTPUTS: DataFrame | Series | None\n------------------------------\nDESCRIPTION: Generate a new DataFrame or Series with the index reset. This is useful when the index needs to be treated as a column, or when the index is meaningless and needs to be reset to the default before another operation....\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3, 4], name=\u0027foo\u0027,\n...               index=pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027], name=\u0027idx\u0027))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.rfloordiv", "label": "rfloordiv", "shape": "dot", "size": 20, "title": "NAME: rfloordiv\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Integer division of series and other, element-wise (binary operator `rfloordiv`). Equivalent to ``other // series``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.floordiv(b, fill_value=0)\na    1.0\nb    inf\nc    inf\nd    0.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.rmod", "label": "rmod", "shape": "dot", "size": 20, "title": "NAME: rmod\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Modulo of series and other, element-wise (binary operator `rmod`). Equivalent to ``other % series``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value level...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.mod(b, fill_value=0)\na    0.0\nb    NaN\nc    NaN\nd    0.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.rmul", "label": "rmul", "shape": "dot", "size": 20, "title": "NAME: rmul\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Multiplication of series and other, element-wise (binary operator `rmul`). Equivalent to ``other * series``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value level...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.multiply(b, fill_value=0)\na    1.0\nb    0.0\nc    0.0\nd    0.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.rolling", "label": "rolling", "shape": "dot", "size": 20, "title": "NAME: rolling\n------------------------------\nINPUTS: self, window, min_periods, center, win_type, on, axis, closed, step, method\nOUTPUTS: Window | Rolling\n------------------------------\nDESCRIPTION: Provide rolling window calculations. Parameters ---------- window : int, timedelta, str, offset, or BaseIndexer subclass Size of the moving window. If an integer, the fixed number of observations used for each window. If a timedelta, str, or offset, the time...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027B\u0027: [0, 1, 2, np.nan, 4]})\n\u003e\u003e\u003e df\n     B\n0  0.0\n1  1.0\n2  2.0\n3  NaN\n4  4.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.round", "label": "round", "shape": "dot", "size": 20, "title": "NAME: round\n------------------------------\nINPUTS: self, decimals, args, kwargs\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Round each value in a Series to the given number of decimals. Parameters ---------- decimals : int, default 0 Number of decimal places to round to. If decimals is negative, it specifies the number of positions to the left of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([0.1, 1.3, 2.7])\n\u003e\u003e\u003e s.round()\n0    0.0\n1    1.0\n2    3.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.rpow", "label": "rpow", "shape": "dot", "size": 20, "title": "NAME: rpow\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Exponential power of series and other, element-wise (binary operator `rpow`). Equivalent to ``other ** series``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.pow(b, fill_value=0)\na    1.0\nb    1.0\nc    1.0\nd    0.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.rsub", "label": "rsub", "shape": "dot", "size": 20, "title": "NAME: rsub\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Subtraction of series and other, element-wise (binary operator `rsub`). Equivalent to ``other - series``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value level...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.subtract(b, fill_value=0)\na    0.0\nb    1.0\nc    1.0\nd   -1.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.rtruediv", "label": "rtruediv", "shape": "dot", "size": 20, "title": "NAME: rtruediv\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Floating division of series and other, element-wise (binary operator `rtruediv`). Equivalent to ``other / series``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.divide(b, fill_value=0)\na    1.0\nb    inf\nc    inf\nd    0.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.sample", "label": "sample", "shape": "dot", "size": 20, "title": "NAME: sample\n------------------------------\nINPUTS: self, n, frac, replace, weights, random_state, axis, ignore_index\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a random sample of items from an axis of object. You can use `random_state` for reproducibility. Parameters ---------- n : int, optional Number of items from axis to return. Cannot be used with `frac`. Default = 1 if `frac`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027num_legs\u0027: [2, 4, 8, 0],\n...                    \u0027num_wings\u0027: [2, 0, 0, 0],\n...                    \u0027num_specimen_seen\u0027: [10, 2, 1, 8]},\n...                   index=[\u0027falcon\u0027, \u0027dog\u0027, \u0027spider\u0027, \u0027fish\u0027])\n\u003e\u003e\u003e df\n        num_legs  num_wings  num_specimen_seen\nfalcon         2          2                 10\ndog            4          0                  2\nspider         8          0                  1\nfish           0          0                  8"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.searchsorted", "label": "searchsorted", "shape": "dot", "size": 20, "title": "NAME: searchsorted\n------------------------------\nINPUTS: self, value, side, sorter\nOUTPUTS: npt.NDArray[np.intp] | np.intp\n------------------------------\nDESCRIPTION: Find indices where elements should be inserted to maintain order. Find the indices into a sorted Series `self` such that, if the corresponding elements in `value` were inserted before the indices, the order of `self` would be preserved. .. note::...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([1, 2, 3])\n\u003e\u003e\u003e ser\n0    1\n1    2\n2    3\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.sem", "label": "sem", "shape": "dot", "size": 20, "title": "NAME: sem\n------------------------------\nINPUTS: self, axis, skipna, ddof, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return unbiased standard error of the mean over requested axis. Normalized by N-1 by default. This can be changed using the ddof argument Parameters ---------- axis : {index (0)} For `Series` this parameter is unused and defaults to 0. .....\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n            \u003e\u003e\u003e s.sem().round(6)\n            0.57735"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.set_axis", "label": "set_axis", "shape": "dot", "size": 20, "title": "NAME: set_axis\n------------------------------\nINPUTS: self, labels, axis, copy\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Assign desired index to given axis. Indexes for row labels can be changed by assigning a list-like or Index. Parameters ---------- labels : list-like, Index The values for the new index. axis : {0 or \u0027index\u0027}, default 0 The axis...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n        \u003e\u003e\u003e s\n        0    1\n        1    2\n        2    3\n        dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.set_flags", "label": "set_flags", "shape": "dot", "size": 20, "title": "NAME: set_flags\n------------------------------\nINPUTS: self, copy, allows_duplicate_labels\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a new object with updated flags. Parameters ---------- copy : bool, default False Specify if a copy of the object should be made. .. note:: The `copy` keyword will change behavior in pandas 3.0. `Copy-on-Write \u003chttps://pandas.pydata.org/docs/dev/user_guide/copy_on_write.html\u003e`__ will be enabled...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"A\": [1, 2]})\n\u003e\u003e\u003e df.flags.allows_duplicate_labels\nTrue\n\u003e\u003e\u003e df2 = df.set_flags(allows_duplicate_labels=False)\n\u003e\u003e\u003e df2.flags.allows_duplicate_labels\nFalse"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.shift", "label": "shift", "shape": "dot", "size": 20, "title": "NAME: shift\n------------------------------\nINPUTS: self, periods, freq, axis, fill_value, suffix\nOUTPUTS: Self | DataFrame\n------------------------------\nDESCRIPTION: Shift index by desired number of periods with an optional time `freq`. When `freq` is not passed, shift the index without realigning the data. If `freq` is passed (in this case, the index must be date or datetime, or it...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"Col1\": [10, 20, 15, 30, 45],\n...                    \"Col2\": [13, 23, 18, 33, 48],\n...                    \"Col3\": [17, 27, 22, 37, 52]},\n...                   index=pd.date_range(\"2020-01-01\", \"2020-01-05\"))\n\u003e\u003e\u003e df\n            Col1  Col2  Col3\n2020-01-01    10    13    17\n2020-01-02    20    23    27\n2020-01-03    15    18    22\n2020-01-04    30    33    37\n2020-01-05    45    48    52"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.skew", "label": "skew", "shape": "dot", "size": 20, "title": "NAME: skew\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return unbiased skew over requested axis. Normalized by N-1. Parameters ---------- axis : {index (0)} Axis for the function to be applied on. For `Series` this parameter is unused and defaults to 0. For DataFrames, specifying ``axis=None`` will apply the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n            \u003e\u003e\u003e s.skew()\n            0.0"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.sort_index", "label": "sort_index", "shape": "dot", "size": 20, "title": "NAME: sort_index\n------------------------------\nINPUTS: self, axis, level, ascending, inplace, kind, na_position, sort_remaining, ignore_index, key\nOUTPUTS: Series | None\n------------------------------\nDESCRIPTION: Sort Series by index labels. Returns a new Series sorted by label if `inplace` argument is ``False``, otherwise updates the original series and returns None. Parameters ---------- axis : {0 or \u0027index\u0027} Unused. Parameter needed for compatibility with DataFrame. level...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027], index=[3, 2, 1, 4])\n\u003e\u003e\u003e s.sort_index()\n1    c\n2    b\n3    a\n4    d\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.sort_values", "label": "sort_values", "shape": "dot", "size": 20, "title": "NAME: sort_values\n------------------------------\nINPUTS: self, axis, ascending, inplace, kind, na_position, ignore_index, key\nOUTPUTS: Series | None\n------------------------------\nDESCRIPTION: Sort by the values. Sort a Series in ascending or descending order by some criterion. Parameters ---------- axis : {0 or \u0027index\u0027} Unused. Parameter needed for compatibility with DataFrame. ascending : bool or list of bools, default True If True,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([np.nan, 1, 3, 10, 5])\n\u003e\u003e\u003e s\n0     NaN\n1     1.0\n2     3.0\n3     10.0\n4     5.0\ndtype: float64"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Series.sparse", "label": "sparse", "shape": "dot", "size": 20, "title": "NAME: sparse\n------------------------------\nINPUTS: data\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Accessor for SparseSparse from other sparse matrix data types. Examples -------- \u003e\u003e\u003e ser = pd.Series([0, 0, 2, 2, 2], dtype=\"Sparse[int]\") \u003e\u003e\u003e ser.sparse.density 0.6 \u003e\u003e\u003e ser.sparse.sp_values array([2, 2, 2])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([0, 0, 2, 2, 2], dtype=\"Sparse[int]\")\n\u003e\u003e\u003e ser.sparse.density\n0.6\n\u003e\u003e\u003e ser.sparse.sp_values\narray([2, 2, 2])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.squeeze", "label": "squeeze", "shape": "dot", "size": 20, "title": "NAME: squeeze\n------------------------------\nINPUTS: self, axis\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Squeeze 1 dimensional axis objects into scalars. Series or DataFrames with a single element are squeezed to a scalar. DataFrames with a single column or a single row are squeezed to a Series. Otherwise the object is unchanged. This method...\n\n\nEXAMPLE:\n\u003e\u003e\u003e primes = pd.Series([2, 3, 5, 7])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.std", "label": "std", "shape": "dot", "size": 20, "title": "NAME: std\n------------------------------\nINPUTS: self, axis, skipna, ddof, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return sample standard deviation over requested axis. Normalized by N-1 by default. This can be changed using the ddof argument. Parameters ---------- axis : {index (0)} For `Series` this parameter is unused and defaults to 0. .. warning:: The behavior...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027person_id\u0027: [0, 1, 2, 3],\n...                    \u0027age\u0027: [21, 25, 62, 43],\n...                    \u0027height\u0027: [1.61, 1.87, 1.49, 2.01]}\n...                   ).set_index(\u0027person_id\u0027)\n\u003e\u003e\u003e df\n           age  height\nperson_id\n0           21    1.61\n1           25    1.87\n2           62    1.49\n3           43    2.01"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Series.str", "label": "str", "shape": "dot", "size": 20, "title": "NAME: str\n------------------------------\nINPUTS: data\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Vectorized string functions for Series and Index. NAs stay NA unless handled otherwise by a particular method. Patterned after Python\u0027s string methods, with some inspiration from R\u0027s stringr package. Examples -------- \u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"]) \u003e\u003e\u003e s 0 A_Str_Series dtype:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"])\n\u003e\u003e\u003e s\n0    A_Str_Series\ndtype: object"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.Series.struct", "label": "struct", "shape": "dot", "size": 20, "title": "NAME: struct\n------------------------------\nINPUTS: data\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Accessor object for structured data properties of the Series values. Parameters ---------- data : Series Series containing Arrow struct data....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.sub", "label": "sub", "shape": "dot", "size": 20, "title": "NAME: sub\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Subtraction of series and other, element-wise (binary operator `sub`). Equivalent to ``series - other``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value level...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.subtract(b, fill_value=0)\na    0.0\nb    1.0\nc    1.0\nd   -1.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.subtract", "label": "subtract", "shape": "dot", "size": 20, "title": "NAME: subtract\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Subtraction of series and other, element-wise (binary operator `sub`). Equivalent to ``series - other``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value level...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.subtract(b, fill_value=0)\na    0.0\nb    1.0\nc    1.0\nd   -1.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.sum", "label": "sum", "shape": "dot", "size": 20, "title": "NAME: sum\n------------------------------\nINPUTS: self, axis, skipna, numeric_only, min_count, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the sum of the values over the requested axis. This is equivalent to the method ``numpy.sum``. Parameters ---------- axis : {index (0)} Axis for the function to be applied on. For `Series` this parameter is unused and defaults to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.MultiIndex.from_arrays([\n...     [\u0027warm\u0027, \u0027warm\u0027, \u0027cold\u0027, \u0027cold\u0027],\n...     [\u0027dog\u0027, \u0027falcon\u0027, \u0027fish\u0027, \u0027spider\u0027]],\n...     names=[\u0027blooded\u0027, \u0027animal\u0027])\n\u003e\u003e\u003e s = pd.Series([4, 2, 0, 8], name=\u0027legs\u0027, index=idx)\n\u003e\u003e\u003e s\nblooded  animal\nwarm     dog       4\n         falcon    2\ncold     fish      0\n         spider    8\nName: legs, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.swapaxes", "label": "swapaxes", "shape": "dot", "size": 20, "title": "NAME: swapaxes\n------------------------------\nINPUTS: self, axis1, axis2, copy\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Interchange axes and swap values axes appropriately. .. deprecated:: 2.1.0 ``swapaxes`` is deprecated and will be removed. Please use ``transpose`` instead. Returns ------- same as input Examples -------- Please see examples for :meth:`DataFrame.transpose`....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.swaplevel", "label": "swaplevel", "shape": "dot", "size": 20, "title": "NAME: swaplevel\n------------------------------\nINPUTS: self, i, j, copy\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Swap levels i and j in a :class:`MultiIndex`. Default is to swap the two innermost levels of the index. Parameters ---------- i, j : int or str Levels of the indices to be swapped. Can pass level name as string....\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(\n...     [\"A\", \"B\", \"A\", \"C\"],\n...     index=[\n...         [\"Final exam\", \"Final exam\", \"Coursework\", \"Coursework\"],\n...         [\"History\", \"Geography\", \"History\", \"Geography\"],\n...         [\"January\", \"February\", \"March\", \"April\"],\n...     ],\n... )\n\u003e\u003e\u003e s\nFinal exam  History     January      A\n            Geography   February     B\nCoursework  History     March        A\n            Geography   April        C\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.tail", "label": "tail", "shape": "dot", "size": 20, "title": "NAME: tail\n------------------------------\nINPUTS: self, n\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return the last `n` rows. This function returns last `n` rows from the object based on position. It is useful for quickly verifying data, for example, after sorting or appending rows. For negative values of `n`, this function returns all...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027animal\u0027: [\u0027alligator\u0027, \u0027bee\u0027, \u0027falcon\u0027, \u0027lion\u0027,\n...                    \u0027monkey\u0027, \u0027parrot\u0027, \u0027shark\u0027, \u0027whale\u0027, \u0027zebra\u0027]})\n\u003e\u003e\u003e df\n      animal\n0  alligator\n1        bee\n2     falcon\n3       lion\n4     monkey\n5     parrot\n6      shark\n7      whale\n8      zebra"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.take", "label": "take", "shape": "dot", "size": 20, "title": "NAME: take\n------------------------------\nINPUTS: self, indices, axis, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return the elements in the given *positional* indices along an axis. This means that we are not indexing according to actual values in the index attribute of the object. We are indexing according to the actual position of the element...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([(\u0027falcon\u0027, \u0027bird\u0027, 389.0),\n...                    (\u0027parrot\u0027, \u0027bird\u0027, 24.0),\n...                    (\u0027lion\u0027, \u0027mammal\u0027, 80.5),\n...                    (\u0027monkey\u0027, \u0027mammal\u0027, np.nan)],\n...                   columns=[\u0027name\u0027, \u0027class\u0027, \u0027max_speed\u0027],\n...                   index=[0, 2, 3, 1])\n\u003e\u003e\u003e df\n     name   class  max_speed\n0  falcon    bird      389.0\n2  parrot    bird       24.0\n3    lion  mammal       80.5\n1  monkey  mammal        NaN"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.to_clipboard", "label": "to_clipboard", "shape": "dot", "size": 20, "title": "NAME: to_clipboard\n------------------------------\nINPUTS: self, excel, sep, kwargs\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Copy object to the system clipboard. Write a text representation of object to the system clipboard. This can be pasted into Excel, for example. Parameters ---------- excel : bool, default True Produce output in a csv format for easy pasting...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([[1, 2, 3], [4, 5, 6]], columns=[\u0027A\u0027, \u0027B\u0027, \u0027C\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.to_csv", "label": "to_csv", "shape": "dot", "size": 20, "title": "NAME: to_csv\n------------------------------\nINPUTS: self, path_or_buf, sep, na_rep, float_format, columns, header, index, index_label, mode, encoding, compression, quoting, quotechar, lineterminator, chunksize, date_format, doublequote, escapechar, decimal, errors, storage_options\nOUTPUTS: str | None\n------------------------------\nDESCRIPTION: Write object to a comma-separated values (csv) file. Parameters ---------- path_or_buf : str, path object, file-like object, or None, default None String, path object (implementing os.PathLike[str]), or file-like object implementing a write() function. If None, the result is returned as...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027name\u0027: [\u0027Raphael\u0027, \u0027Donatello\u0027],\n...                    \u0027mask\u0027: [\u0027red\u0027, \u0027purple\u0027],\n...                    \u0027weapon\u0027: [\u0027sai\u0027, \u0027bo staff\u0027]})\n\u003e\u003e\u003e df.to_csv(\u0027out.csv\u0027, index=False)  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.to_dict", "label": "to_dict", "shape": "dot", "size": 20, "title": "NAME: to_dict\n------------------------------\nINPUTS: self, into\nOUTPUTS: MutableMappingT\n------------------------------\nDESCRIPTION: Convert Series to {label -\u003e value} dict or dict-like object. Parameters ---------- into : class, default dict The collections.abc.MutableMapping subclass to use as the return object. Can be the actual class or an empty instance of the mapping type you...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3, 4])\n\u003e\u003e\u003e s.to_dict()\n{0: 1, 1: 2, 2: 3, 3: 4}\n\u003e\u003e\u003e from collections import OrderedDict, defaultdict\n\u003e\u003e\u003e s.to_dict(into=OrderedDict)\nOrderedDict([(0, 1), (1, 2), (2, 3), (3, 4)])\n\u003e\u003e\u003e dd = defaultdict(list)\n\u003e\u003e\u003e s.to_dict(into=dd)\ndefaultdict(\u003cclass \u0027list\u0027\u003e, {0: 1, 1: 2, 2: 3, 3: 4})"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.to_excel", "label": "to_excel", "shape": "dot", "size": 20, "title": "NAME: to_excel\n------------------------------\nINPUTS: self, excel_writer, sheet_name, na_rep, float_format, columns, header, index, index_label, startrow, startcol, engine, merge_cells, inf_rep, freeze_panes, storage_options, engine_kwargs\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Write object to an Excel sheet. To write a single object to an Excel .xlsx file it is only necessary to specify a target file name. To write to multiple sheets it is necessary to create an `ExcelWriter` object with...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df1 = pd.DataFrame([[\u0027a\u0027, \u0027b\u0027], [\u0027c\u0027, \u0027d\u0027]],\n...                    index=[\u0027row 1\u0027, \u0027row 2\u0027],\n...                    columns=[\u0027col 1\u0027, \u0027col 2\u0027])\n\u003e\u003e\u003e df1.to_excel(\"output.xlsx\")  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.to_frame", "label": "to_frame", "shape": "dot", "size": 20, "title": "NAME: to_frame\n------------------------------\nINPUTS: self, name\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Convert Series to DataFrame. Parameters ---------- name : object, optional The passed name should substitute for the series name (if it has one). Returns ------- DataFrame DataFrame representation of Series. Examples -------- \u003e\u003e\u003e s = pd.Series([\"a\", \"b\", \"c\"], ... name=\"vals\")...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\"a\", \"b\", \"c\"],\n...               name=\"vals\")\n\u003e\u003e\u003e s.to_frame()\n  vals\n0    a\n1    b\n2    c"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.to_hdf", "label": "to_hdf", "shape": "dot", "size": 20, "title": "NAME: to_hdf\n------------------------------\nINPUTS: self, path_or_buf, key, mode, complevel, complib, append, format, index, min_itemsize, nan_rep, dropna, data_columns, errors, encoding\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Write the contained data to an HDF5 file using HDFStore. Hierarchical Data Format (HDF) is self-describing, allowing an application to interpret the structure and contents of a file with no outside information. One HDF file can hold a mix of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [1, 2, 3], \u0027B\u0027: [4, 5, 6]},\n...                   index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])  # doctest: +SKIP\n\u003e\u003e\u003e df.to_hdf(\u0027data.h5\u0027, key=\u0027df\u0027, mode=\u0027w\u0027)  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.to_json", "label": "to_json", "shape": "dot", "size": 20, "title": "NAME: to_json\n------------------------------\nINPUTS: self, path_or_buf, orient, date_format, double_precision, force_ascii, date_unit, default_handler, lines, compression, index, indent, storage_options, mode\nOUTPUTS: str | None\n------------------------------\nDESCRIPTION: Convert the object to a JSON string. Note NaN\u0027s and None will be converted to null and datetime objects will be converted to UNIX timestamps. Parameters ---------- path_or_buf : str, path object, file-like object, or None, default None String, path...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from json import loads, dumps\n\u003e\u003e\u003e df = pd.DataFrame(\n...     [[\"a\", \"b\"], [\"c\", \"d\"]],\n...     index=[\"row 1\", \"row 2\"],\n...     columns=[\"col 1\", \"col 2\"],\n... )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.to_latex", "label": "to_latex", "shape": "dot", "size": 20, "title": "NAME: to_latex\n------------------------------\nINPUTS: self, buf, columns, header, index, na_rep, formatters, float_format, sparsify, index_names, bold_rows, column_format, longtable, escape, encoding, decimal, multicolumn, multicolumn_format, multirow, caption, label, position\nOUTPUTS: str | None\n------------------------------\nDESCRIPTION: Render object to a LaTeX tabular, longtable, or nested table. Requires ``\\usepackage{{booktabs}}``. The output can be copy/pasted into a main LaTeX document or read from an external file with ``\\input{{table.tex}}``. .. versionchanged:: 2.0.0 Refactored to use the Styler implementation via...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(dict(name=[\u0027Raphael\u0027, \u0027Donatello\u0027],\n...                        age=[26, 45],\n...                        height=[181.23, 177.65]))\n\u003e\u003e\u003e print(df.to_latex(index=False,\n...                   formatters={\"name\": str.upper},\n...                   float_format=\"{:.1f}\".format,\n... ))  # doctest: +SKIP\n\\begin{tabular}{lrr}\n\\toprule\nname \u0026 age \u0026 height \\\\\n\\midrule\nRAPHAEL \u0026 26 \u0026 181.2 \\\\\nDONATELLO \u0026 45 \u0026 177.7 \\\\\n\\bottomrule\n\\end{tabular}"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.to_list", "label": "to_list", "shape": "dot", "size": 20, "title": "NAME: to_list\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list See Also -------- numpy.ndarray.tolist : Return the array as an...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.to_list()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.to_markdown", "label": "to_markdown", "shape": "dot", "size": 20, "title": "NAME: to_markdown\n------------------------------\nINPUTS: self, buf, mode, index, storage_options, kwargs\nOUTPUTS: str | None\n------------------------------\nDESCRIPTION: Print Series in Markdown-friendly format. Parameters ---------- buf : str, Path or StringIO-like, optional, default None Buffer to write to. If None, the output is returned as a string. mode : str, optional Mode in which file is opened, \"wt\"...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\"elk\", \"pig\", \"dog\", \"quetzal\"], name=\"animal\")\n            \u003e\u003e\u003e print(s.to_markdown())\n            |    | animal   |\n            |---:|:---------|\n            |  0 | elk      |\n            |  1 | pig      |\n            |  2 | dog      |\n            |  3 | quetzal  |"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.to_numpy", "label": "to_numpy", "shape": "dot", "size": 20, "title": "NAME: to_numpy\n------------------------------\nINPUTS: self, dtype, copy, na_value, kwargs\nOUTPUTS: np.ndarray\n------------------------------\nDESCRIPTION: A NumPy ndarray representing the values in this Series or Index. Parameters ---------- dtype : str or numpy.dtype, optional The dtype to pass to :meth:`numpy.asarray`. copy : bool, default False Whether to ensure that the returned value is not a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series(pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027]))\n\u003e\u003e\u003e ser.to_numpy()\narray([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.to_period", "label": "to_period", "shape": "dot", "size": 20, "title": "NAME: to_period\n------------------------------\nINPUTS: self, freq, copy\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Convert Series from DatetimeIndex to PeriodIndex. Parameters ---------- freq : str, default None Frequency associated with the PeriodIndex. copy : bool, default True Whether or not to return a copy. .. note:: The `copy` keyword will change behavior in pandas...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.DatetimeIndex([\u00272023\u0027, \u00272024\u0027, \u00272025\u0027])\n\u003e\u003e\u003e s = pd.Series([1, 2, 3], index=idx)\n\u003e\u003e\u003e s = s.to_period()\n\u003e\u003e\u003e s\n2023    1\n2024    2\n2025    3\nFreq: Y-DEC, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.to_pickle", "label": "to_pickle", "shape": "dot", "size": 20, "title": "NAME: to_pickle\n------------------------------\nINPUTS: self, path, compression, protocol, storage_options\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Pickle (serialize) object to file. Parameters ---------- path : str, path object, or file-like object String, path object (implementing ``os.PathLike[str]``), or file-like object implementing a binary ``write()`` function. File path where the pickled object will be stored. compression : str...\n\n\nEXAMPLE:\n\u003e\u003e\u003e original_df = pd.DataFrame({\"foo\": range(5), \"bar\": range(5, 10)})  # doctest: +SKIP\n\u003e\u003e\u003e original_df  # doctest: +SKIP\n   foo  bar\n0    0    5\n1    1    6\n2    2    7\n3    3    8\n4    4    9\n\u003e\u003e\u003e original_df.to_pickle(\"./dummy.pkl\")  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.to_sql", "label": "to_sql", "shape": "dot", "size": 20, "title": "NAME: to_sql\n------------------------------\nINPUTS: self, name, con, schema, if_exists, index, index_label, chunksize, dtype, method\nOUTPUTS: int | None\n------------------------------\nDESCRIPTION: Write records stored in a DataFrame to a SQL database. Databases supported by SQLAlchemy [1]_ are supported. Tables can be newly created, appended to, or overwritten. Parameters ---------- name : str Name of SQL table. con : sqlalchemy.engine.(Engine or Connection)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from sqlalchemy import create_engine\n\u003e\u003e\u003e engine = create_engine(\u0027sqlite://\u0027, echo=False)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.to_string", "label": "to_string", "shape": "dot", "size": 20, "title": "NAME: to_string\n------------------------------\nINPUTS: self, buf, na_rep, float_format, header, index, length, dtype, name, max_rows, min_rows\nOUTPUTS: str | None\n------------------------------\nDESCRIPTION: Render a string representation of the Series. Parameters ---------- buf : StringIO-like, optional Buffer to write to. na_rep : str, optional String representation of NaN to use, default \u0027NaN\u0027. float_format : one-parameter function, optional Formatter function to apply to columns\u0027...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([1, 2, 3]).to_string()\n\u003e\u003e\u003e ser\n\u00270    1\\n1    2\\n2    3\u0027"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.to_timestamp", "label": "to_timestamp", "shape": "dot", "size": 20, "title": "NAME: to_timestamp\n------------------------------\nINPUTS: self, freq, how, copy\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Cast to DatetimeIndex of Timestamps, at *beginning* of period. Parameters ---------- freq : str, default frequency of PeriodIndex Desired frequency. how : {\u0027s\u0027, \u0027e\u0027, \u0027start\u0027, \u0027end\u0027} Convention for converting period to timestamp; start of period vs. end. copy : bool,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.PeriodIndex([\u00272023\u0027, \u00272024\u0027, \u00272025\u0027], freq=\u0027Y\u0027)\n\u003e\u003e\u003e s1 = pd.Series([1, 2, 3], index=idx)\n\u003e\u003e\u003e s1\n2023    1\n2024    2\n2025    3\nFreq: Y-DEC, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.to_xarray", "label": "to_xarray", "shape": "dot", "size": 20, "title": "NAME: to_xarray\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return an xarray object from the pandas object. Returns ------- xarray.DataArray or xarray.Dataset Data in the pandas structure converted to Dataset if the object is a DataFrame, or a DataArray if the object is a Series. See Also -------- DataFrame.to_hdf...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame([(\u0027falcon\u0027, \u0027bird\u0027, 389.0, 2),\n...                    (\u0027parrot\u0027, \u0027bird\u0027, 24.0, 2),\n...                    (\u0027lion\u0027, \u0027mammal\u0027, 80.5, 4),\n...                    (\u0027monkey\u0027, \u0027mammal\u0027, np.nan, 4)],\n...                   columns=[\u0027name\u0027, \u0027class\u0027, \u0027max_speed\u0027,\n...                            \u0027num_legs\u0027])\n\u003e\u003e\u003e df\n     name   class  max_speed  num_legs\n0  falcon    bird      389.0         2\n1  parrot    bird       24.0         2\n2    lion  mammal       80.5         4\n3  monkey  mammal        NaN         4"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.tolist", "label": "tolist", "shape": "dot", "size": 20, "title": "NAME: tolist\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list See Also -------- numpy.ndarray.tolist : Return the array as an...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.to_list()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.transform", "label": "transform", "shape": "dot", "size": 20, "title": "NAME: transform\n------------------------------\nINPUTS: self, func, axis, args, kwargs\nOUTPUTS: DataFrame | Series\n------------------------------\nDESCRIPTION: Call ``func`` on self producing a Series with the same axis shape as self. Parameters ---------- func : function, str, list-like or dict-like Function to use for transforming the data. If a function, must either work when passed a Series...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: range(3), \u0027B\u0027: range(1, 4)})\n\u003e\u003e\u003e df\n   A  B\n0  0  1\n1  1  2\n2  2  3\n\u003e\u003e\u003e df.transform(lambda x: x + 1)\n   A  B\n0  1  2\n1  2  3\n2  3  4"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.transpose", "label": "transpose", "shape": "dot", "size": 20, "title": "NAME: transpose\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return the transpose, which is by definition self. Returns ------- %(klass)s...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.truediv", "label": "truediv", "shape": "dot", "size": 20, "title": "NAME: truediv\n------------------------------\nINPUTS: self, other, level, fill_value, axis\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return Floating division of series and other, element-wise (binary operator `truediv`). Equivalent to ``series / other``, but with support to substitute a fill_value for missing data in either one of the inputs. Parameters ---------- other : Series or scalar value...\n\n\nEXAMPLE:\n\u003e\u003e\u003e a = pd.Series([1, 1, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027])\n\u003e\u003e\u003e a\na    1.0\nb    1.0\nc    1.0\nd    NaN\ndtype: float64\n\u003e\u003e\u003e b = pd.Series([1, np.nan, 1, np.nan], index=[\u0027a\u0027, \u0027b\u0027, \u0027d\u0027, \u0027e\u0027])\n\u003e\u003e\u003e b\na    1.0\nb    NaN\nd    1.0\ne    NaN\ndtype: float64\n\u003e\u003e\u003e a.divide(b, fill_value=0)\na    1.0\nb    inf\nc    inf\nd    0.0\ne    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.truncate", "label": "truncate", "shape": "dot", "size": 20, "title": "NAME: truncate\n------------------------------\nINPUTS: self, before, after, axis, copy\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Truncate a Series or DataFrame before and after some index value. This is a useful shorthand for boolean indexing based on index values above or below certain thresholds. Parameters ---------- before : date, str, int Truncate all rows before this...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [\u0027a\u0027, \u0027b\u0027, \u0027c\u0027, \u0027d\u0027, \u0027e\u0027],\n...                    \u0027B\u0027: [\u0027f\u0027, \u0027g\u0027, \u0027h\u0027, \u0027i\u0027, \u0027j\u0027],\n...                    \u0027C\u0027: [\u0027k\u0027, \u0027l\u0027, \u0027m\u0027, \u0027n\u0027, \u0027o\u0027]},\n...                   index=[1, 2, 3, 4, 5])\n\u003e\u003e\u003e df\n   A  B  C\n1  a  f  k\n2  b  g  l\n3  c  h  m\n4  d  i  n\n5  e  j  o"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.tz_convert", "label": "tz_convert", "shape": "dot", "size": 20, "title": "NAME: tz_convert\n------------------------------\nINPUTS: self, tz, axis, level, copy\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Convert tz-aware axis to target time zone. Parameters ---------- tz : str or tzinfo object or None Target time zone. Passing ``None`` will convert to UTC and remove the timezone information. axis : {0 or \u0027index\u0027, 1 or \u0027columns\u0027}, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(\n...     [1],\n...     index=pd.DatetimeIndex([\u00272018-09-15 01:30:00+02:00\u0027]),\n... )\n\u003e\u003e\u003e s.tz_convert(\u0027Asia/Shanghai\u0027)\n2018-09-15 07:30:00+08:00    1\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.tz_localize", "label": "tz_localize", "shape": "dot", "size": 20, "title": "NAME: tz_localize\n------------------------------\nINPUTS: self, tz, axis, level, copy, ambiguous, nonexistent\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Localize tz-naive index of a Series or DataFrame to target time zone. This operation localizes the Index. To localize the values in a timezone-naive Series, use :meth:`Series.dt.tz_localize`. Parameters ---------- tz : str or tzinfo or None Time zone to localize....\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(\n...     [1],\n...     index=pd.DatetimeIndex([\u00272018-09-15 01:30:00\u0027]),\n... )\n\u003e\u003e\u003e s.tz_localize(\u0027CET\u0027)\n2018-09-15 01:30:00+02:00    1\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.unique", "label": "unique", "shape": "dot", "size": 20, "title": "NAME: unique\n------------------------------\nINPUTS: self\nOUTPUTS: ArrayLike\n------------------------------\nDESCRIPTION: Return unique values of Series object. Uniques are returned in order of appearance. Hash table-based unique, therefore does NOT sort. Returns ------- ndarray or ExtensionArray The unique values returned as a NumPy array. See Notes. See Also -------- Series.drop_duplicates :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Series([2, 1, 3, 3], name=\u0027A\u0027).unique()\narray([2, 1, 3])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.unstack", "label": "unstack", "shape": "dot", "size": 20, "title": "NAME: unstack\n------------------------------\nINPUTS: self, level, fill_value, sort\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Unstack, also known as pivot, Series with MultiIndex to produce DataFrame. Parameters ---------- level : int, str, or list of these, default last level Level(s) to unstack, can pass level name. fill_value : scalar value, default None Value to use...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3, 4],\n...               index=pd.MultiIndex.from_product([[\u0027one\u0027, \u0027two\u0027],\n...                                                 [\u0027a\u0027, \u0027b\u0027]]))\n\u003e\u003e\u003e s\none  a    1\n     b    2\ntwo  a    3\n     b    4\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.update", "label": "update", "shape": "dot", "size": 20, "title": "NAME: update\n------------------------------\nINPUTS: self, other\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Modify Series in place using values from passed Series. Uses non-NA values from passed Series to make updates. Aligns on index. Parameters ---------- other : Series, or object coercible into Series Examples -------- \u003e\u003e\u003e s = pd.Series([1, 2, 3]) \u003e\u003e\u003e...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.update(pd.Series([4, 5, 6]))\n\u003e\u003e\u003e s\n0    4\n1    5\n2    6\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.value_counts", "label": "value_counts", "shape": "dot", "size": 20, "title": "NAME: value_counts\n------------------------------\nINPUTS: self, normalize, sort, ascending, bins, dropna\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return a Series containing counts of unique values. The resulting object will be in descending order so that the first element is the most frequently-occurring element. Excludes NA values by default. Parameters ---------- normalize : bool, default False If True...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([3, 1, 2, 3, 4, np.nan])\n\u003e\u003e\u003e index.value_counts()\n3.0    2\n1.0    1\n2.0    1\n4.0    1\nName: count, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.var", "label": "var", "shape": "dot", "size": 20, "title": "NAME: var\n------------------------------\nINPUTS: self, axis, skipna, ddof, numeric_only, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return unbiased variance over requested axis. Normalized by N-1 by default. This can be changed using the ddof argument. Parameters ---------- axis : {index (0)} For `Series` this parameter is unused and defaults to 0. .. warning:: The behavior of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027person_id\u0027: [0, 1, 2, 3],\n...                    \u0027age\u0027: [21, 25, 62, 43],\n...                    \u0027height\u0027: [1.61, 1.87, 1.49, 2.01]}\n...                   ).set_index(\u0027person_id\u0027)\n\u003e\u003e\u003e df\n           age  height\nperson_id\n0           21    1.61\n1           25    1.87\n2           62    1.49\n3           43    2.01"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.view", "label": "view", "shape": "dot", "size": 20, "title": "NAME: view\n------------------------------\nINPUTS: self, dtype\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Create a new view of the Series. .. deprecated:: 2.2.0 ``Series.view`` is deprecated and will be removed in a future version. Use :meth:`Series.astype` as an alternative to change the dtype. This function will return a new Series with a view...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.where", "label": "where", "shape": "dot", "size": 20, "title": "NAME: where\n------------------------------\nINPUTS: self, cond, other, inplace, axis, level\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Replace values where the condition is False. Parameters ---------- cond : bool Series/DataFrame, array-like, or callable Where `cond` is True, keep the original value. Where False, replace with corresponding value from `other`. If `cond` is callable, it is computed on...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(range(5))\n\u003e\u003e\u003e s.where(s \u003e 0)\n0    NaN\n1    1.0\n2    2.0\n3    3.0\n4    4.0\ndtype: float64\n\u003e\u003e\u003e s.mask(s \u003e 0)\n0    0.0\n1    NaN\n2    NaN\n3    NaN\n4    NaN\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.Series.xs", "label": "xs", "shape": "dot", "size": 20, "title": "NAME: xs\n------------------------------\nINPUTS: self, key, axis, level, drop_level\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return cross-section from the Series/DataFrame. This method takes a `key` argument to select data at a particular level of a MultiIndex. Parameters ---------- key : label or tuple of label Label contained in the index, or partially in a MultiIndex....\n\n\nEXAMPLE:\n\u003e\u003e\u003e d = {\u0027num_legs\u0027: [4, 4, 2, 2],\n...      \u0027num_wings\u0027: [0, 0, 2, 2],\n...      \u0027class\u0027: [\u0027mammal\u0027, \u0027mammal\u0027, \u0027mammal\u0027, \u0027bird\u0027],\n...      \u0027animal\u0027: [\u0027cat\u0027, \u0027dog\u0027, \u0027bat\u0027, \u0027penguin\u0027],\n...      \u0027locomotion\u0027: [\u0027walks\u0027, \u0027walks\u0027, \u0027flies\u0027, \u0027walks\u0027]}\n\u003e\u003e\u003e df = pd.DataFrame(data=d)\n\u003e\u003e\u003e df = df.set_index([\u0027class\u0027, \u0027animal\u0027, \u0027locomotion\u0027])\n\u003e\u003e\u003e df\n                           num_legs  num_wings\nclass  animal  locomotion\nmammal cat     walks              4          0\n       dog     walks              4          0\n       bat     flies              2          2\nbird   penguin walks              2          2"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.SparseDtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: \nOUTPUTS: type_t[SparseArray]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.SparseDtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: SparseDtype\n------------------------------\nDESCRIPTION: Construct a SparseDtype from a string form. Parameters ---------- string : str Can take the following forms. string dtype ================ ============================ \u0027int\u0027 SparseDtype[np.int64, 0] \u0027Sparse\u0027 SparseDtype[np.float64, nan] \u0027Sparse[int]\u0027 SparseDtype[np.int64, 0] \u0027Sparse[int, 0]\u0027 SparseDtype[np.int64, 0] ================ ============================ It is not possible...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.SparseDtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.SparseDtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if we match \u0027dtype\u0027. Parameters ---------- dtype : object The object to check. Returns ------- bool Notes ----- The default implementation is True if 1. ``cls.construct_from_string(dtype)`` is an instance of ``cls``. 2. ``dtype`` is an object and is an...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.SparseDtype.update_dtype", "label": "update_dtype", "shape": "dot", "size": 20, "title": "NAME: update_dtype\n------------------------------\nINPUTS: self, dtype\nOUTPUTS: SparseDtype\n------------------------------\nDESCRIPTION: Convert the SparseDtype to a new dtype. This takes care of converting the ``fill_value``. Parameters ---------- dtype : Union[str, numpy.dtype, SparseDtype] The new dtype to use. * For a SparseDtype, it is simply returned * For a NumPy dtype (or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e SparseDtype(int, 0).update_dtype(float)\nSparse[float64, 0.0]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.StringDtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: self\nOUTPUTS: type_t[BaseStringArray]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.StringDtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Construct a StringDtype from a string. Parameters ---------- string : str The type of the name. The storage type will be taking from `string`. Valid options and their storage types are ========================== ============================================== string result storage ========================== ============================================== ``\u0027string\u0027`` pd.options.mode.string_storage,...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.StringDtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.StringDtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if we match \u0027dtype\u0027. Parameters ---------- dtype : object The object to check. Returns ------- bool Notes ----- The default implementation is True if 1. ``cls.construct_from_string(dtype)`` is an instance of ``cls``. 2. ``dtype`` is an object and is an...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.all", "label": "all", "shape": "dot", "size": 20, "title": "NAME: all\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return whether all elements are Truthy. Parameters ---------- *args Required for compatibility with numpy. **kwargs Required for compatibility with numpy. Returns ------- bool or array-like (if axis is specified) A single element array-like may be converted to bool. See Also...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Index([1, 2, 3]).all()\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.any", "label": "any", "shape": "dot", "size": 20, "title": "NAME: any\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return whether any element is Truthy. Parameters ---------- *args Required for compatibility with numpy. **kwargs Required for compatibility with numpy. Returns ------- bool or array-like (if axis is specified) A single element array-like may be converted to bool. See Also...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([0, 1, 2])\n\u003e\u003e\u003e index.any()\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.append", "label": "append", "shape": "dot", "size": 20, "title": "NAME: append\n------------------------------\nINPUTS: self, other\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Append a collection of Index options together. Parameters ---------- other : Index or list/tuple of indices Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([1, 2, 3]) \u003e\u003e\u003e idx.append(pd.Index([4])) Index([1, 2, 3, 4], dtype=\u0027int64\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.append(pd.Index([4]))\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.argmax", "label": "argmax", "shape": "dot", "size": 20, "title": "NAME: argmax\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the largest value in the Series. If the maximum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.argmin", "label": "argmin", "shape": "dot", "size": 20, "title": "NAME: argmin\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return int position of the smallest value in the Series. If the minimum is achieved in multiple locations, the first row position is returned. Parameters ---------- axis : {None} Unused. Parameter needed for compatibility with DataFrame. skipna : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series({\u0027Corn Flakes\u0027: 100.0, \u0027Almond Delight\u0027: 110.0,\n...                \u0027Cinnamon Toast Crunch\u0027: 120.0, \u0027Cocoa Puff\u0027: 110.0})\n\u003e\u003e\u003e s\nCorn Flakes              100.0\nAlmond Delight           110.0\nCinnamon Toast Crunch    120.0\nCocoa Puff               110.0\ndtype: float64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.argsort", "label": "argsort", "shape": "dot", "size": 20, "title": "NAME: argsort\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Return the integer indices that would sort the index. Parameters ---------- *args Passed to `numpy.ndarray.argsort`. **kwargs Passed to `numpy.ndarray.argsort`. Returns ------- np.ndarray[np.intp] Integer indices that would sort the index if used as an indexer. See Also -------- numpy.argsort : Similar...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027b\u0027, \u0027a\u0027, \u0027d\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027b\u0027, \u0027a\u0027, \u0027d\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.as_unit", "label": "as_unit", "shape": "dot", "size": 20, "title": "NAME: as_unit\n------------------------------\nINPUTS: self, unit\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Convert to a dtype with the given unit resolution. Parameters ---------- unit : {\u0027s\u0027, \u0027ms\u0027, \u0027us\u0027, \u0027ns\u0027} Returns ------- same type as self Examples -------- For :class:`pandas.DatetimeIndex`: \u003e\u003e\u003e idx = pd.DatetimeIndex([\u00272020-01-02 01:02:03.004005006\u0027]) \u003e\u003e\u003e idx DatetimeIndex([\u00272020-01-02 01:02:03.004005006\u0027], dtype=\u0027datetime64[ns]\u0027, freq=None) \u003e\u003e\u003e idx.as_unit(\u0027s\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.DatetimeIndex([\u00272020-01-02 01:02:03.004005006\u0027])\n\u003e\u003e\u003e idx\nDatetimeIndex([\u00272020-01-02 01:02:03.004005006\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=None)\n\u003e\u003e\u003e idx.as_unit(\u0027s\u0027)\nDatetimeIndex([\u00272020-01-02 01:02:03\u0027], dtype=\u0027datetime64[s]\u0027, freq=None)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.asof", "label": "asof", "shape": "dot", "size": 20, "title": "NAME: asof\n------------------------------\nINPUTS: self, label\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the label from the index, or, if not present, the previous one. Assuming that the index is sorted, return the passed index label if it is in the index, or return the previous index label if the passed one...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u00272013-12-31\u0027, \u00272014-01-02\u0027, \u00272014-01-03\u0027])\n\u003e\u003e\u003e idx.asof(\u00272014-01-01\u0027)\n\u00272013-12-31\u0027"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.asof_locs", "label": "asof_locs", "shape": "dot", "size": 20, "title": "NAME: asof_locs\n------------------------------\nINPUTS: self, where, mask\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Return the locations (indices) of labels in the index. As in the :meth:`pandas.Index.asof`, if the label (a particular entry in ``where``) is not in the index, the latest index label up to the passed label is chosen and its index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.date_range(\u00272023-06-01\u0027, periods=3, freq=\u0027D\u0027)\n\u003e\u003e\u003e where = pd.DatetimeIndex([\u00272023-05-30 00:12:00\u0027, \u00272023-06-01 00:00:00\u0027,\n...                           \u00272023-06-02 23:59:59\u0027])\n\u003e\u003e\u003e mask = np.ones(3, dtype=bool)\n\u003e\u003e\u003e idx.asof_locs(where, mask)\narray([-1,  0,  1])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.astype", "label": "astype", "shape": "dot", "size": 20, "title": "NAME: astype\n------------------------------\nINPUTS: self, dtype, copy\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Create an Index with values cast to dtypes. The class of a new Index is determined by dtype. When conversion is impossible, a TypeError exception is raised. Parameters ---------- dtype : numpy dtype or pandas type Note that any signed...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx.astype(\u0027float\u0027)\nIndex([1.0, 2.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.ceil", "label": "ceil", "shape": "dot", "size": 20, "title": "NAME: ceil\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Perform ceil operation on the data to the specified `freq`. Parameters ---------- freq : str or Offset The frequency level to ceil the index to. Must be a fixed frequency like \u0027S\u0027 (second) not \u0027ME\u0027 (month end). See :ref:`frequency aliases...\n\n\nEXAMPLE:\n\u003e\u003e\u003e rng = pd.date_range(\u00271/1/2018 11:59:00\u0027, periods=3, freq=\u0027min\u0027)\n\u003e\u003e\u003e rng\nDatetimeIndex([\u00272018-01-01 11:59:00\u0027, \u00272018-01-01 12:00:00\u0027,\n               \u00272018-01-01 12:01:00\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=\u0027min\u0027)\n\u003e\u003e\u003e rng.ceil(\u0027h\u0027)\nDatetimeIndex([\u00272018-01-01 12:00:00\u0027, \u00272018-01-01 12:00:00\u0027,\n               \u00272018-01-01 13:00:00\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=None)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.copy", "label": "copy", "shape": "dot", "size": 20, "title": "NAME: copy\n------------------------------\nINPUTS: self, name, deep\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make a copy of this object. Name is set on the new object. Parameters ---------- name : Label, optional Set name for new object. deep : bool, default False Returns ------- Index Index refer to new object which is a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e new_idx = idx.copy()\n\u003e\u003e\u003e idx is new_idx\nFalse"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.delete", "label": "delete", "shape": "dot", "size": 20, "title": "NAME: delete\n------------------------------\nINPUTS: self, loc\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Make new Index with passed location(-s) deleted. Parameters ---------- loc : int or list of int Location of item(-s) which will be deleted. Use a list of locations to delete more than one value at the same time. Returns -------...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.delete(1)\nIndex([\u0027a\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.diff", "label": "diff", "shape": "dot", "size": 20, "title": "NAME: diff\n------------------------------\nINPUTS: self, periods\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Computes the difference between consecutive values in the Index object. If periods is greater than 1, computes the difference between values that are `periods` number of positions apart. Parameters ---------- periods : int, optional The number of positions between the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import pandas as pd\n\u003e\u003e\u003e idx = pd.Index([10, 20, 30, 40, 50])\n\u003e\u003e\u003e idx.diff()\nIndex([nan, 10.0, 10.0, 10.0, 10.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.difference", "label": "difference", "shape": "dot", "size": 20, "title": "NAME: difference\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a new Index with elements of index not in `other`. This is the set difference of two Index objects. Parameters ---------- other : Index or array-like sort : bool or None, default None Whether to sort the resulting index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([2, 1, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.difference(idx2)\nIndex([1, 2], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx1.difference(idx2, sort=False)\nIndex([2, 1], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.drop", "label": "drop", "shape": "dot", "size": 20, "title": "NAME: drop\n------------------------------\nINPUTS: self, labels, errors\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Make new Index with passed list of labels deleted. Parameters ---------- labels : array-like or scalar errors : {\u0027ignore\u0027, \u0027raise\u0027}, default \u0027raise\u0027 If \u0027ignore\u0027, suppress error and existing labels are dropped. Returns ------- Index Will be same type as self,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.drop([\u0027a\u0027])\nIndex([\u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.drop_duplicates", "label": "drop_duplicates", "shape": "dot", "size": 20, "title": "NAME: drop_duplicates\n------------------------------\nINPUTS: self, keep\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return Index with duplicate values removed. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, ``False``}, default \u0027first\u0027 - \u0027first\u0027 : Drop duplicates except for the first occurrence. - \u0027last\u0027 : Drop duplicates except for the last occurrence. - ``False`` : Drop all...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027lama\u0027, \u0027cow\u0027, \u0027lama\u0027, \u0027beetle\u0027, \u0027lama\u0027, \u0027hippo\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.droplevel", "label": "droplevel", "shape": "dot", "size": 20, "title": "NAME: droplevel\n------------------------------\nINPUTS: self, level\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return index with requested level(s) removed. If resulting index has only 1 level left, the result will be of Index type, not MultiIndex. The original index is not modified inplace. Parameters ---------- level : int, str, or list-like, default 0...\n\n\nEXAMPLE:\n\u003e\u003e\u003e mi = pd.MultiIndex.from_arrays(\n... [[1, 2], [3, 4], [5, 6]], names=[\u0027x\u0027, \u0027y\u0027, \u0027z\u0027])\n\u003e\u003e\u003e mi\nMultiIndex([(1, 3, 5),\n            (2, 4, 6)],\n           names=[\u0027x\u0027, \u0027y\u0027, \u0027z\u0027])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.dropna", "label": "dropna", "shape": "dot", "size": 20, "title": "NAME: dropna\n------------------------------\nINPUTS: self, how\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return Index without NA/NaN values. Parameters ---------- how : {\u0027any\u0027, \u0027all\u0027}, default \u0027any\u0027 If the Index is a MultiIndex, drop the value when any or all levels are NaN. Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([1, np.nan, 3])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, np.nan, 3])\n\u003e\u003e\u003e idx.dropna()\nIndex([1.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.duplicated", "label": "duplicated", "shape": "dot", "size": 20, "title": "NAME: duplicated\n------------------------------\nINPUTS: self, keep\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Indicate duplicate index values. Duplicated values are indicated as ``True`` values in the resulting array. Either all duplicates, all except the first, or all except the last occurrence of duplicates can be indicated. Parameters ---------- keep : {\u0027first\u0027, \u0027last\u0027, False},...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027lama\u0027, \u0027cow\u0027, \u0027lama\u0027, \u0027beetle\u0027, \u0027lama\u0027])\n\u003e\u003e\u003e idx.duplicated()\narray([False, False,  True, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.equals", "label": "equals", "shape": "dot", "size": 20, "title": "NAME: equals\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Determines if two Index objects contain the same elements....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.factorize", "label": "factorize", "shape": "dot", "size": 20, "title": "NAME: factorize\n------------------------------\nINPUTS: self, sort, use_na_sentinel\nOUTPUTS: tuple[npt.NDArray[np.intp], Index]\n------------------------------\nDESCRIPTION: Encode the object as an enumerated type or categorical variable. This method is useful for obtaining a numeric representation of an array when all that matters is identifying distinct values. `factorize` is available as both a top-level function :func:`pandas.factorize`, and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e codes, uniques = pd.factorize(np.array([\u0027b\u0027, \u0027b\u0027, \u0027a\u0027, \u0027c\u0027, \u0027b\u0027], dtype=\"O\"))\n\u003e\u003e\u003e codes\narray([0, 0, 1, 2, 0])\n\u003e\u003e\u003e uniques\narray([\u0027b\u0027, \u0027a\u0027, \u0027c\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.fillna", "label": "fillna", "shape": "dot", "size": 20, "title": "NAME: fillna\n------------------------------\nINPUTS: self, value, downcast\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Fill NA/NaN values with the specified value. Parameters ---------- value : scalar Scalar value to use to fill holes (e.g. 0). This value cannot be a list-likes. downcast : dict, default is None A dict of item-\u003edtype of what to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([np.nan, np.nan, 3])\n\u003e\u003e\u003e idx.fillna(0)\nIndex([0.0, 0.0, 3.0], dtype=\u0027float64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.floor", "label": "floor", "shape": "dot", "size": 20, "title": "NAME: floor\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Perform floor operation on the data to the specified `freq`. Parameters ---------- freq : str or Offset The frequency level to floor the index to. Must be a fixed frequency like \u0027S\u0027 (second) not \u0027ME\u0027 (month end). See :ref:`frequency aliases...\n\n\nEXAMPLE:\n\u003e\u003e\u003e rng = pd.date_range(\u00271/1/2018 11:59:00\u0027, periods=3, freq=\u0027min\u0027)\n\u003e\u003e\u003e rng\nDatetimeIndex([\u00272018-01-01 11:59:00\u0027, \u00272018-01-01 12:00:00\u0027,\n               \u00272018-01-01 12:01:00\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=\u0027min\u0027)\n\u003e\u003e\u003e rng.floor(\u0027h\u0027)\nDatetimeIndex([\u00272018-01-01 11:00:00\u0027, \u00272018-01-01 12:00:00\u0027,\n               \u00272018-01-01 12:00:00\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=None)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.format", "label": "format", "shape": "dot", "size": 20, "title": "NAME: format\n------------------------------\nINPUTS: self, name, formatter, na_rep, date_format\nOUTPUTS: list[str]\n------------------------------\nDESCRIPTION: Render a string representation of the Index....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.get_indexer", "label": "get_indexer", "shape": "dot", "size": 20, "title": "NAME: get_indexer\n------------------------------\nINPUTS: self, target, method, limit, tolerance\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Compute indexer and mask for new index given the current index. The indexer should be then used as an input to ndarray.take to align the current data to the new index. Parameters ---------- target : Index method : {None, \u0027pad\u0027/\u0027ffill\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([\u0027c\u0027, \u0027a\u0027, \u0027b\u0027])\n\u003e\u003e\u003e index.get_indexer([\u0027a\u0027, \u0027b\u0027, \u0027x\u0027])\narray([ 1,  2, -1])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.get_indexer_for", "label": "get_indexer_for", "shape": "dot", "size": 20, "title": "NAME: get_indexer_for\n------------------------------\nINPUTS: self, target\nOUTPUTS: npt.NDArray[np.intp]\n------------------------------\nDESCRIPTION: Guaranteed return of an indexer even when non-unique. This dispatches to get_indexer or get_indexer_non_unique as appropriate. Returns ------- np.ndarray[np.intp] List of indices. Examples -------- \u003e\u003e\u003e idx = pd.Index([np.nan, \u0027var1\u0027, np.nan]) \u003e\u003e\u003e idx.get_indexer_for([np.nan]) array([0, 2])...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([np.nan, \u0027var1\u0027, np.nan])\n\u003e\u003e\u003e idx.get_indexer_for([np.nan])\narray([0, 2])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.get_indexer_non_unique", "label": "get_indexer_non_unique", "shape": "dot", "size": 20, "title": "NAME: get_indexer_non_unique\n------------------------------\nINPUTS: self, target\nOUTPUTS: tuple[npt.NDArray[np.intp], npt.NDArray[np.intp]]\n------------------------------\nDESCRIPTION: Compute indexer and mask for new index given the current index. The indexer should be then used as an input to ndarray.take to align the current data to the new index. Parameters ---------- target : Index Returns ------- indexer :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([\u0027c\u0027, \u0027b\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027])\n\u003e\u003e\u003e index.get_indexer_non_unique([\u0027b\u0027, \u0027b\u0027])\n(array([1, 3, 4, 1, 3, 4]), array([], dtype=int64))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.get_level_values", "label": "get_level_values", "shape": "dot", "size": 20, "title": "NAME: get_level_values\n------------------------------\nINPUTS: self, level\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Return an Index of values for requested level. This is primarily useful to get an individual level of values from a MultiIndex, but is provided on Index as well for compatibility. Parameters ---------- level : int or str It is...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abc\u0027))\n\u003e\u003e\u003e idx\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.get_loc", "label": "get_loc", "shape": "dot", "size": 20, "title": "NAME: get_loc\n------------------------------\nINPUTS: self, key\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Get integer location for requested label Returns ------- loc : int, slice, or ndarray[int]...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.get_slice_bound", "label": "get_slice_bound", "shape": "dot", "size": 20, "title": "NAME: get_slice_bound\n------------------------------\nINPUTS: self, label, side\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Calculate slice bound that corresponds to given label. Returns leftmost (one-past-the-rightmost if ``side==\u0027right\u0027``) position of given label. Parameters ---------- label : object side : {\u0027left\u0027, \u0027right\u0027} Returns ------- int Index of label. See Also -------- Index.get_loc : Get integer location,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.RangeIndex(5)\n\u003e\u003e\u003e idx.get_slice_bound(3, \u0027left\u0027)\n3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.groupby", "label": "groupby", "shape": "dot", "size": 20, "title": "NAME: groupby\n------------------------------\nINPUTS: self, values\nOUTPUTS: PrettyDict[Hashable, np.ndarray]\n------------------------------\nDESCRIPTION: Group the index labels by a given array of values. Parameters ---------- values : array Values used to determine the groups. Returns ------- dict {group name -\u003e group labels}...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.holds_integer", "label": "holds_integer", "shape": "dot", "size": 20, "title": "NAME: holds_integer\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Whether the type is an integer type. .. deprecated:: 2.0.0 Use `pandas.api.types.infer_dtype` instead...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.identical", "label": "identical", "shape": "dot", "size": 20, "title": "NAME: identical\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Similar to equals, but checks that object attributes and types are also equal. Returns ------- bool If two Index objects have equal elements and same type True, otherwise False. Examples -------- \u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027]) \u003e\u003e\u003e idx2 =...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx2 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx2.identical(idx1)\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.infer_objects", "label": "infer_objects", "shape": "dot", "size": 20, "title": "NAME: infer_objects\n------------------------------\nINPUTS: self, copy\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: If we have an object dtype, try to infer a non-object dtype. Parameters ---------- copy : bool, default True Whether to make a copy in cases where no inference occurs....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.insert", "label": "insert", "shape": "dot", "size": 20, "title": "NAME: insert\n------------------------------\nINPUTS: self, loc, item\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Make new Index inserting new item at location. Follows Python numpy.insert semantics for negative values. Parameters ---------- loc : int item : object Returns ------- Index Examples -------- \u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e idx.insert(1, \u0027x\u0027) Index([\u0027a\u0027, \u0027x\u0027, \u0027b\u0027,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.insert(1, \u0027x\u0027)\nIndex([\u0027a\u0027, \u0027x\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.intersection", "label": "intersection", "shape": "dot", "size": 20, "title": "NAME: intersection\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Form the intersection of two Index objects. This returns a new Index with elements common to the index and `other`. Parameters ---------- other : Index or array-like sort : True, False or None, default False Whether to sort the resulting...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.intersection(idx2)\nIndex([3, 4], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.is_", "label": "is_", "shape": "dot", "size": 20, "title": "NAME: is_\n------------------------------\nINPUTS: self, other\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: More flexible, faster check like ``is`` but that works through views. Note: this is *not* the same as ``Index.identical()``, which checks that metadata is also the same. Parameters ---------- other : object Other object to compare against. Returns ------- bool...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([\u00271\u0027, \u00272\u0027, \u00273\u0027])\n\u003e\u003e\u003e idx1.is_(idx1.view())\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.is_boolean", "label": "is_boolean", "shape": "dot", "size": 20, "title": "NAME: is_boolean\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of booleans. .. deprecated:: 2.0.0 Use `pandas.api.types.is_bool_dtype` instead. Returns ------- bool Whether or not the Index only consists of booleans. See Also -------- is_integer : Check if the Index only consists of integers (deprecated)....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([True, False, True])\n\u003e\u003e\u003e idx.is_boolean()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.is_categorical", "label": "is_categorical", "shape": "dot", "size": 20, "title": "NAME: is_categorical\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index holds categorical data. .. deprecated:: 2.0.0 Use `isinstance(index.dtype, pd.CategoricalDtype)` instead. Returns ------- bool True if the Index is categorical. See Also -------- CategoricalIndex : Index for categorical data. is_boolean : Check if the Index only consists...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\"Watermelon\", \"Orange\", \"Apple\",\n...                 \"Watermelon\"]).astype(\"category\")\n\u003e\u003e\u003e idx.is_categorical()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.is_floating", "label": "is_floating", "shape": "dot", "size": 20, "title": "NAME: is_floating\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index is a floating type. .. deprecated:: 2.0.0 Use `pandas.api.types.is_float_dtype` instead The Index may consist of only floats, NaNs, or a mix of floats, integers, or NaNs. Returns ------- bool Whether or not the Index only consists...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n\u003e\u003e\u003e idx.is_floating()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.is_integer", "label": "is_integer", "shape": "dot", "size": 20, "title": "NAME: is_integer\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of integers. .. deprecated:: 2.0.0 Use `pandas.api.types.is_integer_dtype` instead. Returns ------- bool Whether or not the Index only consists of integers. See Also -------- is_boolean : Check if the Index only consists of booleans (deprecated)....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx.is_integer()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.is_interval", "label": "is_interval", "shape": "dot", "size": 20, "title": "NAME: is_interval\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index holds Interval objects. .. deprecated:: 2.0.0 Use `isinstance(index.dtype, pd.IntervalDtype)` instead. Returns ------- bool Whether or not the Index holds Interval objects. See Also -------- IntervalIndex : Index for Interval objects. is_boolean : Check if the Index...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([pd.Interval(left=0, right=5),\n...                 pd.Interval(left=5, right=10)])\n\u003e\u003e\u003e idx.is_interval()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.is_numeric", "label": "is_numeric", "shape": "dot", "size": 20, "title": "NAME: is_numeric\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index only consists of numeric data. .. deprecated:: 2.0.0 Use `pandas.api.types.is_numeric_dtype` instead. Returns ------- bool Whether or not the Index only consists of numeric data. See Also -------- is_boolean : Check if the Index only consists of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1.0, 2.0, 3.0, 4.0])\n\u003e\u003e\u003e idx.is_numeric()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.is_object", "label": "is_object", "shape": "dot", "size": 20, "title": "NAME: is_object\n------------------------------\nINPUTS: self\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if the Index is of the object dtype. .. deprecated:: 2.0.0 Use `pandas.api.types.is_object_dtype` instead. Returns ------- bool Whether or not the Index is of the object dtype. See Also -------- is_boolean : Check if the Index only consists of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\"Apple\", \"Mango\", \"Watermelon\"])\n\u003e\u003e\u003e idx.is_object()  # doctest: +SKIP\nTrue"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.isin", "label": "isin", "shape": "dot", "size": 20, "title": "NAME: isin\n------------------------------\nINPUTS: self, values, level\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Return a boolean array where the index values are in `values`. Compute boolean array of whether each index value is found in the passed set of values. The length of the returned boolean array matches the length of the index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1,2,3])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.isna", "label": "isna", "shape": "dot", "size": 20, "title": "NAME: isna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get mapped to ``True`` values. Everything else get mapped to ``False`` values. Characters such as empty strings `\u0027\u0027`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.isna()\narray([False, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.isnull", "label": "isnull", "shape": "dot", "size": 20, "title": "NAME: isnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect missing values. Return a boolean same-sized object indicating if the values are NA. NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`pd.NaT`, get mapped to ``True`` values. Everything else get mapped to ``False`` values. Characters such as empty strings `\u0027\u0027`...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.isna()\narray([False, False,  True])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.item", "label": "item", "shape": "dot", "size": 20, "title": "NAME: item\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the first element of the underlying data as a Python scalar. Returns ------- scalar The first element of Series or Index. Raises ------ ValueError If the data is not length = 1. Examples -------- \u003e\u003e\u003e s = pd.Series([1]) \u003e\u003e\u003e...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1])\n\u003e\u003e\u003e s.item()\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.join", "label": "join", "shape": "dot", "size": 20, "title": "NAME: join\n------------------------------\nINPUTS: self, other, how, level, return_indexers, sort\nOUTPUTS: Index | tuple[Index, npt.NDArray[np.intp] | None, npt.NDArray[np.intp] | None]\n------------------------------\nDESCRIPTION: Compute join_index and indexers to conform data structures to the new index. Parameters ---------- other : Index how : {\u0027left\u0027, \u0027right\u0027, \u0027inner\u0027, \u0027outer\u0027} level : int or level name, default None return_indexers : bool, default False sort : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx2 = pd.Index([4, 5, 6])\n\u003e\u003e\u003e idx1.join(idx2, how=\u0027outer\u0027)\nIndex([1, 2, 3, 4, 5, 6], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.map", "label": "map", "shape": "dot", "size": 20, "title": "NAME: map\n------------------------------\nINPUTS: self, mapper, na_action\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Map values using an input mapping or function. Parameters ---------- mapper : function, dict, or Series Mapping correspondence. na_action : {None, \u0027ignore\u0027} If \u0027ignore\u0027, propagate NA values, without passing them to the mapping correspondence. Returns ------- Union[Index, MultiIndex] The output...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.map({1: \u0027a\u0027, 2: \u0027b\u0027, 3: \u0027c\u0027})\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.max", "label": "max", "shape": "dot", "size": 20, "title": "NAME: max\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the maximum value of the Index. Parameters ---------- axis : int, optional For compatibility with NumPy. Only 0 or None are allowed. skipna : bool, default True Exclude NA/null values when showing the result. *args, **kwargs Additional arguments and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([3, 2, 1])\n\u003e\u003e\u003e idx.max()\n3"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.mean", "label": "mean", "shape": "dot", "size": 20, "title": "NAME: mean\n------------------------------\nINPUTS: self, skipna, axis\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the mean value of the Array. Parameters ---------- skipna : bool, default True Whether to ignore any NaT elements. axis : int, optional, default 0 Returns ------- scalar Timestamp or Timedelta. See Also -------- numpy.ndarray.mean : Returns the average...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.date_range(\u00272001-01-01 00:00\u0027, periods=3)\n\u003e\u003e\u003e idx\nDatetimeIndex([\u00272001-01-01\u0027, \u00272001-01-02\u0027, \u00272001-01-03\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=\u0027D\u0027)\n\u003e\u003e\u003e idx.mean()\nTimestamp(\u00272001-01-02 00:00:00\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.median", "label": "median", "shape": "dot", "size": 20, "title": "NAME: median\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.memory_usage", "label": "memory_usage", "shape": "dot", "size": 20, "title": "NAME: memory_usage\n------------------------------\nINPUTS: self, deep\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Memory usage of the values. Parameters ---------- deep : bool, default False Introspect the data deeply, interrogate `object` dtypes for system-level memory consumption. Returns ------- bytes used See Also -------- numpy.ndarray.nbytes : Total bytes consumed by the elements of the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx.memory_usage()\n24"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.min", "label": "min", "shape": "dot", "size": 20, "title": "NAME: min\n------------------------------\nINPUTS: self, axis, skipna, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return the minimum value of the Index. Parameters ---------- axis : {None} Dummy argument for consistency with Series. skipna : bool, default True Exclude NA/null values when showing the result. *args, **kwargs Additional arguments and keywords for compatibility with NumPy....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([3, 2, 1])\n\u003e\u003e\u003e idx.min()\n1"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.notna", "label": "notna", "shape": "dot", "size": 20, "title": "NAME: notna\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to ``True``. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values. NA values, such as None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.notna()\narray([ True,  True, False])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.notnull", "label": "notnull", "shape": "dot", "size": 20, "title": "NAME: notnull\n------------------------------\nINPUTS: self\nOUTPUTS: npt.NDArray[np.bool_]\n------------------------------\nDESCRIPTION: Detect existing (non-missing) values. Return a boolean same-sized object indicating if the values are not NA. Non-missing values get mapped to ``True``. Characters such as empty strings ``\u0027\u0027`` or :attr:`numpy.inf` are not considered NA values. NA values, such as None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([5.2, 6.0, np.nan])\n\u003e\u003e\u003e idx\nIndex([5.2, 6.0, nan], dtype=\u0027float64\u0027)\n\u003e\u003e\u003e idx.notna()\narray([ True,  True, False])"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.nunique", "label": "nunique", "shape": "dot", "size": 20, "title": "NAME: nunique\n------------------------------\nINPUTS: self, dropna\nOUTPUTS: int\n------------------------------\nDESCRIPTION: Return number of unique elements in the object. Excludes NA values by default. Parameters ---------- dropna : bool, default True Don\u0027t include NaN in the count. Returns ------- int See Also -------- DataFrame.nunique: Method nunique for DataFrame. Series.count: Count non-NA/null...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 3, 5, 7, 7])\n\u003e\u003e\u003e s\n0    1\n1    3\n2    5\n3    7\n4    7\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.putmask", "label": "putmask", "shape": "dot", "size": 20, "title": "NAME: putmask\n------------------------------\nINPUTS: self, mask, value\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Return a new Index of the values set with the mask. Returns ------- Index See Also -------- numpy.ndarray.putmask : Changes elements of an array based on conditional and input values. Examples -------- \u003e\u003e\u003e idx1 = pd.Index([1, 2, 3]) \u003e\u003e\u003e idx2...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3])\n\u003e\u003e\u003e idx2 = pd.Index([5, 6, 7])\n\u003e\u003e\u003e idx1.putmask([True, False, False], idx2)\nIndex([5, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.ravel", "label": "ravel", "shape": "dot", "size": 20, "title": "NAME: ravel\n------------------------------\nINPUTS: self, order\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a view on self. Returns ------- Index See Also -------- numpy.ndarray.ravel : Return a flattened array. Examples -------- \u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e s.index.ravel() Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e s.index.ravel()\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.reindex", "label": "reindex", "shape": "dot", "size": 20, "title": "NAME: reindex\n------------------------------\nINPUTS: self, target, method, level, limit, tolerance\nOUTPUTS: tuple[Index, npt.NDArray[np.intp] | None]\n------------------------------\nDESCRIPTION: Create index with target\u0027s values. Parameters ---------- target : an iterable method : {None, \u0027pad\u0027/\u0027ffill\u0027, \u0027backfill\u0027/\u0027bfill\u0027, \u0027nearest\u0027}, optional * default: exact matches only. * pad / ffill: find the PREVIOUS index value if no exact match. * backfill / bfill:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.reindex([\u0027car\u0027, \u0027bike\u0027])\n(Index([\u0027car\u0027, \u0027bike\u0027], dtype=\u0027object\u0027), array([0, 1]))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.rename", "label": "rename", "shape": "dot", "size": 20, "title": "NAME: rename\n------------------------------\nINPUTS: self, name, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Alter Index or MultiIndex name. Able to set new names without level. Defaults to returning new index. Length of names must match number of levels in MultiIndex. Parameters ---------- name : label or list of labels Name(s) to set. inplace...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027A\u0027, \u0027C\u0027, \u0027A\u0027, \u0027B\u0027], name=\u0027score\u0027)\n\u003e\u003e\u003e idx.rename(\u0027grade\u0027)\nIndex([\u0027A\u0027, \u0027C\u0027, \u0027A\u0027, \u0027B\u0027], dtype=\u0027object\u0027, name=\u0027grade\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.repeat", "label": "repeat", "shape": "dot", "size": 20, "title": "NAME: repeat\n------------------------------\nINPUTS: self, repeats, axis\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Repeat elements of a Index. Returns a new Index where each element of the current Index is repeated consecutively a given number of times. Parameters ---------- repeats : int or array of ints The number of repetitions for each element....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.repeat(2)\nIndex([\u0027a\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027c\u0027, \u0027c\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.repeat([1, 2, 3])\nIndex([\u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027c\u0027, \u0027c\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.round", "label": "round", "shape": "dot", "size": 20, "title": "NAME: round\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Perform round operation on the data to the specified `freq`. Parameters ---------- freq : str or Offset The frequency level to round the index to. Must be a fixed frequency like \u0027S\u0027 (second) not \u0027ME\u0027 (month end). See :ref:`frequency aliases...\n\n\nEXAMPLE:\n\u003e\u003e\u003e rng = pd.date_range(\u00271/1/2018 11:59:00\u0027, periods=3, freq=\u0027min\u0027)\n\u003e\u003e\u003e rng\nDatetimeIndex([\u00272018-01-01 11:59:00\u0027, \u00272018-01-01 12:00:00\u0027,\n               \u00272018-01-01 12:01:00\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=\u0027min\u0027)\n\u003e\u003e\u003e rng.round(\u0027h\u0027)\nDatetimeIndex([\u00272018-01-01 12:00:00\u0027, \u00272018-01-01 12:00:00\u0027,\n               \u00272018-01-01 12:00:00\u0027],\n              dtype=\u0027datetime64[ns]\u0027, freq=None)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.searchsorted", "label": "searchsorted", "shape": "dot", "size": 20, "title": "NAME: searchsorted\n------------------------------\nINPUTS: self, value, side, sorter\nOUTPUTS: npt.NDArray[np.intp] | np.intp\n------------------------------\nDESCRIPTION: Find indices where elements should be inserted to maintain order. Find the indices into a sorted Index `self` such that, if the corresponding elements in `value` were inserted before the indices, the order of `self` would be preserved. .. note::...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([1, 2, 3])\n\u003e\u003e\u003e ser\n0    1\n1    2\n2    3\ndtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.set_names", "label": "set_names", "shape": "dot", "size": 20, "title": "NAME: set_names\n------------------------------\nINPUTS: self, names, level, inplace\nOUTPUTS: Self | None\n------------------------------\nDESCRIPTION: Set Index or MultiIndex name. Able to set new names partially and by level. Parameters ---------- names : label or list of label or dict-like for MultiIndex Name(s) to set. .. versionchanged:: 1.3.0 level : int, label or list of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027)\n\u003e\u003e\u003e idx.set_names(\u0027quarter\u0027)\nIndex([1, 2, 3, 4], dtype=\u0027int64\u0027, name=\u0027quarter\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.shift", "label": "shift", "shape": "dot", "size": 20, "title": "NAME: shift\n------------------------------\nINPUTS: self, periods, freq\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Shift index by desired number of time frequency increments. This method is for shifting the values of datetime-like indexes by a specified time increment a given number of times. Parameters ---------- periods : int, default 1 Number of periods (or...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.slice_indexer", "label": "slice_indexer", "shape": "dot", "size": 20, "title": "NAME: slice_indexer\n------------------------------\nINPUTS: self, start, end, step\nOUTPUTS: slice\n------------------------------\nDESCRIPTION: Compute the slice indexer for input labels and step. Index needs to be ordered and unique. Parameters ---------- start : label, default None If None, defaults to the beginning. end : label, default None If None, defaults to the end....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abcd\u0027))\n\u003e\u003e\u003e idx.slice_indexer(start=\u0027b\u0027, end=\u0027c\u0027)\nslice(1, 3, None)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.slice_locs", "label": "slice_locs", "shape": "dot", "size": 20, "title": "NAME: slice_locs\n------------------------------\nINPUTS: self, start, end, step\nOUTPUTS: tuple[int, int]\n------------------------------\nDESCRIPTION: Compute slice locations for input labels. Parameters ---------- start : label, default None If None, defaults to the beginning. end : label, default None If None, defaults to the end. step : int, defaults None If None, defaults to 1....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index(list(\u0027abcd\u0027))\n\u003e\u003e\u003e idx.slice_locs(start=\u0027b\u0027, end=\u0027c\u0027)\n(1, 3)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.sort", "label": "sort", "shape": "dot", "size": 20, "title": "NAME: sort\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Use sort_values instead....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.sort_values", "label": "sort_values", "shape": "dot", "size": 20, "title": "NAME: sort_values\n------------------------------\nINPUTS: self, return_indexer, ascending, na_position, key\nOUTPUTS: Self | tuple[Self, np.ndarray]\n------------------------------\nDESCRIPTION: Return a sorted copy of the index. Return a sorted copy of the index, and optionally return the indices that sorted the index itself. Parameters ---------- return_indexer : bool, default False Should the indices that would sort the index be...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([10, 100, 1, 1000])\n\u003e\u003e\u003e idx\nIndex([10, 100, 1, 1000], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.sortlevel", "label": "sortlevel", "shape": "dot", "size": 20, "title": "NAME: sortlevel\n------------------------------\nINPUTS: self, level, ascending, sort_remaining, na_position\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: For internal compatibility with the Index API. Sort the Index. This is for compat with MultiIndex Parameters ---------- ascending : bool, default True False to sort in descending order na_position : {\u0027first\u0027 or \u0027last\u0027}, default \u0027first\u0027 Argument \u0027first\u0027 puts NaNs...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.std", "label": "std", "shape": "dot", "size": 20, "title": "NAME: std\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.str", "label": "str", "shape": "dot", "size": 20, "title": "NAME: str\n------------------------------\nINPUTS: data\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Vectorized string functions for Series and Index. NAs stay NA unless handled otherwise by a particular method. Patterned after Python\u0027s string methods, with some inspiration from R\u0027s stringr package. Examples -------- \u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"]) \u003e\u003e\u003e s 0 A_Str_Series dtype:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([\"A_Str_Series\"])\n\u003e\u003e\u003e s\n0    A_Str_Series\ndtype: object"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.sum", "label": "sum", "shape": "dot", "size": 20, "title": "NAME: sum\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.symmetric_difference", "label": "symmetric_difference", "shape": "dot", "size": 20, "title": "NAME: symmetric_difference\n------------------------------\nINPUTS: self, other, result_name, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Compute the symmetric difference of two Index objects. Parameters ---------- other : Index or array-like result_name : str sort : bool or None, default None Whether to sort the resulting index. By default, the values are attempted to be sorted,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([2, 3, 4, 5])\n\u003e\u003e\u003e idx1.symmetric_difference(idx2)\nIndex([1, 5], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.take", "label": "take", "shape": "dot", "size": 20, "title": "NAME: take\n------------------------------\nINPUTS: self, indices, axis, allow_fill, fill_value, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return a new Index of the values selected by the indices. For internal compatibility with numpy arrays. Parameters ---------- indices : array-like Indices to be taken. axis : int, optional The axis over which to select values, always 0. allow_fill...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e idx.take([2, 2, 1, 2])\nIndex([\u0027c\u0027, \u0027c\u0027, \u0027b\u0027, \u0027c\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.to_flat_index", "label": "to_flat_index", "shape": "dot", "size": 20, "title": "NAME: to_flat_index\n------------------------------\nINPUTS: self\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Identity method. This is implemented for compatibility with subclass implementations when chaining. Returns ------- pd.Index Caller. See Also -------- MultiIndex.to_flat_index : Subclass implementation....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.to_frame", "label": "to_frame", "shape": "dot", "size": 20, "title": "NAME: to_frame\n------------------------------\nINPUTS: self, index, name\nOUTPUTS: DataFrame\n------------------------------\nDESCRIPTION: Create a DataFrame with a column containing the Index. Parameters ---------- index : bool, default True Set the index of the returned DataFrame as the original Index. name : object, defaults to index.name The passed name should substitute for the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027Ant\u0027, \u0027Bear\u0027, \u0027Cow\u0027], name=\u0027animal\u0027)\n\u003e\u003e\u003e idx.to_frame()\n       animal\nanimal\nAnt       Ant\nBear     Bear\nCow       Cow"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.to_list", "label": "to_list", "shape": "dot", "size": 20, "title": "NAME: to_list\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list See Also -------- numpy.ndarray.tolist : Return the array as an...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.to_list()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.to_numpy", "label": "to_numpy", "shape": "dot", "size": 20, "title": "NAME: to_numpy\n------------------------------\nINPUTS: self, dtype, copy, na_value, kwargs\nOUTPUTS: np.ndarray\n------------------------------\nDESCRIPTION: A NumPy ndarray representing the values in this Series or Index. Parameters ---------- dtype : str or numpy.dtype, optional The dtype to pass to :meth:`numpy.asarray`. copy : bool, default False Whether to ensure that the returned value is not a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series(pd.Categorical([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027]))\n\u003e\u003e\u003e ser.to_numpy()\narray([\u0027a\u0027, \u0027b\u0027, \u0027a\u0027], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.to_pytimedelta", "label": "to_pytimedelta", "shape": "dot", "size": 20, "title": "NAME: to_pytimedelta\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return an ndarray of datetime.timedelta objects. Returns ------- numpy.ndarray Examples -------- \u003e\u003e\u003e tdelta_idx = pd.to_timedelta([1, 2, 3], unit=\u0027D\u0027) \u003e\u003e\u003e tdelta_idx TimedeltaIndex([\u00271 days\u0027, \u00272 days\u0027, \u00273 days\u0027], dtype=\u0027timedelta64[ns]\u0027, freq=None) \u003e\u003e\u003e tdelta_idx.to_pytimedelta() array([datetime.timedelta(days=1), datetime.timedelta(days=2), datetime.timedelta(days=3)], dtype=object)...\n\n\nEXAMPLE:\n\u003e\u003e\u003e tdelta_idx = pd.to_timedelta([1, 2, 3], unit=\u0027D\u0027)\n\u003e\u003e\u003e tdelta_idx\nTimedeltaIndex([\u00271 days\u0027, \u00272 days\u0027, \u00273 days\u0027],\n                dtype=\u0027timedelta64[ns]\u0027, freq=None)\n\u003e\u003e\u003e tdelta_idx.to_pytimedelta()\narray([datetime.timedelta(days=1), datetime.timedelta(days=2),\n       datetime.timedelta(days=3)], dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.to_series", "label": "to_series", "shape": "dot", "size": 20, "title": "NAME: to_series\n------------------------------\nINPUTS: self, index, name\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Create a Series with both index and values equal to the index keys. Useful with map for returning an indexer based on an index. Parameters ---------- index : Index, optional Index of resulting Series. If None, defaults to original index....\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027Ant\u0027, \u0027Bear\u0027, \u0027Cow\u0027], name=\u0027animal\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.tolist", "label": "tolist", "shape": "dot", "size": 20, "title": "NAME: tolist\n------------------------------\nINPUTS: self\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return a list of the values. These are each a scalar type, which is a Python scalar (for str, int, float) or a pandas scalar (for Timestamp/Timedelta/Interval/Period) Returns ------- list See Also -------- numpy.ndarray.tolist : Return the array as an...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([1, 2, 3])\n\u003e\u003e\u003e s.to_list()\n[1, 2, 3]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.total_seconds", "label": "total_seconds", "shape": "dot", "size": 20, "title": "NAME: total_seconds\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Return total duration of each element expressed in seconds. This method is available directly on TimedeltaArray, TimedeltaIndex and on Series containing timedelta values under the ``.dt`` namespace. Returns ------- ndarray, Index or Series When the calling object is a TimedeltaArray,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(pd.to_timedelta(np.arange(5), unit=\u0027d\u0027))\n\u003e\u003e\u003e s\n0   0 days\n1   1 days\n2   2 days\n3   3 days\n4   4 days\ndtype: timedelta64[ns]"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.transpose", "label": "transpose", "shape": "dot", "size": 20, "title": "NAME: transpose\n------------------------------\nINPUTS: self, args, kwargs\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return the transpose, which is by definition self. Returns ------- %(klass)s...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.union", "label": "union", "shape": "dot", "size": 20, "title": "NAME: union\n------------------------------\nINPUTS: self, other, sort\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Form the union of two Index objects. If the Index objects are incompatible, both Index objects will be cast to dtype(\u0027object\u0027) first. Parameters ---------- other : Index or array-like sort : bool or None, default None Whether to sort the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([1, 2, 3, 4])\n\u003e\u003e\u003e idx2 = pd.Index([3, 4, 5, 6])\n\u003e\u003e\u003e idx1.union(idx2)\nIndex([1, 2, 3, 4, 5, 6], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.unique", "label": "unique", "shape": "dot", "size": 20, "title": "NAME: unique\n------------------------------\nINPUTS: self, level\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Return unique values in the index. Unique values are returned in order of appearance, this does NOT sort. Parameters ---------- level : int or hashable, optional Only return values from specified level (for MultiIndex). If int, gets the level by...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([1, 1, 2, 3, 3])\n\u003e\u003e\u003e idx.unique()\nIndex([1, 2, 3], dtype=\u0027int64\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.value_counts", "label": "value_counts", "shape": "dot", "size": 20, "title": "NAME: value_counts\n------------------------------\nINPUTS: self, normalize, sort, ascending, bins, dropna\nOUTPUTS: Series\n------------------------------\nDESCRIPTION: Return a Series containing counts of unique values. The resulting object will be in descending order so that the first element is the most frequently-occurring element. Excludes NA values by default. Parameters ---------- normalize : bool, default False If True...\n\n\nEXAMPLE:\n\u003e\u003e\u003e index = pd.Index([3, 1, 2, 3, 4, np.nan])\n\u003e\u003e\u003e index.value_counts()\n3.0    2\n1.0    1\n2.0    1\n4.0    1\nName: count, dtype: int64"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.view", "label": "view", "shape": "dot", "size": 20, "title": "NAME: view\n------------------------------\nINPUTS: self, cls\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.TimedeltaIndex.where", "label": "where", "shape": "dot", "size": 20, "title": "NAME: where\n------------------------------\nINPUTS: self, cond, other\nOUTPUTS: Index\n------------------------------\nDESCRIPTION: Replace values where the condition is False. The replacement is taken from other. Parameters ---------- cond : bool array-like with the same length as self Condition to select the values on. other : scalar, or array-like, default None Replacement if...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.Index([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027])\n\u003e\u003e\u003e idx\nIndex([\u0027car\u0027, \u0027bike\u0027, \u0027train\u0027, \u0027tractor\u0027], dtype=\u0027object\u0027)\n\u003e\u003e\u003e idx.where(idx.isin([\u0027car\u0027, \u0027train\u0027]), \u0027other\u0027)\nIndex([\u0027car\u0027, \u0027other\u0027, \u0027train\u0027, \u0027other\u0027], dtype=\u0027object\u0027)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt16Dtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: \nOUTPUTS: type[IntegerArray]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt16Dtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Construct this type from a string. This is useful mainly for data types that accept parameters. For example, a period dtype accepts a frequency parameter that can be set as ``period[h]`` (where H means hourly frequency). By default, in the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import re\n\u003e\u003e\u003e @classmethod\n... def construct_from_string(cls, string):\n...     pattern = re.compile(r\"^my_type\\[(?P\u003carg_name\u003e.+)\\]$\")\n...     match = pattern.match(string)\n...     if match:\n...         return cls(**match.groupdict())\n...     else:\n...         raise TypeError(\n...             f\"Cannot construct a \u0027{cls.__name__}\u0027 from \u0027{string}\u0027\"\n...         )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt16Dtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt16Dtype.from_numpy_dtype", "label": "from_numpy_dtype", "shape": "dot", "size": 20, "title": "NAME: from_numpy_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: BaseMaskedDtype\n------------------------------\nDESCRIPTION: Construct the MaskedDtype corresponding to the given numpy dtype....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt16Dtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if we match \u0027dtype\u0027. Parameters ---------- dtype : object The object to check. Returns ------- bool Notes ----- The default implementation is True if 1. ``cls.construct_from_string(dtype)`` is an instance of ``cls``. 2. ``dtype`` is an object and is an...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.UInt16Dtype.type", "label": "type", "shape": "dot", "size": 20, "title": "NAME: type\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Unsigned integer type, compatible with C ``unsigned short``. :Character code: ``\u0027H\u0027`` :Canonical name: `numpy.ushort` :Alias on this platform (win32 AMD64): `numpy.uint16`: 16-bit unsigned integer (``0`` to ``65_535``)....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt32Dtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: \nOUTPUTS: type[IntegerArray]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt32Dtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Construct this type from a string. This is useful mainly for data types that accept parameters. For example, a period dtype accepts a frequency parameter that can be set as ``period[h]`` (where H means hourly frequency). By default, in the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import re\n\u003e\u003e\u003e @classmethod\n... def construct_from_string(cls, string):\n...     pattern = re.compile(r\"^my_type\\[(?P\u003carg_name\u003e.+)\\]$\")\n...     match = pattern.match(string)\n...     if match:\n...         return cls(**match.groupdict())\n...     else:\n...         raise TypeError(\n...             f\"Cannot construct a \u0027{cls.__name__}\u0027 from \u0027{string}\u0027\"\n...         )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt32Dtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt32Dtype.from_numpy_dtype", "label": "from_numpy_dtype", "shape": "dot", "size": 20, "title": "NAME: from_numpy_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: BaseMaskedDtype\n------------------------------\nDESCRIPTION: Construct the MaskedDtype corresponding to the given numpy dtype....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt32Dtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if we match \u0027dtype\u0027. Parameters ---------- dtype : object The object to check. Returns ------- bool Notes ----- The default implementation is True if 1. ``cls.construct_from_string(dtype)`` is an instance of ``cls``. 2. ``dtype`` is an object and is an...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.UInt32Dtype.type", "label": "type", "shape": "dot", "size": 20, "title": "NAME: type\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Unsigned integer type, compatible with C ``unsigned long``. :Character code: ``\u0027L\u0027`` :Canonical name: `numpy.uint` :Alias on this platform (win32 AMD64): `numpy.uint32`: 32-bit unsigned integer (``0`` to ``4_294_967_295``)....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt64Dtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: \nOUTPUTS: type[IntegerArray]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt64Dtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Construct this type from a string. This is useful mainly for data types that accept parameters. For example, a period dtype accepts a frequency parameter that can be set as ``period[h]`` (where H means hourly frequency). By default, in the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import re\n\u003e\u003e\u003e @classmethod\n... def construct_from_string(cls, string):\n...     pattern = re.compile(r\"^my_type\\[(?P\u003carg_name\u003e.+)\\]$\")\n...     match = pattern.match(string)\n...     if match:\n...         return cls(**match.groupdict())\n...     else:\n...         raise TypeError(\n...             f\"Cannot construct a \u0027{cls.__name__}\u0027 from \u0027{string}\u0027\"\n...         )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt64Dtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt64Dtype.from_numpy_dtype", "label": "from_numpy_dtype", "shape": "dot", "size": 20, "title": "NAME: from_numpy_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: BaseMaskedDtype\n------------------------------\nDESCRIPTION: Construct the MaskedDtype corresponding to the given numpy dtype....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt64Dtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if we match \u0027dtype\u0027. Parameters ---------- dtype : object The object to check. Returns ------- bool Notes ----- The default implementation is True if 1. ``cls.construct_from_string(dtype)`` is an instance of ``cls``. 2. ``dtype`` is an object and is an...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.UInt64Dtype.type", "label": "type", "shape": "dot", "size": 20, "title": "NAME: type\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Signed integer type, compatible with C ``unsigned long long``. :Character code: ``\u0027Q\u0027`` :Canonical name: `numpy.ulonglong` :Alias on this platform (win32 AMD64): `numpy.uint64`: 64-bit unsigned integer (``0`` to ``18_446_744_073_709_551_615``). :Alias on this platform (win32 AMD64): `numpy.uintp`: Unsigned integer large enough to...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt8Dtype.construct_array_type", "label": "construct_array_type", "shape": "dot", "size": 20, "title": "NAME: construct_array_type\n------------------------------\nINPUTS: \nOUTPUTS: type[IntegerArray]\n------------------------------\nDESCRIPTION: Return the array type associated with this dtype. Returns ------- type...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt8Dtype.construct_from_string", "label": "construct_from_string", "shape": "dot", "size": 20, "title": "NAME: construct_from_string\n------------------------------\nINPUTS: string\nOUTPUTS: Self\n------------------------------\nDESCRIPTION: Construct this type from a string. This is useful mainly for data types that accept parameters. For example, a period dtype accepts a frequency parameter that can be set as ``period[h]`` (where H means hourly frequency). By default, in the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import re\n\u003e\u003e\u003e @classmethod\n... def construct_from_string(cls, string):\n...     pattern = re.compile(r\"^my_type\\[(?P\u003carg_name\u003e.+)\\]$\")\n...     match = pattern.match(string)\n...     if match:\n...         return cls(**match.groupdict())\n...     else:\n...         raise TypeError(\n...             f\"Cannot construct a \u0027{cls.__name__}\u0027 from \u0027{string}\u0027\"\n...         )"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt8Dtype.empty", "label": "empty", "shape": "dot", "size": 20, "title": "NAME: empty\n------------------------------\nINPUTS: self, shape\nOUTPUTS: ExtensionArray\n------------------------------\nDESCRIPTION: Construct an ExtensionArray of this dtype with the given shape. Analogous to numpy.empty. Parameters ---------- shape : int or tuple[int] Returns ------- ExtensionArray...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt8Dtype.from_numpy_dtype", "label": "from_numpy_dtype", "shape": "dot", "size": 20, "title": "NAME: from_numpy_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: BaseMaskedDtype\n------------------------------\nDESCRIPTION: Construct the MaskedDtype corresponding to the given numpy dtype....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.UInt8Dtype.is_dtype", "label": "is_dtype", "shape": "dot", "size": 20, "title": "NAME: is_dtype\n------------------------------\nINPUTS: dtype\nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Check if we match \u0027dtype\u0027. Parameters ---------- dtype : object The object to check. Returns ------- bool Notes ----- The default implementation is True if 1. ``cls.construct_from_string(dtype)`` is an instance of ``cls``. 2. ``dtype`` is an object and is an...\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.UInt8Dtype.type", "label": "type", "shape": "dot", "size": 20, "title": "NAME: type\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Unsigned integer type, compatible with C ``unsigned char``. :Character code: ``\u0027B\u0027`` :Canonical name: `numpy.ubyte` :Alias on this platform (win32 AMD64): `numpy.uint8`: 8-bit unsigned integer (``0`` to ``255``)....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.api.extensions", "label": "extensions", "shape": "dot", "size": 20, "title": "NAME: extensions\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Public API for extending pandas objects....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.api.indexers", "label": "indexers", "shape": "dot", "size": 20, "title": "NAME: indexers\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Public API for Rolling Window Indexers....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.api.interchange", "label": "interchange", "shape": "dot", "size": 20, "title": "NAME: interchange\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Public API for DataFrame interchange protocol....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.api.types", "label": "types", "shape": "dot", "size": 20, "title": "NAME: types\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Public toolkit API....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.api.typing", "label": "typing", "shape": "dot", "size": 20, "title": "NAME: typing\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Public API classes that store intermediate results useful for type-hinting....\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.arrays.ArrowExtensionArray", "label": "ArrowExtensionArray", "shape": "dot", "size": 20, "title": "NAME: ArrowExtensionArray\n------------------------------\nINPUTS: values\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Pandas ExtensionArray backed by a PyArrow ChunkedArray. .. warning:: ArrowExtensionArray is considered experimental. The implementation and parts of the API may change without warning. Parameters ---------- values : pyarrow.Array or pyarrow.ChunkedArray Attributes ---------- None Methods ------- None Returns ------- ArrowExtensionArray...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.array([1, 1, None], dtype=\"int64[pyarrow]\")\n\u003cArrowExtensionArray\u003e\n[1, 1, \u003cNA\u003e]\nLength: 3, dtype: int64[pyarrow]"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.arrays.ArrowStringArray", "label": "ArrowStringArray", "shape": "dot", "size": 20, "title": "NAME: ArrowStringArray\n------------------------------\nINPUTS: values\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Extension array for string data in a ``pyarrow.ChunkedArray``. .. warning:: ArrowStringArray is considered experimental. The implementation and parts of the API may change without warning. Parameters ---------- values : pyarrow.Array or pyarrow.ChunkedArray The array of data. Attributes ---------- None Methods...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.array([\u0027This is\u0027, \u0027some text\u0027, None, \u0027data.\u0027], dtype=\"string[pyarrow]\")\n\u003cArrowStringArray\u003e\n[\u0027This is\u0027, \u0027some text\u0027, \u003cNA\u003e, \u0027data.\u0027]\nLength: 4, dtype: string"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.arrays.BooleanArray", "label": "BooleanArray", "shape": "dot", "size": 20, "title": "NAME: BooleanArray\n------------------------------\nINPUTS: values, mask, copy\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Array of boolean (True/False) data with missing values. This is a pandas Extension array for boolean data, under the hood represented by 2 numpy arrays: a boolean array with the data and a boolean array with the mask (True indicating...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.array([True, False, None], dtype=\"boolean\")\n\u003cBooleanArray\u003e\n[True, False, \u003cNA\u003e]\nLength: 3, dtype: boolean"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.arrays.Categorical", "label": "Categorical", "shape": "dot", "size": 20, "title": "NAME: Categorical\n------------------------------\nINPUTS: values, categories, ordered, dtype, fastpath, copy\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Represent a categorical variable in classic R / S-plus fashion. `Categoricals` can only take on a limited, and usually fixed, number of possible values (`categories`). In contrast to statistical categorical variables, a `Categorical` might have an order, but numerical operations...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.Categorical([1, 2, 3, 1, 2, 3])\n[1, 2, 3, 1, 2, 3]\nCategories (3, int64): [1, 2, 3]"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.arrays.DatetimeArray", "label": "DatetimeArray", "shape": "dot", "size": 20, "title": "NAME: DatetimeArray\n------------------------------\nINPUTS: values, dtype, freq, copy\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Pandas ExtensionArray for tz-naive or tz-aware datetime data. .. warning:: DatetimeArray is currently experimental, and its API may change without warning. In particular, :attr:`DatetimeArray.dtype` is expected to change to always be an instance of an ``ExtensionDtype`` subclass. Parameters ---------- values...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.arrays.DatetimeArray._from_sequence(\n...    pd.DatetimeIndex([\u00272023-01-01\u0027, \u00272023-01-02\u0027], freq=\u0027D\u0027))\n\u003cDatetimeArray\u003e\n[\u00272023-01-01 00:00:00\u0027, \u00272023-01-02 00:00:00\u0027]\nLength: 2, dtype: datetime64[ns]"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.arrays.FloatingArray", "label": "FloatingArray", "shape": "dot", "size": 20, "title": "NAME: FloatingArray\n------------------------------\nINPUTS: values, mask, copy\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Array of floating (optional missing) values. .. warning:: FloatingArray is currently experimental, and its API or internal implementation may change without warning. Especially the behaviour regarding NaN (distinct from NA missing values) is subject to change. We represent a FloatingArray...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.array([0.1, None, 0.3], dtype=pd.Float32Dtype())\n\u003cFloatingArray\u003e\n[0.1, \u003cNA\u003e, 0.3]\nLength: 3, dtype: Float32"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.arrays.IntegerArray", "label": "IntegerArray", "shape": "dot", "size": 20, "title": "NAME: IntegerArray\n------------------------------\nINPUTS: values, mask, copy\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Array of integer (optional missing) values. Uses :attr:`pandas.NA` as the missing value. .. warning:: IntegerArray is currently experimental, and its API or internal implementation may change without warning. We represent an IntegerArray with 2 numpy arrays: - data: contains a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e int_array = pd.array([1, None, 3], dtype=pd.Int32Dtype())\n\u003e\u003e\u003e int_array\n\u003cIntegerArray\u003e\n[1, \u003cNA\u003e, 3]\nLength: 3, dtype: Int32"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.arrays.IntervalArray", "label": "IntervalArray", "shape": "dot", "size": 20, "title": "NAME: IntervalArray\n------------------------------\nINPUTS: data, closed, dtype, copy, verify_integrity\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Pandas array for interval data that are closed on the same side. Parameters ---------- data : array-like (1-dimensional) Array-like (ndarray, :class:`DateTimeArray`, :class:`TimeDeltaArray`) containing Interval objects from which to build the IntervalArray. closed : {\u0027left\u0027, \u0027right\u0027, \u0027both\u0027, \u0027neither\u0027}, default \u0027right\u0027 Whether...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.arrays.IntervalArray([pd.Interval(0, 1), pd.Interval(1, 5)])\n\u003cIntervalArray\u003e\n[(0, 1], (1, 5]]\nLength: 2, dtype: interval[int64, right]"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.arrays.NumpyExtensionArray", "label": "NumpyExtensionArray", "shape": "dot", "size": 20, "title": "NAME: NumpyExtensionArray\n------------------------------\nINPUTS: values, copy\nOUTPUTS: None\n------------------------------\nDESCRIPTION: A pandas ExtensionArray for NumPy data. This is mostly for internal compatibility, and is not especially useful on its own. Parameters ---------- values : ndarray The NumPy ndarray to wrap. Must be 1-dimensional. copy : bool, default False Whether to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.arrays.NumpyExtensionArray(np.array([0, 1, 2, 3]))\n\u003cNumpyExtensionArray\u003e\n[0, 1, 2, 3]\nLength: 4, dtype: int64"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.arrays.PeriodArray", "label": "PeriodArray", "shape": "dot", "size": 20, "title": "NAME: PeriodArray\n------------------------------\nINPUTS: values, dtype, freq, copy\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Pandas ExtensionArray for storing Period data. Users should use :func:`~pandas.array` to create new instances. Parameters ---------- values : Union[PeriodArray, Series[period], ndarray[int], PeriodIndex] The data to store. These should be arrays that can be directly converted to ordinals without inference or...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.arrays.PeriodArray(pd.PeriodIndex([\u00272023-01-01\u0027,\n...                                       \u00272023-01-02\u0027], freq=\u0027D\u0027))\n\u003cPeriodArray\u003e\n[\u00272023-01-01\u0027, \u00272023-01-02\u0027]\nLength: 2, dtype: period[D]"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.arrays.SparseArray", "label": "SparseArray", "shape": "dot", "size": 20, "title": "NAME: SparseArray\n------------------------------\nINPUTS: data, sparse_index, fill_value, kind, dtype, copy\nOUTPUTS: None\n------------------------------\nDESCRIPTION: An ExtensionArray for storing sparse data. Parameters ---------- data : array-like or scalar A dense array of values to store in the SparseArray. This may contain `fill_value`. sparse_index : SparseIndex, optional fill_value : scalar, optional Elements in data that are...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas.arrays import SparseArray\n\u003e\u003e\u003e arr = SparseArray([0, 0, 1, 2])\n\u003e\u003e\u003e arr\n[0, 0, 1, 2]\nFill: 0\nIntIndex\nIndices: array([2, 3], dtype=int32)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.arrays.StringArray", "label": "StringArray", "shape": "dot", "size": 20, "title": "NAME: StringArray\n------------------------------\nINPUTS: values, copy\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Extension array for string data. .. warning:: StringArray is considered experimental. The implementation and parts of the API may change without warning. Parameters ---------- values : array-like The array of data. .. warning:: Currently, this expects an object-dtype ndarray where...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.array([\u0027This is\u0027, \u0027some text\u0027, None, \u0027data.\u0027], dtype=\"string\")\n\u003cStringArray\u003e\n[\u0027This is\u0027, \u0027some text\u0027, \u003cNA\u003e, \u0027data.\u0027]\nLength: 4, dtype: string"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.arrays.TimedeltaArray", "label": "TimedeltaArray", "shape": "dot", "size": 20, "title": "NAME: TimedeltaArray\n------------------------------\nINPUTS: values, dtype, freq, copy\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Pandas ExtensionArray for timedelta data. .. warning:: TimedeltaArray is currently experimental, and its API may change without warning. In particular, :attr:`TimedeltaArray.dtype` is expected to change to be an instance of an ``ExtensionDtype`` subclass. Parameters ---------- values : array-like The timedelta...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.arrays.TimedeltaArray._from_sequence(pd.TimedeltaIndex([\u00271h\u0027, \u00272h\u0027]))\n\u003cTimedeltaArray\u003e\n[\u00270 days 01:00:00\u0027, \u00270 days 02:00:00\u0027]\nLength: 2, dtype: timedelta64[ns]"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.compat.compressors", "label": "compressors", "shape": "dot", "size": 20, "title": "NAME: compressors\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Patched ``BZ2File`` and ``LZMAFile`` to handle pickle protocol 5....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.compat.get_bz2_file", "label": "get_bz2_file", "shape": "dot", "size": 20, "title": "NAME: get_bz2_file\n------------------------------\nINPUTS: \nOUTPUTS: type[pandas.compat.compressors.BZ2File]\n------------------------------\nDESCRIPTION: Importing the `BZ2File` class from the `bz2` module. Returns ------- class The `BZ2File` class from the `bz2` module. Raises ------ RuntimeError If the `bz2` module was not imported correctly, or didn\u0027t exist....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.compat.get_lzma_file", "label": "get_lzma_file", "shape": "dot", "size": 20, "title": "NAME: get_lzma_file\n------------------------------\nINPUTS: \nOUTPUTS: type[pandas.compat.compressors.LZMAFile]\n------------------------------\nDESCRIPTION: Importing the `LZMAFile` class from the `lzma` module. Returns ------- class The `LZMAFile` class from the `lzma` module. Raises ------ RuntimeError If the `lzma` module was not imported correctly, or didn\u0027t exist....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.compat.is_ci_environment", "label": "is_ci_environment", "shape": "dot", "size": 20, "title": "NAME: is_ci_environment\n------------------------------\nINPUTS: \nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Checking if running in a continuous integration environment by checking the PANDAS_CI environment variable. Returns ------- bool True if the running in a continuous integration environment....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.compat.is_platform_arm", "label": "is_platform_arm", "shape": "dot", "size": 20, "title": "NAME: is_platform_arm\n------------------------------\nINPUTS: \nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Checking if the running platform use ARM architecture. Returns ------- bool True if the running platform uses ARM architecture....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.compat.is_platform_linux", "label": "is_platform_linux", "shape": "dot", "size": 20, "title": "NAME: is_platform_linux\n------------------------------\nINPUTS: \nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Checking if the running platform is linux. Returns ------- bool True if the running platform is linux....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.compat.is_platform_little_endian", "label": "is_platform_little_endian", "shape": "dot", "size": 20, "title": "NAME: is_platform_little_endian\n------------------------------\nINPUTS: \nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Checking if the running platform is little endian. Returns ------- bool True if the running platform is little endian....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.compat.is_platform_mac", "label": "is_platform_mac", "shape": "dot", "size": 20, "title": "NAME: is_platform_mac\n------------------------------\nINPUTS: \nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Checking if the running platform is mac. Returns ------- bool True if the running platform is mac....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.compat.is_platform_power", "label": "is_platform_power", "shape": "dot", "size": 20, "title": "NAME: is_platform_power\n------------------------------\nINPUTS: \nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Checking if the running platform use Power architecture. Returns ------- bool True if the running platform uses ARM architecture....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.compat.is_platform_windows", "label": "is_platform_windows", "shape": "dot", "size": 20, "title": "NAME: is_platform_windows\n------------------------------\nINPUTS: \nOUTPUTS: bool\n------------------------------\nDESCRIPTION: Checking if the running platform is windows. Returns ------- bool True if the running platform is windows....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.compat.numpy", "label": "numpy", "shape": "dot", "size": 20, "title": "NAME: numpy\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: support numpy compatibility across versions...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.compat.os", "label": "os", "shape": "dot", "size": 20, "title": "NAME: os\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: OS routines for NT or Posix depending on what system we\u0027re on. This exports: - all functions from posix or nt, e.g. unlink, stat, etc. - os.path is either posixpath or ntpath - os.name is either \u0027posix\u0027 or \u0027nt\u0027 -...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.compat.pandas", "label": "pandas", "shape": "dot", "size": 20, "title": "NAME: pandas\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: pandas - a powerful data analysis and manipulation library for Python ===================================================================== **pandas** is a Python package providing fast, flexible, and expressive data structures designed to make working with \"relational\" or \"labeled\" data both easy and intuitive. It aims to...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.compat.pickle_compat", "label": "pickle_compat", "shape": "dot", "size": 20, "title": "NAME: pickle_compat\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Support pre-0.12 series pickle compatibility....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.compat.platform", "label": "platform", "shape": "dot", "size": 20, "title": "NAME: platform\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: This module tries to retrieve as much platform-identifying data as possible. It makes this information available via function APIs. If called from the command line, it prints the platform information concatenated as single string to stdout. The output format is...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.compat.pyarrow", "label": "pyarrow", "shape": "dot", "size": 20, "title": "NAME: pyarrow\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: support pyarrow compatibility across versions...\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.compat.set_function_name", "label": "set_function_name", "shape": "dot", "size": 20, "title": "NAME: set_function_name\n------------------------------\nINPUTS: f, name, cls\nOUTPUTS: F\n------------------------------\nDESCRIPTION: Bind the name/qualname attributes of the function....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.compat.sys", "label": "sys", "shape": "dot", "size": 20, "title": "NAME: sys\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: This module provides access to some objects used or maintained by the interpreter and to functions that interact strongly with the interpreter. Dynamic objects: argv -- command line arguments; argv[0] is the script pathname if known path -- module search...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.accessor", "label": "accessor", "shape": "dot", "size": 20, "title": "NAME: accessor\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: accessor.py contains base classes for implementing accessor properties that can be mixed into or pinned onto other pandas classes....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.algorithms", "label": "algorithms", "shape": "dot", "size": 20, "title": "NAME: algorithms\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Generic data algorithms. This module is experimental at the moment and not intended for public consumption...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.api", "label": "api", "shape": "dot", "size": 20, "title": "NAME: api\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.apply", "label": "apply", "shape": "dot", "size": 20, "title": "NAME: apply\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.array_algos", "label": "array_algos", "shape": "dot", "size": 20, "title": "NAME: array_algos\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: core.array_algos is for algorithms that operate on ndarray and ExtensionArray. These should: - Assume that any Index, Series, or DataFrame objects have already been unwrapped. - Assume that any list arguments have already been cast to ndarray/EA. - Not depend...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.arraylike", "label": "arraylike", "shape": "dot", "size": 20, "title": "NAME: arraylike\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Methods that can be shared by many array-like classes or subclasses: Series Index ExtensionArray...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.arrays", "label": "arrays", "shape": "dot", "size": 20, "title": "NAME: arrays\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.base", "label": "base", "shape": "dot", "size": 20, "title": "NAME: base\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Base and utility classes for pandas objects....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.common", "label": "common", "shape": "dot", "size": 20, "title": "NAME: common\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Misc tools for implementing data structures Note: pandas.core.common is *not* part of the public API....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.computation", "label": "computation", "shape": "dot", "size": 20, "title": "NAME: computation\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.config_init", "label": "config_init", "shape": "dot", "size": 20, "title": "NAME: config_init\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: This module is imported from the pandas package __init__.py file in order to ensure that the core.config options registered here will be available as soon as the user loads the package. if register_option is invoked inside specific modules, they will...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.construction", "label": "construction", "shape": "dot", "size": 20, "title": "NAME: construction\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Constructor functions intended to be shared by pd.array, Series.__init__, and Index.__new__. These should not depend on core.internals....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.dtypes", "label": "dtypes", "shape": "dot", "size": 20, "title": "NAME: dtypes\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.flags", "label": "flags", "shape": "dot", "size": 20, "title": "NAME: flags\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.frame", "label": "frame", "shape": "dot", "size": 20, "title": "NAME: frame\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DataFrame --------- An efficient 2D container for potentially mixed-type time series or other labeled data series. Similar to its R counterpart, data.frame, except providing automatic data alignment and a host of useful data manipulation methods having to do with the...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.generic", "label": "generic", "shape": "dot", "size": 20, "title": "NAME: generic\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.groupby", "label": "groupby", "shape": "dot", "size": 20, "title": "NAME: groupby\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.indexers", "label": "indexers", "shape": "dot", "size": 20, "title": "NAME: indexers\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.indexes", "label": "indexes", "shape": "dot", "size": 20, "title": "NAME: indexes\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.indexing", "label": "indexing", "shape": "dot", "size": 20, "title": "NAME: indexing\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.interchange", "label": "interchange", "shape": "dot", "size": 20, "title": "NAME: interchange\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.internals", "label": "internals", "shape": "dot", "size": 20, "title": "NAME: internals\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.methods", "label": "methods", "shape": "dot", "size": 20, "title": "NAME: methods\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.missing", "label": "missing", "shape": "dot", "size": 20, "title": "NAME: missing\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Routines for filling missing data....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.nanops", "label": "nanops", "shape": "dot", "size": 20, "title": "NAME: nanops\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.ops", "label": "ops", "shape": "dot", "size": 20, "title": "NAME: ops\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Arithmetic operations for PandasObjects This is not a public API....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.resample", "label": "resample", "shape": "dot", "size": 20, "title": "NAME: resample\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.reshape", "label": "reshape", "shape": "dot", "size": 20, "title": "NAME: reshape\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.roperator", "label": "roperator", "shape": "dot", "size": 20, "title": "NAME: roperator\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Reversed Operations not available in the stdlib operator module. Defining these instead of using lambdas allows us to reference them by name....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.sample", "label": "sample", "shape": "dot", "size": 20, "title": "NAME: sample\n------------------------------\nINPUTS: \nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Module containing utilities for NDFrame.sample() and .GroupBy.sample()...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.series", "label": "series", "shape": "dot", "size": 20, "title": "NAME: series\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Data structure for 1-dimensional cross-sectional and time series data...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.shared_docs", "label": "shared_docs", "shape": "dot", "size": 20, "title": "NAME: shared_docs\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.sorting", "label": "sorting", "shape": "dot", "size": 20, "title": "NAME: sorting\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: miscellaneous sorting / groupby utilities...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.strings", "label": "strings", "shape": "dot", "size": 20, "title": "NAME: strings\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Implementation of pandas.Series.str and its interface. * strings.accessor.StringMethods : Accessor for Series.str * strings.base.BaseStringArrayMethods: Mixin ABC for EAs to implement str methods Most methods on the StringMethods accessor follow the pattern: 1. extract the array from the series (or index)...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.tools", "label": "tools", "shape": "dot", "size": 20, "title": "NAME: tools\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.util", "label": "util", "shape": "dot", "size": 20, "title": "NAME: util\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.core.window", "label": "window", "shape": "dot", "size": 20, "title": "NAME: window\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.AbstractMethodError", "label": "AbstractMethodError", "shape": "dot", "size": 20, "title": "NAME: AbstractMethodError\n------------------------------\nINPUTS: class_instance, methodtype\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Raise this error instead of NotImplementedError for abstract methods. Examples -------- \u003e\u003e\u003e class Foo: ... @classmethod ... def classmethod(cls): ... raise pd.errors.AbstractMethodError(cls, methodtype=\"classmethod\") ... def method(self): ... raise pd.errors.AbstractMethodError(self) \u003e\u003e\u003e test = Foo.classmethod() Traceback (most recent call last): AbstractMethodError: This...\n\n\nEXAMPLE:\n\u003e\u003e\u003e class Foo:\n...     @classmethod\n...     def classmethod(cls):\n...         raise pd.errors.AbstractMethodError(cls, methodtype=\"classmethod\")\n...     def method(self):\n...         raise pd.errors.AbstractMethodError(self)\n\u003e\u003e\u003e test = Foo.classmethod()\nTraceback (most recent call last):\nAbstractMethodError: This classmethod must be defined in the concrete class Foo"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.AttributeConflictWarning", "label": "AttributeConflictWarning", "shape": "dot", "size": 20, "title": "NAME: AttributeConflictWarning\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Warning raised when index attributes conflict when using HDFStore. Occurs when attempting to append an index with a different name than the existing index on an HDFStore or attempting to append an index with a different frequency than the existing...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx1 = pd.Index([\u0027a\u0027, \u0027b\u0027], name=\u0027name1\u0027)\n\u003e\u003e\u003e df1 = pd.DataFrame([[1, 2], [3, 4]], index=idx1)\n\u003e\u003e\u003e df1.to_hdf(\u0027file\u0027, \u0027data\u0027, \u0027w\u0027, append=True)  # doctest: +SKIP\n\u003e\u003e\u003e idx2 = pd.Index([\u0027c\u0027, \u0027d\u0027], name=\u0027name2\u0027)\n\u003e\u003e\u003e df2 = pd.DataFrame([[5, 6], [7, 8]], index=idx2)\n\u003e\u003e\u003e df2.to_hdf(\u0027file\u0027, \u0027data\u0027, \u0027a\u0027, append=True)  # doctest: +SKIP\nAttributeConflictWarning: the [index_name] attribute of the existing index is\n[name1] which conflicts with the new [name2]..."}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.CSSWarning", "label": "CSSWarning", "shape": "dot", "size": 20, "title": "NAME: CSSWarning\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Warning is raised when converting css styling fails. This can be due to the styling not having an equivalent value or because the styling isn\u0027t properly formatted. Examples -------- \u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [1, 1, 1]}) \u003e\u003e\u003e df.style.applymap( ... lambda...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [1, 1, 1]})\n\u003e\u003e\u003e df.style.applymap(\n...     lambda x: \u0027background-color: blueGreenRed;\u0027\n... ).to_excel(\u0027styled.xlsx\u0027)  # doctest: +SKIP\nCSSWarning: Unhandled color format: \u0027blueGreenRed\u0027\n\u003e\u003e\u003e df.style.applymap(\n...     lambda x: \u0027border: 1px solid red red;\u0027\n... ).to_excel(\u0027styled.xlsx\u0027)  # doctest: +SKIP\nCSSWarning: Unhandled color format: \u0027blueGreenRed\u0027"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.CategoricalConversionWarning", "label": "CategoricalConversionWarning", "shape": "dot", "size": 20, "title": "NAME: CategoricalConversionWarning\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Warning is raised when reading a partial labeled Stata file using a iterator. Examples -------- \u003e\u003e\u003e from pandas.io.stata import StataReader \u003e\u003e\u003e with StataReader(\u0027dta_file\u0027, chunksize=2) as reader: # doctest: +SKIP ... for i, block in enumerate(reader): ... print(i, block) ... #...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas.io.stata import StataReader\n\u003e\u003e\u003e with StataReader(\u0027dta_file\u0027, chunksize=2) as reader: # doctest: +SKIP\n...   for i, block in enumerate(reader):\n...      print(i, block)\n... # CategoricalConversionWarning: One or more series with value labels..."}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.ChainedAssignmentError", "label": "ChainedAssignmentError", "shape": "dot", "size": 20, "title": "NAME: ChainedAssignmentError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Warning raised when trying to set using chained assignment. When the ``mode.copy_on_write`` option is enabled, chained assignment can never work. In such a situation, we are always setting into a temporary object that is the result of an indexing operation...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.options.mode.copy_on_write = True\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [1, 1, 1, 2, 2]}, columns=[\u0027A\u0027])\n\u003e\u003e\u003e df[\"A\"][0:3] = 10 # doctest: +SKIP\n... # ChainedAssignmentError: ...\n\u003e\u003e\u003e pd.options.mode.copy_on_write = False"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.ClosedFileError", "label": "ClosedFileError", "shape": "dot", "size": 20, "title": "NAME: ClosedFileError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exception is raised when trying to perform an operation on a closed HDFStore file. Examples -------- \u003e\u003e\u003e store = pd.HDFStore(\u0027my-store\u0027, \u0027a\u0027) # doctest: +SKIP \u003e\u003e\u003e store.close() # doctest: +SKIP \u003e\u003e\u003e store.keys() # doctest: +SKIP ... # ClosedFileError: my-store file is...\n\n\nEXAMPLE:\n\u003e\u003e\u003e store = pd.HDFStore(\u0027my-store\u0027, \u0027a\u0027) # doctest: +SKIP\n\u003e\u003e\u003e store.close() # doctest: +SKIP\n\u003e\u003e\u003e store.keys() # doctest: +SKIP\n... # ClosedFileError: my-store file is not open!"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.DataError", "label": "DataError", "shape": "dot", "size": 20, "title": "NAME: DataError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exceptionn raised when performing an operation on non-numerical data. For example, calling ``ohlc`` on a non-numerical column or a function on a rolling window. Examples -------- \u003e\u003e\u003e ser = pd.Series([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]) \u003e\u003e\u003e ser.rolling(2).sum() Traceback (most recent call last): DataError:...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([\u0027a\u0027, \u0027b\u0027, \u0027c\u0027])\n\u003e\u003e\u003e ser.rolling(2).sum()\nTraceback (most recent call last):\nDataError: No numeric types to aggregate"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.DatabaseError", "label": "DatabaseError", "shape": "dot", "size": 20, "title": "NAME: DatabaseError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Error is raised when executing sql with bad syntax or sql that throws an error. Examples -------- \u003e\u003e\u003e from sqlite3 import connect \u003e\u003e\u003e conn = connect(\u0027:memory:\u0027) \u003e\u003e\u003e pd.read_sql(\u0027select * test\u0027, conn) # doctest: +SKIP ... # DatabaseError: Execution failed on...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from sqlite3 import connect\n\u003e\u003e\u003e conn = connect(\u0027:memory:\u0027)\n\u003e\u003e\u003e pd.read_sql(\u0027select * test\u0027, conn) # doctest: +SKIP\n... # DatabaseError: Execution failed on sql \u0027test\u0027: near \"test\": syntax error"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.DtypeWarning", "label": "DtypeWarning", "shape": "dot", "size": 20, "title": "NAME: DtypeWarning\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Warning raised when reading different dtypes in a column from a file. Raised for a dtype incompatibility. This can happen whenever `read_csv` or `read_table` encounter non-uniform dtypes in a column(s) of a given CSV file. See Also -------- read_csv :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027a\u0027: ([\u00271\u0027] * 100000 + [\u0027X\u0027] * 100000 +\n...                          [\u00271\u0027] * 100000),\n...                    \u0027b\u0027: [\u0027b\u0027] * 300000})  # doctest: +SKIP\n\u003e\u003e\u003e df.to_csv(\u0027test.csv\u0027, index=False)  # doctest: +SKIP\n\u003e\u003e\u003e df2 = pd.read_csv(\u0027test.csv\u0027)  # doctest: +SKIP\n... # DtypeWarning: Columns (0) have mixed types"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.DuplicateLabelError", "label": "DuplicateLabelError", "shape": "dot", "size": 20, "title": "NAME: DuplicateLabelError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Error raised when an operation would introduce duplicate labels. Examples -------- \u003e\u003e\u003e s = pd.Series([0, 1, 2], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]).set_flags( ... allows_duplicate_labels=False ... ) \u003e\u003e\u003e s.reindex([\u0027a\u0027, \u0027a\u0027, \u0027b\u0027]) Traceback (most recent call last): ... DuplicateLabelError: Index has duplicates. positions label...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series([0, 1, 2], index=[\u0027a\u0027, \u0027b\u0027, \u0027c\u0027]).set_flags(\n...     allows_duplicate_labels=False\n... )\n\u003e\u003e\u003e s.reindex([\u0027a\u0027, \u0027a\u0027, \u0027b\u0027])\nTraceback (most recent call last):\n   ...\nDuplicateLabelError: Index has duplicates.\n      positions\nlabel\na        [0, 1]"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.EmptyDataError", "label": "EmptyDataError", "shape": "dot", "size": 20, "title": "NAME: EmptyDataError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exception raised in ``pd.read_csv`` when empty data or header is encountered. Examples -------- \u003e\u003e\u003e from io import StringIO \u003e\u003e\u003e empty = StringIO() \u003e\u003e\u003e pd.read_csv(empty) Traceback (most recent call last): EmptyDataError: No columns to parse from file...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from io import StringIO\n\u003e\u003e\u003e empty = StringIO()\n\u003e\u003e\u003e pd.read_csv(empty)\nTraceback (most recent call last):\nEmptyDataError: No columns to parse from file"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.IncompatibilityWarning", "label": "IncompatibilityWarning", "shape": "dot", "size": 20, "title": "NAME: IncompatibilityWarning\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Warning raised when trying to use where criteria on an incompatible HDF5 file....\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.IndexingError", "label": "IndexingError", "shape": "dot", "size": 20, "title": "NAME: IndexingError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exception is raised when trying to index and there is a mismatch in dimensions. Examples -------- \u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [1, 1, 1]}) \u003e\u003e\u003e df.loc[..., ..., \u0027A\u0027] # doctest: +SKIP ... # IndexingError: indexer may only contain one \u0027...\u0027 entry...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [1, 1, 1]})\n\u003e\u003e\u003e df.loc[..., ..., \u0027A\u0027] # doctest: +SKIP\n... # IndexingError: indexer may only contain one \u0027...\u0027 entry\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [1, 1, 1]})\n\u003e\u003e\u003e df.loc[1, ..., ...] # doctest: +SKIP\n... # IndexingError: Too many indexers\n\u003e\u003e\u003e df[pd.Series([True], dtype=bool)] # doctest: +SKIP\n... # IndexingError: Unalignable boolean Series provided as indexer...\n\u003e\u003e\u003e s = pd.Series(range(2),\n...               index = pd.MultiIndex.from_product([[\"a\", \"b\"], [\"c\"]]))\n\u003e\u003e\u003e s.loc[\"a\", \"c\", \"d\"] # doctest: +SKIP\n... # IndexingError: Too many indexers"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.IntCastingNaNError", "label": "IntCastingNaNError", "shape": "dot", "size": 20, "title": "NAME: IntCastingNaNError\n------------------------------\nINPUTS: ``astype``\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exception raised when converting (``astype``) an array with NaN to an integer type. Examples -------- \u003e\u003e\u003e pd.DataFrame(np.array([[1, np.nan], [2, 3]]), dtype=\"i8\") Traceback (most recent call last): IntCastingNaNError: Cannot convert non-finite values (NA or inf) to integer...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.DataFrame(np.array([[1, np.nan], [2, 3]]), dtype=\"i8\")\nTraceback (most recent call last):\nIntCastingNaNError: Cannot convert non-finite values (NA or inf) to integer"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.InvalidColumnName", "label": "InvalidColumnName", "shape": "dot", "size": 20, "title": "NAME: InvalidColumnName\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Warning raised by to_stata the column contains a non-valid stata name. Because the column name is an invalid Stata variable, the name needs to be converted. Examples -------- \u003e\u003e\u003e df = pd.DataFrame({\"0categories\": pd.Series([2, 2])}) \u003e\u003e\u003e df.to_stata(\u0027test\u0027) # doctest: +SKIP ......\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"0categories\": pd.Series([2, 2])})\n\u003e\u003e\u003e df.to_stata(\u0027test\u0027) # doctest: +SKIP\n... # InvalidColumnName: Not all pandas column names were valid Stata variable..."}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.InvalidComparison", "label": "InvalidComparison", "shape": "dot", "size": 20, "title": "NAME: InvalidComparison\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exception is raised by _validate_comparison_value to indicate an invalid comparison. Notes ----- This is an internal error....\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.InvalidIndexError", "label": "InvalidIndexError", "shape": "dot", "size": 20, "title": "NAME: InvalidIndexError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exception raised when attempting to use an invalid index key. Examples -------- \u003e\u003e\u003e idx = pd.MultiIndex.from_product([[\"x\", \"y\"], [0, 1]]) \u003e\u003e\u003e df = pd.DataFrame([[1, 1, 2, 2], ... [3, 3, 4, 4]], columns=idx) \u003e\u003e\u003e df x y 0 1 0 1...\n\n\nEXAMPLE:\n\u003e\u003e\u003e idx = pd.MultiIndex.from_product([[\"x\", \"y\"], [0, 1]])\n\u003e\u003e\u003e df = pd.DataFrame([[1, 1, 2, 2],\n...                   [3, 3, 4, 4]], columns=idx)\n\u003e\u003e\u003e df\n    x       y\n    0   1   0   1\n0   1   1   2   2\n1   3   3   4   4\n\u003e\u003e\u003e df[:, 0]\nTraceback (most recent call last):\nInvalidIndexError: (slice(None, None, None), 0)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.InvalidVersion", "label": "InvalidVersion", "shape": "dot", "size": 20, "title": "NAME: InvalidVersion\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: An invalid version was found, users should refer to PEP 440. Examples -------- \u003e\u003e\u003e pd.util.version.Version(\u00271.\u0027) Traceback (most recent call last): InvalidVersion: Invalid version: \u00271.\u0027...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.util.version.Version(\u00271.\u0027)\nTraceback (most recent call last):\nInvalidVersion: Invalid version: \u00271.\u0027"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.LossySetitemError", "label": "LossySetitemError", "shape": "dot", "size": 20, "title": "NAME: LossySetitemError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Raised when trying to do a __setitem__ on an np.ndarray that is not lossless. Notes ----- This is an internal error....\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.MergeError", "label": "MergeError", "shape": "dot", "size": 20, "title": "NAME: MergeError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exception raised when merging data. Subclass of ``ValueError``. Examples -------- \u003e\u003e\u003e left = pd.DataFrame({\"a\": [\"a\", \"b\", \"b\", \"d\"], ... \"b\": [\"cat\", \"dog\", \"weasel\", \"horse\"]}, ... index=range(4)) \u003e\u003e\u003e right = pd.DataFrame({\"a\": [\"a\", \"b\", \"c\", \"d\"], ... \"c\": [\"meow\", \"bark\", \"chirp\", \"nay\"]},...\n\n\nEXAMPLE:\n\u003e\u003e\u003e left = pd.DataFrame({\"a\": [\"a\", \"b\", \"b\", \"d\"],\n...                     \"b\": [\"cat\", \"dog\", \"weasel\", \"horse\"]},\n...                     index=range(4))\n\u003e\u003e\u003e right = pd.DataFrame({\"a\": [\"a\", \"b\", \"c\", \"d\"],\n...                      \"c\": [\"meow\", \"bark\", \"chirp\", \"nay\"]},\n...                      index=range(4)).set_index(\"a\")\n\u003e\u003e\u003e left.join(right, on=\"a\", validate=\"one_to_one\",)\nTraceback (most recent call last):\nMergeError: Merge keys are not unique in left dataset; not a one-to-one merge"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.NoBufferPresent", "label": "NoBufferPresent", "shape": "dot", "size": 20, "title": "NAME: NoBufferPresent\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exception is raised in _get_data_buffer to signal that there is no requested buffer....\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.NullFrequencyError", "label": "NullFrequencyError", "shape": "dot", "size": 20, "title": "NAME: NullFrequencyError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exception raised when a ``freq`` cannot be null. Particularly ``DatetimeIndex.shift``, ``TimedeltaIndex.shift``, ``PeriodIndex.shift``. Examples -------- \u003e\u003e\u003e df = pd.DatetimeIndex([\"2011-01-01 10:00\", \"2011-01-01\"], freq=None) \u003e\u003e\u003e df.shift(2) Traceback (most recent call last): NullFrequencyError: Cannot shift with no freq...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DatetimeIndex([\"2011-01-01 10:00\", \"2011-01-01\"], freq=None)\n\u003e\u003e\u003e df.shift(2)\nTraceback (most recent call last):\nNullFrequencyError: Cannot shift with no freq"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.NumExprClobberingError", "label": "NumExprClobberingError", "shape": "dot", "size": 20, "title": "NAME: NumExprClobberingError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exception raised when trying to use a built-in numexpr name as a variable name. ``eval`` or ``query`` will throw the error if the engine is set to \u0027numexpr\u0027. \u0027numexpr\u0027 is the default engine value for these methods if the numexpr...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027abs\u0027: [1, 1, 1]})\n\u003e\u003e\u003e df.query(\"abs \u003e 2\") # doctest: +SKIP\n... # NumExprClobberingError: Variables in expression \"(abs) \u003e (2)\" overlap...\n\u003e\u003e\u003e sin, a = 1, 2\n\u003e\u003e\u003e pd.eval(\"sin + a\", engine=\u0027numexpr\u0027) # doctest: +SKIP\n... # NumExprClobberingError: Variables in expression \"(sin) + (a)\" overlap..."}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.NumbaUtilError", "label": "NumbaUtilError", "shape": "dot", "size": 20, "title": "NAME: NumbaUtilError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Error raised for unsupported Numba engine routines. Examples -------- \u003e\u003e\u003e df = pd.DataFrame({\"key\": [\"a\", \"a\", \"b\", \"b\"], \"data\": [1, 2, 3, 4]}, ... columns=[\"key\", \"data\"]) \u003e\u003e\u003e def incorrect_function(x): ... return sum(x) * 2.7 \u003e\u003e\u003e df.groupby(\"key\").agg(incorrect_function, engine=\"numba\") Traceback (most recent call...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"key\": [\"a\", \"a\", \"b\", \"b\"], \"data\": [1, 2, 3, 4]},\n...                   columns=[\"key\", \"data\"])\n\u003e\u003e\u003e def incorrect_function(x):\n...     return sum(x) * 2.7\n\u003e\u003e\u003e df.groupby(\"key\").agg(incorrect_function, engine=\"numba\")\nTraceback (most recent call last):\nNumbaUtilError: The first 2 arguments to incorrect_function\nmust be [\u0027values\u0027, \u0027index\u0027]"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.OptionError", "label": "OptionError", "shape": "dot", "size": 20, "title": "NAME: OptionError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exception raised for pandas.options. Backwards compatible with KeyError checks. Examples -------- \u003e\u003e\u003e pd.options.context Traceback (most recent call last): OptionError: No such option...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.options.context\nTraceback (most recent call last):\nOptionError: No such option"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.OutOfBoundsDatetime", "label": "OutOfBoundsDatetime", "shape": "dot", "size": 20, "title": "NAME: OutOfBoundsDatetime\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Raised when the datetime is outside the range that can be represented. Examples -------- \u003e\u003e\u003e pd.to_datetime(\"08335394550\") Traceback (most recent call last): OutOfBoundsDatetime: Parsing \"08335394550\" to datetime overflows, at position 0...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.to_datetime(\"08335394550\")\nTraceback (most recent call last):\nOutOfBoundsDatetime: Parsing \"08335394550\" to datetime overflows,\nat position 0"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.OutOfBoundsTimedelta", "label": "OutOfBoundsTimedelta", "shape": "dot", "size": 20, "title": "NAME: OutOfBoundsTimedelta\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Raised when encountering a timedelta value that cannot be represented. Representation should be within a timedelta64[ns]. Examples -------- \u003e\u003e\u003e pd.date_range(start=\"1/1/1700\", freq=\"B\", periods=100000) Traceback (most recent call last): OutOfBoundsTimedelta: Cannot cast 139999 days 00:00:00 to unit=\u0027ns\u0027 without overflow....\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.date_range(start=\"1/1/1700\", freq=\"B\", periods=100000)\nTraceback (most recent call last):\nOutOfBoundsTimedelta: Cannot cast 139999 days 00:00:00\nto unit=\u0027ns\u0027 without overflow."}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.ParserError", "label": "ParserError", "shape": "dot", "size": 20, "title": "NAME: ParserError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exception that is raised by an error encountered in parsing file contents. This is a generic error raised for errors encountered when functions like `read_csv` or `read_html` are parsing contents of a file. See Also -------- read_csv : Read CSV...\n\n\nEXAMPLE:\n\u003e\u003e\u003e data = \u0027\u0027\u0027a,b,c\n... cat,foo,bar\n... dog,foo,\"baz\u0027\u0027\u0027\n\u003e\u003e\u003e from io import StringIO\n\u003e\u003e\u003e pd.read_csv(StringIO(data), skipfooter=1, engine=\u0027python\u0027)\nTraceback (most recent call last):\nParserError: \u0027,\u0027 expected after \u0027\"\u0027. Error could possibly be due\nto parsing errors in the skipped footer rows"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.ParserWarning", "label": "ParserWarning", "shape": "dot", "size": 20, "title": "NAME: ParserWarning\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Warning raised when reading a file that doesn\u0027t use the default \u0027c\u0027 parser. Raised by `pd.read_csv` and `pd.read_table` when it is necessary to change parsers, generally from the default \u0027c\u0027 parser to \u0027python\u0027. It happens due to a lack of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import io\n\u003e\u003e\u003e csv = \u0027\u0027\u0027a;b;c\n...           1;1,8\n...           1;2,1\u0027\u0027\u0027\n\u003e\u003e\u003e df = pd.read_csv(io.StringIO(csv), sep=\u0027[;,]\u0027)  # doctest: +SKIP\n... # ParserWarning: Falling back to the \u0027python\u0027 engine..."}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.PerformanceWarning", "label": "PerformanceWarning", "shape": "dot", "size": 20, "title": "NAME: PerformanceWarning\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Warning raised when there is a possible performance impact. Examples -------- \u003e\u003e\u003e df = pd.DataFrame({\"jim\": [0, 0, 1, 1], ... \"joe\": [\"x\", \"x\", \"z\", \"y\"], ... \"jolie\": [1, 2, 3, 4]}) \u003e\u003e\u003e df = df.set_index([\"jim\", \"joe\"]) \u003e\u003e\u003e df jolie jim...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"jim\": [0, 0, 1, 1],\n...                    \"joe\": [\"x\", \"x\", \"z\", \"y\"],\n...                    \"jolie\": [1, 2, 3, 4]})\n\u003e\u003e\u003e df = df.set_index([\"jim\", \"joe\"])\n\u003e\u003e\u003e df\n          jolie\njim  joe\n0    x    1\n     x    2\n1    z    3\n     y    4\n\u003e\u003e\u003e df.loc[(1, \u0027z\u0027)]  # doctest: +SKIP\n# PerformanceWarning: indexing past lexsort depth may impact performance.\ndf.loc[(1, \u0027z\u0027)]\n          jolie\njim  joe\n1    z        3"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.PossibleDataLossError", "label": "PossibleDataLossError", "shape": "dot", "size": 20, "title": "NAME: PossibleDataLossError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exception raised when trying to open a HDFStore file when already opened. Examples -------- \u003e\u003e\u003e store = pd.HDFStore(\u0027my-store\u0027, \u0027a\u0027) # doctest: +SKIP \u003e\u003e\u003e store.open(\"w\") # doctest: +SKIP ... # PossibleDataLossError: Re-opening the file [my-store] with mode [a]......\n\n\nEXAMPLE:\n\u003e\u003e\u003e store = pd.HDFStore(\u0027my-store\u0027, \u0027a\u0027) # doctest: +SKIP\n\u003e\u003e\u003e store.open(\"w\") # doctest: +SKIP\n... # PossibleDataLossError: Re-opening the file [my-store] with mode [a]..."}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.PossiblePrecisionLoss", "label": "PossiblePrecisionLoss", "shape": "dot", "size": 20, "title": "NAME: PossiblePrecisionLoss\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Warning raised by to_stata on a column with a value outside or equal to int64. When the column value is outside or equal to the int64 value the column is converted to a float64 dtype. Examples -------- \u003e\u003e\u003e df =...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"s\": pd.Series([1, 2**53], dtype=np.int64)})\n\u003e\u003e\u003e df.to_stata(\u0027test\u0027) # doctest: +SKIP\n... # PossiblePrecisionLoss: Column converted from int64 to float64..."}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.PyperclipException", "label": "PyperclipException", "shape": "dot", "size": 20, "title": "NAME: PyperclipException\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exception raised when clipboard functionality is unsupported. Raised by ``to_clipboard()`` and ``read_clipboard()``....\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.PyperclipWindowsException", "label": "PyperclipWindowsException", "shape": "dot", "size": 20, "title": "NAME: PyperclipWindowsException\n------------------------------\nINPUTS: message\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Exception raised when clipboard functionality is unsupported by Windows. Access to the clipboard handle would be denied due to some other window process is accessing it....\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.SettingWithCopyError", "label": "SettingWithCopyError", "shape": "dot", "size": 20, "title": "NAME: SettingWithCopyError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exception raised when trying to set on a copied slice from a ``DataFrame``. The ``mode.chained_assignment`` needs to be set to set to \u0027raise.\u0027 This can happen unintentionally when chained indexing. For more information on evaluation order, see :ref:`the user guide\u003cindexing.evaluation_order\u003e`....\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.options.mode.chained_assignment = \u0027raise\u0027\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [1, 1, 1, 2, 2]}, columns=[\u0027A\u0027])\n\u003e\u003e\u003e df.loc[0:3][\u0027A\u0027] = \u0027a\u0027 # doctest: +SKIP\n... # SettingWithCopyError: A value is trying to be set on a copy of a..."}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.SettingWithCopyWarning", "label": "SettingWithCopyWarning", "shape": "dot", "size": 20, "title": "NAME: SettingWithCopyWarning\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Warning raised when trying to set on a copied slice from a ``DataFrame``. The ``mode.chained_assignment`` needs to be set to set to \u0027warn.\u0027 \u0027Warn\u0027 is the default option. This can happen unintentionally when chained indexing. For more information on evaluation...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [1, 1, 1, 2, 2]}, columns=[\u0027A\u0027])\n\u003e\u003e\u003e df.loc[0:3][\u0027A\u0027] = \u0027a\u0027 # doctest: +SKIP\n... # SettingWithCopyWarning: A value is trying to be set on a copy of a..."}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.SpecificationError", "label": "SpecificationError", "shape": "dot", "size": 20, "title": "NAME: SpecificationError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exception raised by ``agg`` when the functions are ill-specified. The exception raised in two scenarios. The first way is calling ``agg`` on a Dataframe or Series using a nested renamer (dict-of-dict). The second way is calling ``agg`` on a Dataframe...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [1, 1, 1, 2, 2],\n...                    \u0027B\u0027: range(5),\n...                    \u0027C\u0027: range(5)})\n\u003e\u003e\u003e df.groupby(\u0027A\u0027).B.agg({\u0027foo\u0027: \u0027count\u0027}) # doctest: +SKIP\n... # SpecificationError: nested renamer is not supported"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.UndefinedVariableError", "label": "UndefinedVariableError", "shape": "dot", "size": 20, "title": "NAME: UndefinedVariableError\n------------------------------\nINPUTS: name, is_local\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Exception raised by ``query`` or ``eval`` when using an undefined variable name. It will also specify whether the undefined variable is local or not. Examples -------- \u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [1, 1, 1]}) \u003e\u003e\u003e df.query(\"A \u003e x\") # doctest: +SKIP...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [1, 1, 1]})\n\u003e\u003e\u003e df.query(\"A \u003e x\") # doctest: +SKIP\n... # UndefinedVariableError: name \u0027x\u0027 is not defined\n\u003e\u003e\u003e df.query(\"A \u003e @y\") # doctest: +SKIP\n... # UndefinedVariableError: local variable \u0027y\u0027 is not defined\n\u003e\u003e\u003e pd.eval(\u0027x + 1\u0027) # doctest: +SKIP\n... # UndefinedVariableError: name \u0027x\u0027 is not defined"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.UnsortedIndexError", "label": "UnsortedIndexError", "shape": "dot", "size": 20, "title": "NAME: UnsortedIndexError\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Error raised when slicing a MultiIndex which has not been lexsorted. Subclass of `KeyError`. Examples -------- \u003e\u003e\u003e df = pd.DataFrame({\"cat\": [0, 0, 1, 1], ... \"color\": [\"white\", \"white\", \"brown\", \"black\"], ... \"lives\": [4, 4, 3, 7]}, ... ) \u003e\u003e\u003e df...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"cat\": [0, 0, 1, 1],\n...                    \"color\": [\"white\", \"white\", \"brown\", \"black\"],\n...                    \"lives\": [4, 4, 3, 7]},\n...                   )\n\u003e\u003e\u003e df = df.set_index([\"cat\", \"color\"])\n\u003e\u003e\u003e df\n            lives\ncat  color\n0    white    4\n     white    4\n1    brown    3\n     black    7\n\u003e\u003e\u003e df.loc[(0, \"black\"):(1, \"white\")]\nTraceback (most recent call last):\nUnsortedIndexError: \u0027Key length (2) was greater\nthan MultiIndex lexsort depth (1)\u0027"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.UnsupportedFunctionCall", "label": "UnsupportedFunctionCall", "shape": "dot", "size": 20, "title": "NAME: UnsupportedFunctionCall\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Exception raised when attempting to call a unsupported numpy function. For example, ``np.cumsum(groupby_object)``. Examples -------- \u003e\u003e\u003e df = pd.DataFrame({\"A\": [0, 0, 1, 1], ... \"B\": [\"x\", \"x\", \"z\", \"y\"], ... \"C\": [1, 2, 3, 4]} ... ) \u003e\u003e\u003e np.cumsum(df.groupby([\"A\"])) Traceback...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"A\": [0, 0, 1, 1],\n...                    \"B\": [\"x\", \"x\", \"z\", \"y\"],\n...                    \"C\": [1, 2, 3, 4]}\n...                   )\n\u003e\u003e\u003e np.cumsum(df.groupby([\"A\"]))\nTraceback (most recent call last):\nUnsupportedFunctionCall: numpy operations are not valid with groupby.\nUse .groupby(...).cumsum() instead"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.errors.ValueLabelTypeMismatch", "label": "ValueLabelTypeMismatch", "shape": "dot", "size": 20, "title": "NAME: ValueLabelTypeMismatch\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Warning raised by to_stata on a category column that contains non-string values. Examples -------- \u003e\u003e\u003e df = pd.DataFrame({\"categories\": pd.Series([\"a\", 2], dtype=\"category\")}) \u003e\u003e\u003e df.to_stata(\u0027test\u0027) # doctest: +SKIP ... # ValueLabelTypeMismatch: Stata value labels (pandas categories) must be str......\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame({\"categories\": pd.Series([\"a\", 2], dtype=\"category\")})\n\u003e\u003e\u003e df.to_stata(\u0027test\u0027) # doctest: +SKIP\n... # ValueLabelTypeMismatch: Stata value labels (pandas categories) must be str..."}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.errors.ctypes", "label": "ctypes", "shape": "dot", "size": 20, "title": "NAME: ctypes\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: create and manipulate C data types in Python...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.api", "label": "api", "shape": "dot", "size": 20, "title": "NAME: api\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Data IO api...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.clipboards", "label": "clipboards", "shape": "dot", "size": 20, "title": "NAME: clipboards\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: io on the clipboard...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.common", "label": "common", "shape": "dot", "size": 20, "title": "NAME: common\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Common IO api utilities...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.excel", "label": "excel", "shape": "dot", "size": 20, "title": "NAME: excel\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.feather_format", "label": "feather_format", "shape": "dot", "size": 20, "title": "NAME: feather_format\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: feather-format compat...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.formats", "label": "formats", "shape": "dot", "size": 20, "title": "NAME: formats\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.gbq", "label": "gbq", "shape": "dot", "size": 20, "title": "NAME: gbq\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Google BigQuery support...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.html", "label": "html", "shape": "dot", "size": 20, "title": "NAME: html\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: :mod:`pandas.io.html` is a module containing functionality for dealing with HTML IO....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.json", "label": "json", "shape": "dot", "size": 20, "title": "NAME: json\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.orc", "label": "orc", "shape": "dot", "size": 20, "title": "NAME: orc\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: orc compat...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.parquet", "label": "parquet", "shape": "dot", "size": 20, "title": "NAME: parquet\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: parquet compat...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.parsers", "label": "parsers", "shape": "dot", "size": 20, "title": "NAME: parsers\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.pickle", "label": "pickle", "shape": "dot", "size": 20, "title": "NAME: pickle\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: pickle compat...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.pytables", "label": "pytables", "shape": "dot", "size": 20, "title": "NAME: pytables\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: High level interface to PyTables for reading and writing pandas data structures to disk...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.sas", "label": "sas", "shape": "dot", "size": 20, "title": "NAME: sas\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.spss", "label": "spss", "shape": "dot", "size": 20, "title": "NAME: spss\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.sql", "label": "sql", "shape": "dot", "size": 20, "title": "NAME: sql\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Collection of query wrappers / abstractions to both facilitate data retrieval and to reduce dependency on DB-specific API....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.stata", "label": "stata", "shape": "dot", "size": 20, "title": "NAME: stata\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Module contains tools for processing Stata files into DataFrames The StataReader below was originally written by Joe Presbrey as part of PyDTA. It has been extended and improved by Skipper Seabold from the Statsmodels project who also developed the StataWriter...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.io.xml", "label": "xml", "shape": "dot", "size": 20, "title": "NAME: xml\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: :mod:``pandas.io.xml`` is a module for reading XML....\n"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.BDay", "label": "BDay", "shape": "dot", "size": 20, "title": "NAME: BDay\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset subclass representing possibly n business days. Parameters ---------- n : int, default 1 The number of days represented. normalize : bool, default False Normalize start/end dates to midnight. offset : timedelta, default timedelta(0) Time offset to apply. Examples --------...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 12, 9, 15)\n\u003e\u003e\u003e ts.strftime(\u0027%a %d %b %Y %H:%M\u0027)\n\u0027Fri 09 Dec 2022 15:00\u0027\n\u003e\u003e\u003e (ts + pd.offsets.BusinessDay(n=5)).strftime(\u0027%a %d %b %Y %H:%M\u0027)\n\u0027Fri 16 Dec 2022 15:00\u0027"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.BMonthBegin", "label": "BMonthBegin", "shape": "dot", "size": 20, "title": "NAME: BMonthBegin\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset of one month at the first business day. BusinessMonthBegin goes to the next date which is the first business day of the month. Parameters ---------- n : int, default 1 The number of months represented. normalize : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 11, 30)\n\u003e\u003e\u003e ts + pd.offsets.BMonthBegin()\nTimestamp(\u00272022-12-01 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.BMonthEnd", "label": "BMonthEnd", "shape": "dot", "size": 20, "title": "NAME: BMonthEnd\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset increments between the last business day of the month. BusinessMonthEnd goes to the next date which is the last business day of the month. Parameters ---------- n : int, default 1 The number of months represented. normalize : bool,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 11, 29)\n\u003e\u003e\u003e ts + pd.offsets.BMonthEnd()\nTimestamp(\u00272022-11-30 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.BQuarterBegin", "label": "BQuarterBegin", "shape": "dot", "size": 20, "title": "NAME: BQuarterBegin\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset increments between the first business day of each Quarter. startingMonth = 1 corresponds to dates like 1/01/2007, 4/01/2007, ... startingMonth = 2 corresponds to dates like 2/01/2007, 5/01/2007, ... startingMonth = 3 corresponds to dates like 3/01/2007, 6/01/2007, ......\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas.tseries.offsets import BQuarterBegin\n\u003e\u003e\u003e ts = pd.Timestamp(\u00272020-05-24 05:01:15\u0027)\n\u003e\u003e\u003e ts + BQuarterBegin()\nTimestamp(\u00272020-06-01 05:01:15\u0027)\n\u003e\u003e\u003e ts + BQuarterBegin(2)\nTimestamp(\u00272020-09-01 05:01:15\u0027)\n\u003e\u003e\u003e ts + BQuarterBegin(startingMonth=2)\nTimestamp(\u00272020-08-03 05:01:15\u0027)\n\u003e\u003e\u003e ts + BQuarterBegin(-1)\nTimestamp(\u00272020-03-02 05:01:15\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.BQuarterEnd", "label": "BQuarterEnd", "shape": "dot", "size": 20, "title": "NAME: BQuarterEnd\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset increments between the last business day of each Quarter. startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ... startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ... startingMonth = 3 corresponds to dates like 3/30/2007, 6/29/2007, ......\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas.tseries.offsets import BQuarterEnd\n\u003e\u003e\u003e ts = pd.Timestamp(\u00272020-05-24 05:01:15\u0027)\n\u003e\u003e\u003e ts + BQuarterEnd()\nTimestamp(\u00272020-06-30 05:01:15\u0027)\n\u003e\u003e\u003e ts + BQuarterEnd(2)\nTimestamp(\u00272020-09-30 05:01:15\u0027)\n\u003e\u003e\u003e ts + BQuarterEnd(1, startingMonth=2)\nTimestamp(\u00272020-05-29 05:01:15\u0027)\n\u003e\u003e\u003e ts + BQuarterEnd(startingMonth=2)\nTimestamp(\u00272020-05-29 05:01:15\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.BYearBegin", "label": "BYearBegin", "shape": "dot", "size": 20, "title": "NAME: BYearBegin\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset increments between the first business day of the year. Parameters ---------- n : int, default 1 The number of years represented. normalize : bool, default False Normalize start/end dates to midnight before generating date range. month : int, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas.tseries.offsets import BYearBegin\n\u003e\u003e\u003e ts = pd.Timestamp(\u00272020-05-24 05:01:15\u0027)\n\u003e\u003e\u003e ts + BYearBegin()\nTimestamp(\u00272021-01-01 05:01:15\u0027)\n\u003e\u003e\u003e ts - BYearBegin()\nTimestamp(\u00272020-01-01 05:01:15\u0027)\n\u003e\u003e\u003e ts + BYearBegin(-1)\nTimestamp(\u00272020-01-01 05:01:15\u0027)\n\u003e\u003e\u003e ts + BYearBegin(2)\nTimestamp(\u00272022-01-03 05:01:15\u0027)\n\u003e\u003e\u003e ts + BYearBegin(month=11)\nTimestamp(\u00272020-11-02 05:01:15\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.BYearEnd", "label": "BYearEnd", "shape": "dot", "size": 20, "title": "NAME: BYearEnd\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset increments between the last business day of the year. Parameters ---------- n : int, default 1 The number of years represented. normalize : bool, default False Normalize start/end dates to midnight before generating date range. month : int, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas.tseries.offsets import BYearEnd\n\u003e\u003e\u003e ts = pd.Timestamp(\u00272020-05-24 05:01:15\u0027)\n\u003e\u003e\u003e ts - BYearEnd()\nTimestamp(\u00272019-12-31 05:01:15\u0027)\n\u003e\u003e\u003e ts + BYearEnd()\nTimestamp(\u00272020-12-31 05:01:15\u0027)\n\u003e\u003e\u003e ts + BYearEnd(3)\nTimestamp(\u00272022-12-30 05:01:15\u0027)\n\u003e\u003e\u003e ts + BYearEnd(-3)\nTimestamp(\u00272017-12-29 05:01:15\u0027)\n\u003e\u003e\u003e ts + BYearEnd(month=11)\nTimestamp(\u00272020-11-30 05:01:15\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.BaseOffset", "label": "BaseOffset", "shape": "dot", "size": 20, "title": "NAME: BaseOffset\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Base class for DateOffset methods that are not overridden by subclasses. Parameters ---------- n : int Number of multiples of the frequency. normalize : bool Whether the frequency can align with midnight. Examples -------- \u003e\u003e\u003e pd.offsets.Hour(5).n 5 \u003e\u003e\u003e pd.offsets.Hour(5).normalize False...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.offsets.Hour(5).n\n5\n\u003e\u003e\u003e pd.offsets.Hour(5).normalize\nFalse"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.BusinessDay", "label": "BusinessDay", "shape": "dot", "size": 20, "title": "NAME: BusinessDay\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset subclass representing possibly n business days. Parameters ---------- n : int, default 1 The number of days represented. normalize : bool, default False Normalize start/end dates to midnight. offset : timedelta, default timedelta(0) Time offset to apply. Examples --------...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 12, 9, 15)\n\u003e\u003e\u003e ts.strftime(\u0027%a %d %b %Y %H:%M\u0027)\n\u0027Fri 09 Dec 2022 15:00\u0027\n\u003e\u003e\u003e (ts + pd.offsets.BusinessDay(n=5)).strftime(\u0027%a %d %b %Y %H:%M\u0027)\n\u0027Fri 16 Dec 2022 15:00\u0027"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.BusinessHour", "label": "BusinessHour", "shape": "dot", "size": 20, "title": "NAME: BusinessHour\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset subclass representing possibly n business hours. Parameters ---------- n : int, default 1 The number of hours represented. normalize : bool, default False Normalize start/end dates to midnight before generating date range. start : str, time, or list of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 12, 9, 8)\n\u003e\u003e\u003e ts + pd.offsets.BusinessHour(n=5)\nTimestamp(\u00272022-12-09 14:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.BusinessMonthBegin", "label": "BusinessMonthBegin", "shape": "dot", "size": 20, "title": "NAME: BusinessMonthBegin\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset of one month at the first business day. BusinessMonthBegin goes to the next date which is the first business day of the month. Parameters ---------- n : int, default 1 The number of months represented. normalize : bool, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 11, 30)\n\u003e\u003e\u003e ts + pd.offsets.BMonthBegin()\nTimestamp(\u00272022-12-01 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.BusinessMonthEnd", "label": "BusinessMonthEnd", "shape": "dot", "size": 20, "title": "NAME: BusinessMonthEnd\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset increments between the last business day of the month. BusinessMonthEnd goes to the next date which is the last business day of the month. Parameters ---------- n : int, default 1 The number of months represented. normalize : bool,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 11, 29)\n\u003e\u003e\u003e ts + pd.offsets.BMonthEnd()\nTimestamp(\u00272022-11-30 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.CBMonthBegin", "label": "CBMonthBegin", "shape": "dot", "size": 20, "title": "NAME: CBMonthBegin\n------------------------------\nINPUTS: s\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset subclass representing custom business month(s). Increments between beginning of month dates. Parameters ---------- n : int, default 1 The number of months represented. normalize : bool, default False Normalize start dates to midnight before generating date range. weekmask :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 8, 5)\n\u003e\u003e\u003e ts + pd.offsets.CustomBusinessMonthBegin()\nTimestamp(\u00272022-09-01 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.CBMonthEnd", "label": "CBMonthEnd", "shape": "dot", "size": 20, "title": "NAME: CBMonthEnd\n------------------------------\nINPUTS: s\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset subclass representing custom business month(s). Increments between end of month dates. Parameters ---------- n : int, default 1 The number of months represented. normalize : bool, default False Normalize end dates to midnight before generating date range. weekmask :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 8, 5)\n\u003e\u003e\u003e ts + pd.offsets.CustomBusinessMonthEnd()\nTimestamp(\u00272022-08-31 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.CDay", "label": "CDay", "shape": "dot", "size": 20, "title": "NAME: CDay\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset subclass representing possibly n custom business days. In CustomBusinessDay we can use custom weekmask, holidays, and calendar. Parameters ---------- n : int, default 1 The number of days represented. normalize : bool, default False Normalize start/end dates to midnight...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 8, 5, 16)\n\u003e\u003e\u003e ts + pd.offsets.CustomBusinessDay()\nTimestamp(\u00272022-08-08 16:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.CustomBusinessDay", "label": "CustomBusinessDay", "shape": "dot", "size": 20, "title": "NAME: CustomBusinessDay\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset subclass representing possibly n custom business days. In CustomBusinessDay we can use custom weekmask, holidays, and calendar. Parameters ---------- n : int, default 1 The number of days represented. normalize : bool, default False Normalize start/end dates to midnight...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 8, 5, 16)\n\u003e\u003e\u003e ts + pd.offsets.CustomBusinessDay()\nTimestamp(\u00272022-08-08 16:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.CustomBusinessHour", "label": "CustomBusinessHour", "shape": "dot", "size": 20, "title": "NAME: CustomBusinessHour\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset subclass representing possibly n custom business days. In CustomBusinessHour we can use custom weekmask, holidays, and calendar. Parameters ---------- n : int, default 1 The number of hours represented. normalize : bool, default False Normalize start/end dates to midnight...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 8, 5, 16)\n\u003e\u003e\u003e ts + pd.offsets.CustomBusinessHour()\nTimestamp(\u00272022-08-08 09:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.CustomBusinessMonthBegin", "label": "CustomBusinessMonthBegin", "shape": "dot", "size": 20, "title": "NAME: CustomBusinessMonthBegin\n------------------------------\nINPUTS: s\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset subclass representing custom business month(s). Increments between beginning of month dates. Parameters ---------- n : int, default 1 The number of months represented. normalize : bool, default False Normalize start dates to midnight before generating date range. weekmask :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 8, 5)\n\u003e\u003e\u003e ts + pd.offsets.CustomBusinessMonthBegin()\nTimestamp(\u00272022-09-01 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.CustomBusinessMonthEnd", "label": "CustomBusinessMonthEnd", "shape": "dot", "size": 20, "title": "NAME: CustomBusinessMonthEnd\n------------------------------\nINPUTS: s\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset subclass representing custom business month(s). Increments between end of month dates. Parameters ---------- n : int, default 1 The number of months represented. normalize : bool, default False Normalize end dates to midnight before generating date range. weekmask :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 8, 5)\n\u003e\u003e\u003e ts + pd.offsets.CustomBusinessMonthEnd()\nTimestamp(\u00272022-08-31 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.DateOffset", "label": "DateOffset", "shape": "dot", "size": 20, "title": "NAME: DateOffset\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Standard kind of date increment used for a date range. Works exactly like the keyword argument form of relativedelta. Note that the positional argument form of relativedelata is not supported. Use of the keyword n is discouraged-- you would be...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas.tseries.offsets import DateOffset\n\u003e\u003e\u003e ts = pd.Timestamp(\u00272017-01-01 09:10:11\u0027)\n\u003e\u003e\u003e ts + DateOffset(months=3)\nTimestamp(\u00272017-04-01 09:10:11\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.Day", "label": "Day", "shape": "dot", "size": 20, "title": "NAME: Day\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Offset ``n`` days. Parameters ---------- n : int, default 1 The number of days represented. See Also -------- :class:`~pandas.tseries.offsets.DateOffset` : Standard kind of date increment. Examples -------- You can use the parameter ``n`` to represent a shift of n days....\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas.tseries.offsets import Day\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 12, 9, 15)\n\u003e\u003e\u003e ts\nTimestamp(\u00272022-12-09 15:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.Easter", "label": "Easter", "shape": "dot", "size": 20, "title": "NAME: Easter\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset for the Easter holiday using logic defined in dateutil. Right now uses the revised method which is valid in years 1583-4099. Parameters ---------- n : int, default 1 The number of years represented. normalize : bool, default False Normalize...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 1, 1)\n\u003e\u003e\u003e ts + pd.offsets.Easter()\nTimestamp(\u00272022-04-17 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.FY5253", "label": "FY5253", "shape": "dot", "size": 20, "title": "NAME: FY5253\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Describes 52-53 week fiscal year. This is also known as a 4-4-5 calendar. It is used by companies that desire that their fiscal year always end on the same day of the week. It is a method of managing accounting...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 1, 1)\n\u003e\u003e\u003e ts + pd.offsets.FY5253()\nTimestamp(\u00272022-01-31 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.FY5253Quarter", "label": "FY5253Quarter", "shape": "dot", "size": 20, "title": "NAME: FY5253Quarter\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset increments between business quarter dates for 52-53 week fiscal year. Also known as a 4-4-5 calendar. It is used by companies that desire that their fiscal year always end on the same day of the week. It is a...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 1, 1)\n\u003e\u003e\u003e ts + pd.offsets.FY5253Quarter()\nTimestamp(\u00272022-01-31 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.Hour", "label": "Hour", "shape": "dot", "size": 20, "title": "NAME: Hour\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Offset ``n`` hours. Parameters ---------- n : int, default 1 The number of hours represented. See Also -------- :class:`~pandas.tseries.offsets.DateOffset` : Standard kind of date increment. Examples -------- You can use the parameter ``n`` to represent a shift of n hours....\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas.tseries.offsets import Hour\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 12, 9, 15)\n\u003e\u003e\u003e ts\nTimestamp(\u00272022-12-09 15:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.LastWeekOfMonth", "label": "LastWeekOfMonth", "shape": "dot", "size": 20, "title": "NAME: LastWeekOfMonth\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Describes monthly dates in last week of month. For example \"the last Tuesday of each month\". Parameters ---------- n : int, default 1 The number of months represented. normalize : bool, default False Normalize start/end dates to midnight before generating...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 1, 1)\n\u003e\u003e\u003e ts + pd.offsets.LastWeekOfMonth()\nTimestamp(\u00272022-01-31 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.Micro", "label": "Micro", "shape": "dot", "size": 20, "title": "NAME: Micro\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Offset ``n`` microseconds. Parameters ---------- n : int, default 1 The number of microseconds represented. See Also -------- :class:`~pandas.tseries.offsets.DateOffset` : Standard kind of date increment. Examples -------- You can use the parameter ``n`` to represent a shift of n microseconds....\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas.tseries.offsets import Micro\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 12, 9, 15)\n\u003e\u003e\u003e ts\nTimestamp(\u00272022-12-09 15:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.Milli", "label": "Milli", "shape": "dot", "size": 20, "title": "NAME: Milli\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Offset ``n`` milliseconds. Parameters ---------- n : int, default 1 The number of milliseconds represented. See Also -------- :class:`~pandas.tseries.offsets.DateOffset` : Standard kind of date increment. Examples -------- You can use the parameter ``n`` to represent a shift of n milliseconds....\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas.tseries.offsets import Milli\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 12, 9, 15)\n\u003e\u003e\u003e ts\nTimestamp(\u00272022-12-09 15:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.Minute", "label": "Minute", "shape": "dot", "size": 20, "title": "NAME: Minute\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Offset ``n`` minutes. Parameters ---------- n : int, default 1 The number of minutes represented. See Also -------- :class:`~pandas.tseries.offsets.DateOffset` : Standard kind of date increment. Examples -------- You can use the parameter ``n`` to represent a shift of n minutes....\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas.tseries.offsets import Minute\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 12, 9, 15)\n\u003e\u003e\u003e ts\nTimestamp(\u00272022-12-09 15:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.MonthBegin", "label": "MonthBegin", "shape": "dot", "size": 20, "title": "NAME: MonthBegin\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset of one month at beginning. MonthBegin goes to the next date which is a start of the month. Parameters ---------- n : int, default 1 The number of months represented. normalize : bool, default False Normalize start/end dates to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 11, 30)\n\u003e\u003e\u003e ts + pd.offsets.MonthBegin()\nTimestamp(\u00272022-12-01 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.MonthEnd", "label": "MonthEnd", "shape": "dot", "size": 20, "title": "NAME: MonthEnd\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset of one month end. MonthEnd goes to the next date which is an end of the month. Parameters ---------- n : int, default 1 The number of months represented. normalize : bool, default False Normalize start/end dates to midnight...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 1, 30)\n\u003e\u003e\u003e ts + pd.offsets.MonthEnd()\nTimestamp(\u00272022-01-31 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.Nano", "label": "Nano", "shape": "dot", "size": 20, "title": "NAME: Nano\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Offset ``n`` nanoseconds. Parameters ---------- n : int, default 1 The number of nanoseconds represented. See Also -------- :class:`~pandas.tseries.offsets.DateOffset` : Standard kind of date increment. Examples -------- You can use the parameter ``n`` to represent a shift of n nanoseconds....\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas.tseries.offsets import Nano\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 12, 9, 15)\n\u003e\u003e\u003e ts\nTimestamp(\u00272022-12-09 15:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.QuarterBegin", "label": "QuarterBegin", "shape": "dot", "size": 20, "title": "NAME: QuarterBegin\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset increments between Quarter start dates. startingMonth = 1 corresponds to dates like 1/01/2007, 4/01/2007, ... startingMonth = 2 corresponds to dates like 2/01/2007, 5/01/2007, ... startingMonth = 3 corresponds to dates like 3/01/2007, 6/01/2007, ... Parameters ---------- n :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 1, 1)\n\u003e\u003e\u003e ts + pd.offsets.QuarterBegin()\nTimestamp(\u00272022-03-01 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.QuarterEnd", "label": "QuarterEnd", "shape": "dot", "size": 20, "title": "NAME: QuarterEnd\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset increments between Quarter end dates. startingMonth = 1 corresponds to dates like 1/31/2007, 4/30/2007, ... startingMonth = 2 corresponds to dates like 2/28/2007, 5/31/2007, ... startingMonth = 3 corresponds to dates like 3/31/2007, 6/30/2007, ... Parameters ---------- n :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 1, 1)\n\u003e\u003e\u003e ts + pd.offsets.QuarterEnd()\nTimestamp(\u00272022-03-31 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.Second", "label": "Second", "shape": "dot", "size": 20, "title": "NAME: Second\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Offset ``n`` seconds. Parameters ---------- n : int, default 1 The number of seconds represented. See Also -------- :class:`~pandas.tseries.offsets.DateOffset` : Standard kind of date increment. Examples -------- You can use the parameter ``n`` to represent a shift of n seconds....\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas.tseries.offsets import Second\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 12, 9, 15)\n\u003e\u003e\u003e ts\nTimestamp(\u00272022-12-09 15:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.SemiMonthBegin", "label": "SemiMonthBegin", "shape": "dot", "size": 20, "title": "NAME: SemiMonthBegin\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Two DateOffset\u0027s per month repeating on the first day of the month \u0026 day_of_month. Parameters ---------- n : int, default 1 The number of months represented. normalize : bool, default False Normalize start/end dates to midnight before generating date range....\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 1, 1)\n\u003e\u003e\u003e ts + pd.offsets.SemiMonthBegin()\nTimestamp(\u00272022-01-15 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.SemiMonthEnd", "label": "SemiMonthEnd", "shape": "dot", "size": 20, "title": "NAME: SemiMonthEnd\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Two DateOffset\u0027s per month repeating on the last day of the month \u0026 day_of_month. Parameters ---------- n : int, default 1 The number of months represented. normalize : bool, default False Normalize start/end dates to midnight before generating date range....\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 1, 14)\n\u003e\u003e\u003e ts + pd.offsets.SemiMonthEnd()\nTimestamp(\u00272022-01-15 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.Tick", "label": "Tick", "shape": "dot", "size": 20, "title": "NAME: Tick\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Base class for DateOffset methods that are not overridden by subclasses. Parameters ---------- n : int Number of multiples of the frequency. normalize : bool Whether the frequency can align with midnight. Examples -------- \u003e\u003e\u003e pd.offsets.Hour(5).n 5 \u003e\u003e\u003e pd.offsets.Hour(5).normalize False...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.offsets.Hour(5).n\n5\n\u003e\u003e\u003e pd.offsets.Hour(5).normalize\nFalse"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.Week", "label": "Week", "shape": "dot", "size": 20, "title": "NAME: Week\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Weekly offset. Parameters ---------- n : int, default 1 The number of weeks represented. normalize : bool, default False Normalize start/end dates to midnight before generating date range. weekday : int or None, default None Always generate specific day of...\n\n\nEXAMPLE:\n\u003e\u003e\u003e date_object = pd.Timestamp(\"2023-01-13\")\n\u003e\u003e\u003e date_object\nTimestamp(\u00272023-01-13 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.WeekOfMonth", "label": "WeekOfMonth", "shape": "dot", "size": 20, "title": "NAME: WeekOfMonth\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Describes monthly dates like \"the Tuesday of the 2nd week of each month\". Parameters ---------- n : int, default 1 The number of months represented. normalize : bool, default False Normalize start/end dates to midnight before generating date range. week...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 1, 1)\n\u003e\u003e\u003e ts + pd.offsets.WeekOfMonth()\nTimestamp(\u00272022-01-03 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.YearBegin", "label": "YearBegin", "shape": "dot", "size": 20, "title": "NAME: YearBegin\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset increments between calendar year begin dates. YearBegin goes to the next date which is the start of the year. Parameters ---------- n : int, default 1 The number of years represented. normalize : bool, default False Normalize start/end dates...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 12, 1)\n\u003e\u003e\u003e ts + pd.offsets.YearBegin()\nTimestamp(\u00272023-01-01 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.offsets.YearEnd", "label": "YearEnd", "shape": "dot", "size": 20, "title": "NAME: YearEnd\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: DateOffset increments between calendar year end dates. YearEnd goes to the next date which is the end of the year. Parameters ---------- n : int, default 1 The number of years represented. normalize : bool, default False Normalize start/end dates...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ts = pd.Timestamp(2022, 1, 1)\n\u003e\u003e\u003e ts + pd.offsets.YearEnd()\nTimestamp(\u00272022-12-31 00:00:00\u0027)"}, {"color": "#70db70", "font": {"color": "white"}, "id": "pandas.plotting.PlotAccessor", "label": "PlotAccessor", "shape": "dot", "size": 20, "title": "NAME: PlotAccessor\n------------------------------\nINPUTS: data\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Make plots of Series or DataFrame. Uses the backend specified by the option ``plotting.backend``. By default, matplotlib is used. Parameters ---------- data : Series or DataFrame The object for which the method is called. x : label or position, default...\n\n\nEXAMPLE:\n\u003e\u003e\u003e ser = pd.Series([1, 2, 3, 3])\n    \u003e\u003e\u003e plot = ser.plot(kind=\u0027hist\u0027, title=\"My plot\")"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.plotting.andrews_curves", "label": "andrews_curves", "shape": "dot", "size": 20, "title": "NAME: andrews_curves\n------------------------------\nINPUTS: frame, class_column, ax, samples, color, colormap, kwargs\nOUTPUTS: Axes\n------------------------------\nDESCRIPTION: Generate a matplotlib plot for visualizing clusters of multivariate data. Andrews curves have the functional form: .. math:: f(t) = \\frac{x_1}{\\sqrt{2}} + x_2 \\sin(t) + x_3 \\cos(t) + x_4 \\sin(2t) + x_5 \\cos(2t) + \\cdots Where :math:`x` coefficients correspond to...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.read_csv(\n    ...     \u0027https://raw.githubusercontent.com/pandas-dev/\u0027\n    ...     \u0027pandas/main/pandas/tests/io/data/csv/iris.csv\u0027\n    ... )\n    \u003e\u003e\u003e pd.plotting.andrews_curves(df, \u0027Name\u0027)  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.plotting.autocorrelation_plot", "label": "autocorrelation_plot", "shape": "dot", "size": 20, "title": "NAME: autocorrelation_plot\n------------------------------\nINPUTS: series, ax, kwargs\nOUTPUTS: Axes\n------------------------------\nDESCRIPTION: Autocorrelation plot for time series. Parameters ---------- series : Series The time series to visualize. ax : Matplotlib axis object, optional The matplotlib axis object to use. **kwargs Options to pass to matplotlib plotting method. Returns ------- matplotlib.axes.Axes Examples --------...\n\n\nEXAMPLE:\n\u003e\u003e\u003e spacing = np.linspace(-9 * np.pi, 9 * np.pi, num=1000)\n    \u003e\u003e\u003e s = pd.Series(0.7 * np.random.rand(1000) + 0.3 * np.sin(spacing))\n    \u003e\u003e\u003e pd.plotting.autocorrelation_plot(s)  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.plotting.bootstrap_plot", "label": "bootstrap_plot", "shape": "dot", "size": 20, "title": "NAME: bootstrap_plot\n------------------------------\nINPUTS: series, fig, size, samples, kwds\nOUTPUTS: Figure\n------------------------------\nDESCRIPTION: Bootstrap plot on mean, median and mid-range statistics. The bootstrap plot is used to estimate the uncertainty of a statistic by relying on random sampling with replacement [1]_. This function will generate bootstrapping plots for mean, median and mid-range statistics...\n\n\nEXAMPLE:\n\u003e\u003e\u003e s = pd.Series(np.random.uniform(size=100))\n    \u003e\u003e\u003e pd.plotting.bootstrap_plot(s)  # doctest: +SKIP\n    \u003cFigure size 640x480 with 6 Axes\u003e"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.plotting.boxplot", "label": "boxplot", "shape": "dot", "size": 20, "title": "NAME: boxplot\n------------------------------\nINPUTS: data, column, by, ax, fontsize, rot, grid, figsize, layout, return_type, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Make a box plot from DataFrame columns. Make a box-and-whisker plot from DataFrame columns, optionally grouped by some other columns. A box plot is a method for graphically depicting groups of numerical data through their quartiles. The box extends from...\n\n\nEXAMPLE:\n\u003e\u003e\u003e np.random.seed(1234)\n    \u003e\u003e\u003e df = pd.DataFrame(np.random.randn(10, 4),\n    ...                   columns=[\u0027Col1\u0027, \u0027Col2\u0027, \u0027Col3\u0027, \u0027Col4\u0027])\n    \u003e\u003e\u003e boxplot = df.boxplot(column=[\u0027Col1\u0027, \u0027Col2\u0027, \u0027Col3\u0027])  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.plotting.boxplot_frame", "label": "boxplot_frame", "shape": "dot", "size": 20, "title": "NAME: boxplot_frame\n------------------------------\nINPUTS: self, column, by, ax, fontsize, rot, grid, figsize, layout, return_type, backend, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Make a box plot from DataFrame columns. Make a box-and-whisker plot from DataFrame columns, optionally grouped by some other columns. A box plot is a method for graphically depicting groups of numerical data through their quartiles. The box extends from...\n\n\nEXAMPLE:\n\u003e\u003e\u003e np.random.seed(1234)\n    \u003e\u003e\u003e df = pd.DataFrame(np.random.randn(10, 4),\n    ...                   columns=[\u0027Col1\u0027, \u0027Col2\u0027, \u0027Col3\u0027, \u0027Col4\u0027])\n    \u003e\u003e\u003e boxplot = df.boxplot(column=[\u0027Col1\u0027, \u0027Col2\u0027, \u0027Col3\u0027])  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.plotting.boxplot_frame_groupby", "label": "boxplot_frame_groupby", "shape": "dot", "size": 20, "title": "NAME: boxplot_frame_groupby\n------------------------------\nINPUTS: grouped, subplots, column, fontsize, rot, grid, ax, figsize, layout, sharex, sharey, backend, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Make box plots from DataFrameGroupBy data. Parameters ---------- grouped : Grouped DataFrame subplots : bool * ``False`` - no subplots will be used * ``True`` - create a subplot for each group. column : column name or list of names,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import itertools\n    \u003e\u003e\u003e tuples = [t for t in itertools.product(range(1000), range(4))]\n    \u003e\u003e\u003e index = pd.MultiIndex.from_tuples(tuples, names=[\u0027lvl0\u0027, \u0027lvl1\u0027])\n    \u003e\u003e\u003e data = np.random.randn(len(index), 4)\n    \u003e\u003e\u003e df = pd.DataFrame(data, columns=list(\u0027ABCD\u0027), index=index)\n    \u003e\u003e\u003e grouped = df.groupby(level=\u0027lvl1\u0027)\n    \u003e\u003e\u003e grouped.boxplot(rot=45, fontsize=12, figsize=(8, 10))  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.plotting.deregister_matplotlib_converters", "label": "deregister_matplotlib_converters", "shape": "dot", "size": 20, "title": "NAME: deregister_matplotlib_converters\n------------------------------\nINPUTS: \nOUTPUTS: None\n------------------------------\nDESCRIPTION: Remove pandas formatters and converters. Removes the custom converters added by :func:`register`. This attempts to set the state of the registry back to the state before pandas registered its own units. Converters for pandas\u0027 own types like Timestamp and Period...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.plotting.register_matplotlib_converters()"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.plotting.hist_frame", "label": "hist_frame", "shape": "dot", "size": 20, "title": "NAME: hist_frame\n------------------------------\nINPUTS: data, column, by, grid, xlabelsize, xrot, ylabelsize, yrot, ax, sharex, sharey, figsize, layout, bins, backend, legend, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Make a histogram of the DataFrame\u0027s columns. A `histogram`_ is a representation of the distribution of data. This function calls :meth:`matplotlib.pyplot.hist`, on each series in the DataFrame, resulting in one histogram per column. .. _histogram: https://en.wikipedia.org/wiki/Histogram Parameters ---------- data :...\n\n\nEXAMPLE:\n\u003e\u003e\u003e data = {\u0027length\u0027: [1.5, 0.5, 1.2, 0.9, 3],\n    ...         \u0027width\u0027: [0.7, 0.2, 0.15, 0.2, 1.1]}\n    \u003e\u003e\u003e index = [\u0027pig\u0027, \u0027rabbit\u0027, \u0027duck\u0027, \u0027chicken\u0027, \u0027horse\u0027]\n    \u003e\u003e\u003e df = pd.DataFrame(data, index=index)\n    \u003e\u003e\u003e hist = df.hist(bins=3)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.plotting.hist_series", "label": "hist_series", "shape": "dot", "size": 20, "title": "NAME: hist_series\n------------------------------\nINPUTS: self, by, ax, grid, xlabelsize, xrot, ylabelsize, yrot, figsize, bins, backend, legend, kwargs\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Draw histogram of the input series using matplotlib. Parameters ---------- by : object, optional If passed, then used to form histograms for separate groups. ax : matplotlib axis object If not passed, uses gca(). grid : bool, default True Whether...\n\n\nEXAMPLE:\n\u003e\u003e\u003e lst = [\u0027a\u0027, \u0027a\u0027, \u0027a\u0027, \u0027b\u0027, \u0027b\u0027, \u0027b\u0027]\n    \u003e\u003e\u003e ser = pd.Series([1, 2, 2, 4, 6, 6], index=lst)\n    \u003e\u003e\u003e hist = ser.hist()"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.plotting.lag_plot", "label": "lag_plot", "shape": "dot", "size": 20, "title": "NAME: lag_plot\n------------------------------\nINPUTS: series, lag, ax, kwds\nOUTPUTS: Axes\n------------------------------\nDESCRIPTION: Lag plot for time series. Parameters ---------- series : Series The time series to visualize. lag : int, default 1 Lag length of the scatter plot. ax : Matplotlib axis object, optional The matplotlib axis object to use. **kwds Matplotlib...\n\n\nEXAMPLE:\n\u003e\u003e\u003e np.random.seed(5)\n    \u003e\u003e\u003e x = np.cumsum(np.random.normal(loc=1, scale=5, size=50))\n    \u003e\u003e\u003e s = pd.Series(x)\n    \u003e\u003e\u003e s.plot()  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.plotting.parallel_coordinates", "label": "parallel_coordinates", "shape": "dot", "size": 20, "title": "NAME: parallel_coordinates\n------------------------------\nINPUTS: frame, class_column, cols, ax, color, use_columns, xticks, colormap, axvlines, axvlines_kwds, sort_labels, kwargs\nOUTPUTS: Axes\n------------------------------\nDESCRIPTION: Parallel coordinates plotting. Parameters ---------- frame : DataFrame class_column : str Column name containing class names. cols : list, optional A list of column names to use. ax : matplotlib.axis, optional Matplotlib axis object. color : list or tuple, optional...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.read_csv(\n    ...     \u0027https://raw.githubusercontent.com/pandas-dev/\u0027\n    ...     \u0027pandas/main/pandas/tests/io/data/csv/iris.csv\u0027\n    ... )\n    \u003e\u003e\u003e pd.plotting.parallel_coordinates(\n    ...     df, \u0027Name\u0027, color=(\u0027#556270\u0027, \u0027#4ECDC4\u0027, \u0027#C7F464\u0027)\n    ... )  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.plotting.radviz", "label": "radviz", "shape": "dot", "size": 20, "title": "NAME: radviz\n------------------------------\nINPUTS: frame, class_column, ax, color, colormap, kwds\nOUTPUTS: Axes\n------------------------------\nDESCRIPTION: Plot a multidimensional dataset in 2D. Each Series in the DataFrame is represented as a evenly distributed slice on a circle. Each data point is rendered in the circle according to the value on each Series. Highly correlated `Series` in...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(\n    ...     {\n    ...         \u0027SepalLength\u0027: [6.5, 7.7, 5.1, 5.8, 7.6, 5.0, 5.4, 4.6, 6.7, 4.6],\n    ...         \u0027SepalWidth\u0027: [3.0, 3.8, 3.8, 2.7, 3.0, 2.3, 3.0, 3.2, 3.3, 3.6],\n    ...         \u0027PetalLength\u0027: [5.5, 6.7, 1.9, 5.1, 6.6, 3.3, 4.5, 1.4, 5.7, 1.0],\n    ...         \u0027PetalWidth\u0027: [1.8, 2.2, 0.4, 1.9, 2.1, 1.0, 1.5, 0.2, 2.1, 0.2],\n    ...         \u0027Category\u0027: [\n    ...             \u0027virginica\u0027,\n    ...             \u0027virginica\u0027,\n    ...             \u0027setosa\u0027,\n    ...             \u0027virginica\u0027,\n    ...             \u0027virginica\u0027,\n    ...             \u0027versicolor\u0027,\n    ...             \u0027versicolor\u0027,\n    ...             \u0027setosa\u0027,\n    ...             \u0027virginica\u0027,\n    ...             \u0027setosa\u0027\n    ...         ]\n    ...     }\n    ... )\n    \u003e\u003e\u003e pd.plotting.radviz(df, \u0027Category\u0027)  # doctest: +SKIP"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.plotting.register_matplotlib_converters", "label": "register_matplotlib_converters", "shape": "dot", "size": 20, "title": "NAME: register_matplotlib_converters\n------------------------------\nINPUTS: \nOUTPUTS: None\n------------------------------\nDESCRIPTION: Register pandas formatters and converters with matplotlib. This function modifies the global ``matplotlib.units.registry`` dictionary. pandas adds custom converters for * pd.Timestamp * pd.Period * np.datetime64 * datetime.datetime * datetime.date * datetime.time See Also -------- deregister_matplotlib_converters : Remove pandas formatters and...\n\n\nEXAMPLE:\n\u003e\u003e\u003e pd.plotting.register_matplotlib_converters()"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.plotting.scatter_matrix", "label": "scatter_matrix", "shape": "dot", "size": 20, "title": "NAME: scatter_matrix\n------------------------------\nINPUTS: frame, alpha, figsize, ax, grid, diagonal, marker, density_kwds, hist_kwds, range_padding, kwargs\nOUTPUTS: np.ndarray\n------------------------------\nDESCRIPTION: Draw a matrix of scatter plots. Parameters ---------- frame : DataFrame alpha : float, optional Amount of transparency applied. figsize : (float,float), optional A tuple (width, height) in inches. ax : Matplotlib axis object, optional grid : bool, optional Setting...\n\n\nEXAMPLE:\n\u003e\u003e\u003e df = pd.DataFrame(np.random.randn(1000, 4), columns=[\u0027A\u0027,\u0027B\u0027,\u0027C\u0027,\u0027D\u0027])\n    \u003e\u003e\u003e pd.plotting.scatter_matrix(df, alpha=0.2)\n    array([[\u003cAxes: xlabel=\u0027A\u0027, ylabel=\u0027A\u0027\u003e, \u003cAxes: xlabel=\u0027B\u0027, ylabel=\u0027A\u0027\u003e,\n            \u003cAxes: xlabel=\u0027C\u0027, ylabel=\u0027A\u0027\u003e, \u003cAxes: xlabel=\u0027D\u0027, ylabel=\u0027A\u0027\u003e],\n           [\u003cAxes: xlabel=\u0027A\u0027, ylabel=\u0027B\u0027\u003e, \u003cAxes: xlabel=\u0027B\u0027, ylabel=\u0027B\u0027\u003e,\n            \u003cAxes: xlabel=\u0027C\u0027, ylabel=\u0027B\u0027\u003e, \u003cAxes: xlabel=\u0027D\u0027, ylabel=\u0027B\u0027\u003e],\n           [\u003cAxes: xlabel=\u0027A\u0027, ylabel=\u0027C\u0027\u003e, \u003cAxes: xlabel=\u0027B\u0027, ylabel=\u0027C\u0027\u003e,\n            \u003cAxes: xlabel=\u0027C\u0027, ylabel=\u0027C\u0027\u003e, \u003cAxes: xlabel=\u0027D\u0027, ylabel=\u0027C\u0027\u003e],\n           [\u003cAxes: xlabel=\u0027A\u0027, ylabel=\u0027D\u0027\u003e, \u003cAxes: xlabel=\u0027B\u0027, ylabel=\u0027D\u0027\u003e,\n            \u003cAxes: xlabel=\u0027C\u0027, ylabel=\u0027D\u0027\u003e, \u003cAxes: xlabel=\u0027D\u0027, ylabel=\u0027D\u0027\u003e]],\n          dtype=object)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.plotting.table", "label": "table", "shape": "dot", "size": 20, "title": "NAME: table\n------------------------------\nINPUTS: ax, data, kwargs\nOUTPUTS: Table\n------------------------------\nDESCRIPTION: Helper function to convert DataFrame and Series to matplotlib.table. Parameters ---------- ax : Matplotlib axes object data : DataFrame or Series Data for table contents. **kwargs Keyword arguments to be passed to matplotlib.table.table. If `rowLabels` or `colLabels` is not specified,...\n\n\nEXAMPLE:\n\u003e\u003e\u003e import matplotlib.pyplot as plt\n        \u003e\u003e\u003e df = pd.DataFrame({\u0027A\u0027: [1, 2], \u0027B\u0027: [3, 4]})\n        \u003e\u003e\u003e fix, ax = plt.subplots()\n        \u003e\u003e\u003e ax.axis(\u0027off\u0027)\n        (0.0, 1.0, 0.0, 1.0)\n        \u003e\u003e\u003e table = pd.plotting.table(ax, df, loc=\u0027center\u0027,\n        ...                           cellLoc=\u0027center\u0027, colWidths=list([.2, .2]))"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.testing.assert_extension_array_equal", "label": "assert_extension_array_equal", "shape": "dot", "size": 20, "title": "NAME: assert_extension_array_equal\n------------------------------\nINPUTS: left, right, check_dtype, index_values, check_exact, rtol, atol, obj\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Check that left and right ExtensionArrays are equal. Parameters ---------- left, right : ExtensionArray The two arrays to compare. check_dtype : bool, default True Whether to check if the ExtensionArray dtypes are identical. index_values : Index | numpy.ndarray, default None...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas import testing as tm\n\u003e\u003e\u003e a = pd.Series([1, 2, 3, 4])\n\u003e\u003e\u003e b, c = a.array, a.array\n\u003e\u003e\u003e tm.assert_extension_array_equal(b, c)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.testing.assert_frame_equal", "label": "assert_frame_equal", "shape": "dot", "size": 20, "title": "NAME: assert_frame_equal\n------------------------------\nINPUTS: left, right, check_dtype, check_index_type, check_column_type, check_frame_type, check_names, by_blocks, check_exact, check_datetimelike_compat, check_categorical, check_like, check_freq, check_flags, rtol, atol, obj\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Check that left and right DataFrame are equal. This function is intended to compare two DataFrames and output any differences. It is mostly intended for use in unit tests. Additional parameters allow varying the strictness of the equality checks performed....\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas.testing import assert_frame_equal\n\u003e\u003e\u003e df1 = pd.DataFrame({\u0027a\u0027: [1, 2], \u0027b\u0027: [3, 4]})\n\u003e\u003e\u003e df2 = pd.DataFrame({\u0027a\u0027: [1, 2], \u0027b\u0027: [3.0, 4.0]})"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.testing.assert_index_equal", "label": "assert_index_equal", "shape": "dot", "size": 20, "title": "NAME: assert_index_equal\n------------------------------\nINPUTS: left, right, exact, check_names, check_exact, check_categorical, check_order, rtol, atol, obj\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Check that left and right Index are equal. Parameters ---------- left : Index right : Index exact : bool or {\u0027equiv\u0027}, default \u0027equiv\u0027 Whether to check the Index class, dtype and inferred_type are identical. If \u0027equiv\u0027, then RangeIndex can be...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas import testing as tm\n\u003e\u003e\u003e a = pd.Index([1, 2, 3])\n\u003e\u003e\u003e b = pd.Index([1, 2, 3])\n\u003e\u003e\u003e tm.assert_index_equal(a, b)"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.testing.assert_series_equal", "label": "assert_series_equal", "shape": "dot", "size": 20, "title": "NAME: assert_series_equal\n------------------------------\nINPUTS: left, right, check_dtype, check_index_type, check_series_type, check_names, check_exact, check_datetimelike_compat, check_categorical, check_category_order, check_freq, check_flags, rtol, atol, obj, check_index, check_like\nOUTPUTS: None\n------------------------------\nDESCRIPTION: Check that left and right Series are equal. Parameters ---------- left : Series right : Series check_dtype : bool, default True Whether to check the Series dtype is identical. check_index_type : bool or {\u0027equiv\u0027}, default \u0027equiv\u0027 Whether to check the...\n\n\nEXAMPLE:\n\u003e\u003e\u003e from pandas import testing as tm\n\u003e\u003e\u003e a = pd.Series([1, 2, 3, 4])\n\u003e\u003e\u003e b = pd.Series([1, 2, 3, 4])\n\u003e\u003e\u003e tm.assert_series_equal(a, b)"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.tseries.api", "label": "api", "shape": "dot", "size": 20, "title": "NAME: api\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: Timeseries API...\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.tseries.frequencies", "label": "frequencies", "shape": "dot", "size": 20, "title": "NAME: frequencies\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.tseries.offsets", "label": "offsets", "shape": "dot", "size": 20, "title": "NAME: offsets\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#4db8ff", "font": {"color": "white"}, "id": "pandas.util.capitalize_first_letter", "label": "capitalize_first_letter", "shape": "dot", "size": 20, "title": "NAME: capitalize_first_letter\n------------------------------\nINPUTS: s\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}, {"color": "#ff9933", "font": {"color": "white"}, "id": "pandas.util.version", "label": "version", "shape": "dot", "size": 20, "title": "NAME: version\n------------------------------\nINPUTS: Not found\nOUTPUTS: Any\n------------------------------\nDESCRIPTION: No docs available....\n"}]);
                  edges = new vis.DataSet([{"arrows": "to", "from": "pandas", "to": "pandas.ArrowDtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.BooleanDtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.Categorical", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.CategoricalDtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.CategoricalIndex", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.DataFrame", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.DateOffset", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.DatetimeIndex", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.DatetimeTZDtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.ExcelFile", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.ExcelWriter", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.Flags", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.Float32Dtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.Float64Dtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.Grouper", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.HDFStore", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.Index", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.Int16Dtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.Int32Dtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.Int64Dtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.Int8Dtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.Interval", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.IntervalDtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.IntervalIndex", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.MultiIndex", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.NamedAgg", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.Period", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.PeriodDtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.PeriodIndex", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.RangeIndex", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.Series", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.SparseDtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.StringDtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.Timedelta", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.TimedeltaIndex", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.Timestamp", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.UInt16Dtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.UInt32Dtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.UInt64Dtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.UInt8Dtype", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.api", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.array", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.arrays", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.bdate_range", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.compat", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.concat", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.core", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.crosstab", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.cut", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.date_range", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.errors", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.eval", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.factorize", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.from_dummies", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.get_dummies", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.infer_freq", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.interval_range", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.io", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.isna", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.isnull", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.json_normalize", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.lreshape", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.melt", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.merge", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.merge_asof", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.merge_ordered", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.notna", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.notnull", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.offsets", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.option_context", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.pandas", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.period_range", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.pivot", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.pivot_table", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.plotting", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.qcut", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_clipboard", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_csv", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_excel", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_feather", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_fwf", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_gbq", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_hdf", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_html", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_json", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_orc", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_parquet", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_pickle", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_sas", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_spss", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_sql", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_sql_query", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_sql_table", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_stata", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_table", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.read_xml", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.set_eng_float_format", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.show_versions", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.test", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.testing", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.timedelta_range", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.to_datetime", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.to_numeric", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.to_pickle", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.to_timedelta", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.tseries", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.unique", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.util", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.value_counts", "width": 1}, {"arrows": "to", "from": "pandas", "to": "pandas.wide_to_long", "width": 1}, {"arrows": "to", "from": "pandas.ArrowDtype", "to": "pandas.ArrowDtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.ArrowDtype", "to": "pandas.ArrowDtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.ArrowDtype", "to": "pandas.ArrowDtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.ArrowDtype", "to": "pandas.ArrowDtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.BooleanDtype", "to": "pandas.BooleanDtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.BooleanDtype", "to": "pandas.BooleanDtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.BooleanDtype", "to": "pandas.BooleanDtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.BooleanDtype", "to": "pandas.BooleanDtype.from_numpy_dtype", "width": 1}, {"arrows": "to", "from": "pandas.BooleanDtype", "to": "pandas.BooleanDtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.add_categories", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.argmax", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.argmin", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.argsort", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.as_ordered", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.as_unordered", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.astype", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.check_for_ordered", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.describe", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.dropna", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.duplicated", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.equals", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.factorize", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.fillna", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.from_codes", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.insert", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.interpolate", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.isin", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.isna", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.isnull", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.map", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.max", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.memory_usage", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.min", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.notna", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.notnull", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.remove_categories", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.remove_unused_categories", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.rename_categories", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.reorder_categories", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.searchsorted", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.set_categories", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.set_ordered", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.shift", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.sort_values", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.take", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.to_list", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.to_numpy", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.tolist", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.unique", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.value_counts", "width": 1}, {"arrows": "to", "from": "pandas.Categorical", "to": "pandas.Categorical.view", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalDtype", "to": "pandas.CategoricalDtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalDtype", "to": "pandas.CategoricalDtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalDtype", "to": "pandas.CategoricalDtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalDtype", "to": "pandas.CategoricalDtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalDtype", "to": "pandas.CategoricalDtype.reset_cache", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalDtype", "to": "pandas.CategoricalDtype.type", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalDtype", "to": "pandas.CategoricalDtype.update_dtype", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalDtype", "to": "pandas.CategoricalDtype.validate_categories", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalDtype", "to": "pandas.CategoricalDtype.validate_ordered", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.add_categories", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.all", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.any", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.append", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.argmax", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.argmin", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.argsort", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.as_ordered", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.as_unordered", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.asof", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.asof_locs", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.astype", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.copy", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.delete", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.diff", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.difference", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.drop", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.drop_duplicates", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.droplevel", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.dropna", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.duplicated", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.equals", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.factorize", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.fillna", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.format", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.get_indexer", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.get_indexer_for", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.get_indexer_non_unique", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.get_level_values", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.get_loc", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.get_slice_bound", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.groupby", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.holds_integer", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.identical", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.infer_objects", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.insert", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.intersection", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.is_", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.is_boolean", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.is_categorical", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.is_floating", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.is_integer", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.is_interval", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.is_numeric", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.is_object", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.isin", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.isna", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.isnull", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.item", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.join", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.map", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.max", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.memory_usage", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.min", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.notna", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.notnull", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.nunique", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.putmask", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.ravel", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.reindex", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.remove_categories", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.remove_unused_categories", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.rename", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.rename_categories", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.reorder_categories", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.repeat", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.round", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.searchsorted", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.set_categories", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.set_names", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.shift", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.slice_indexer", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.slice_locs", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.sort", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.sort_values", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.sortlevel", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.str", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.symmetric_difference", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.take", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.to_flat_index", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.to_frame", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.to_list", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.to_numpy", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.to_series", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.tolist", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.transpose", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.union", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.unique", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.value_counts", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.view", "width": 1}, {"arrows": "to", "from": "pandas.CategoricalIndex", "to": "pandas.CategoricalIndex.where", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.abs", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.add", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.add_prefix", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.add_suffix", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.agg", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.aggregate", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.align", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.all", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.any", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.apply", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.applymap", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.asfreq", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.asof", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.assign", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.astype", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.at_time", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.backfill", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.between_time", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.bfill", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.bool", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.boxplot", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.clip", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.combine", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.combine_first", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.compare", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.convert_dtypes", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.copy", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.corr", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.corrwith", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.count", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.cov", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.cummax", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.cummin", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.cumprod", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.cumsum", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.describe", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.diff", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.div", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.divide", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.dot", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.drop", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.drop_duplicates", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.droplevel", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.dropna", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.duplicated", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.eq", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.equals", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.eval", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.ewm", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.expanding", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.explode", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.ffill", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.fillna", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.filter", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.first", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.first_valid_index", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.floordiv", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.from_dict", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.from_records", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.ge", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.get", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.groupby", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.gt", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.head", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.hist", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.idxmax", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.idxmin", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.infer_objects", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.info", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.insert", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.interpolate", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.isetitem", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.isin", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.isna", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.isnull", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.items", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.iterrows", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.itertuples", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.join", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.keys", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.kurt", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.kurtosis", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.last", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.last_valid_index", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.le", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.lt", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.map", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.mask", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.max", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.mean", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.median", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.melt", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.memory_usage", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.merge", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.min", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.mod", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.mode", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.mul", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.multiply", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.ne", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.nlargest", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.notna", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.notnull", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.nsmallest", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.nunique", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.pad", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.pct_change", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.pipe", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.pivot", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.pivot_table", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.plot", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.pop", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.pow", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.prod", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.product", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.quantile", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.query", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.radd", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.rank", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.rdiv", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.reindex", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.reindex_like", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.rename", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.rename_axis", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.reorder_levels", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.replace", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.resample", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.reset_index", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.rfloordiv", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.rmod", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.rmul", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.rolling", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.round", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.rpow", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.rsub", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.rtruediv", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.sample", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.select_dtypes", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.sem", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.set_axis", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.set_flags", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.set_index", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.shift", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.skew", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.sort_index", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.sort_values", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.sparse", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.squeeze", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.stack", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.std", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.sub", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.subtract", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.sum", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.swapaxes", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.swaplevel", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.tail", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.take", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_clipboard", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_csv", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_dict", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_excel", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_feather", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_gbq", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_hdf", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_html", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_json", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_latex", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_markdown", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_numpy", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_orc", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_parquet", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_period", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_pickle", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_records", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_sql", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_stata", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_string", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_timestamp", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_xarray", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.to_xml", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.transform", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.transpose", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.truediv", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.truncate", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.tz_convert", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.tz_localize", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.unstack", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.update", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.value_counts", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.var", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.where", "width": 1}, {"arrows": "to", "from": "pandas.DataFrame", "to": "pandas.DataFrame.xs", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.all", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.any", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.append", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.argmax", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.argmin", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.argsort", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.as_unit", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.asof", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.asof_locs", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.astype", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.ceil", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.copy", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.day_name", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.delete", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.diff", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.difference", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.drop", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.drop_duplicates", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.droplevel", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.dropna", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.duplicated", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.equals", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.factorize", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.fillna", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.floor", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.format", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.get_indexer", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.get_indexer_for", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.get_indexer_non_unique", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.get_level_values", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.get_loc", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.get_slice_bound", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.groupby", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.holds_integer", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.identical", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.indexer_at_time", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.indexer_between_time", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.infer_objects", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.insert", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.intersection", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.is_", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.is_boolean", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.is_categorical", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.is_floating", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.is_integer", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.is_interval", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.is_numeric", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.is_object", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.isin", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.isna", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.isnull", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.isocalendar", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.item", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.join", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.map", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.max", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.mean", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.memory_usage", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.min", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.month_name", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.normalize", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.notna", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.notnull", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.nunique", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.putmask", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.ravel", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.reindex", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.rename", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.repeat", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.round", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.searchsorted", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.set_names", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.shift", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.slice_indexer", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.slice_locs", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.snap", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.sort", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.sort_values", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.sortlevel", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.std", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.str", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.strftime", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.symmetric_difference", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.take", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.to_flat_index", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.to_frame", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.to_julian_date", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.to_list", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.to_numpy", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.to_period", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.to_pydatetime", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.to_series", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.tolist", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.transpose", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.tz_convert", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.tz_localize", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.union", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.unique", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.value_counts", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.view", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeIndex", "to": "pandas.DatetimeIndex.where", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeTZDtype", "to": "pandas.DatetimeTZDtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeTZDtype", "to": "pandas.DatetimeTZDtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeTZDtype", "to": "pandas.DatetimeTZDtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeTZDtype", "to": "pandas.DatetimeTZDtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeTZDtype", "to": "pandas.DatetimeTZDtype.reset_cache", "width": 1}, {"arrows": "to", "from": "pandas.DatetimeTZDtype", "to": "pandas.DatetimeTZDtype.type", "width": 1}, {"arrows": "to", "from": "pandas.ExcelFile", "to": "pandas.ExcelFile.CalamineReader", "width": 1}, {"arrows": "to", "from": "pandas.ExcelFile", "to": "pandas.ExcelFile.ODFReader", "width": 1}, {"arrows": "to", "from": "pandas.ExcelFile", "to": "pandas.ExcelFile.OpenpyxlReader", "width": 1}, {"arrows": "to", "from": "pandas.ExcelFile", "to": "pandas.ExcelFile.PyxlsbReader", "width": 1}, {"arrows": "to", "from": "pandas.ExcelFile", "to": "pandas.ExcelFile.XlrdReader", "width": 1}, {"arrows": "to", "from": "pandas.ExcelFile", "to": "pandas.ExcelFile.close", "width": 1}, {"arrows": "to", "from": "pandas.ExcelFile", "to": "pandas.ExcelFile.parse", "width": 1}, {"arrows": "to", "from": "pandas.ExcelWriter", "to": "pandas.ExcelWriter.check_extension", "width": 1}, {"arrows": "to", "from": "pandas.ExcelWriter", "to": "pandas.ExcelWriter.close", "width": 1}, {"arrows": "to", "from": "pandas.Float32Dtype", "to": "pandas.Float32Dtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.Float32Dtype", "to": "pandas.Float32Dtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.Float32Dtype", "to": "pandas.Float32Dtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.Float32Dtype", "to": "pandas.Float32Dtype.from_numpy_dtype", "width": 1}, {"arrows": "to", "from": "pandas.Float32Dtype", "to": "pandas.Float32Dtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.Float32Dtype", "to": "pandas.Float32Dtype.type", "width": 1}, {"arrows": "to", "from": "pandas.Float64Dtype", "to": "pandas.Float64Dtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.Float64Dtype", "to": "pandas.Float64Dtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.Float64Dtype", "to": "pandas.Float64Dtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.Float64Dtype", "to": "pandas.Float64Dtype.from_numpy_dtype", "width": 1}, {"arrows": "to", "from": "pandas.Float64Dtype", "to": "pandas.Float64Dtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.Float64Dtype", "to": "pandas.Float64Dtype.type", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.append", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.append_to_multiple", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.close", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.copy", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.create_table_index", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.flush", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.get", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.get_node", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.get_storer", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.groups", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.info", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.items", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.keys", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.open", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.put", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.remove", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.select", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.select_as_coordinates", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.select_as_multiple", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.select_column", "width": 1}, {"arrows": "to", "from": "pandas.HDFStore", "to": "pandas.HDFStore.walk", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.all", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.any", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.append", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.argmax", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.argmin", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.argsort", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.asof", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.asof_locs", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.astype", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.copy", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.delete", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.diff", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.difference", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.drop", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.drop_duplicates", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.droplevel", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.dropna", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.duplicated", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.equals", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.factorize", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.fillna", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.format", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.get_indexer", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.get_indexer_for", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.get_indexer_non_unique", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.get_level_values", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.get_loc", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.get_slice_bound", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.groupby", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.holds_integer", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.identical", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.infer_objects", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.insert", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.intersection", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.is_", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.is_boolean", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.is_categorical", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.is_floating", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.is_integer", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.is_interval", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.is_numeric", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.is_object", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.isin", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.isna", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.isnull", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.item", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.join", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.map", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.max", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.memory_usage", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.min", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.notna", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.notnull", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.nunique", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.putmask", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.ravel", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.reindex", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.rename", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.repeat", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.round", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.searchsorted", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.set_names", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.shift", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.slice_indexer", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.slice_locs", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.sort", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.sort_values", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.sortlevel", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.str", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.symmetric_difference", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.take", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.to_flat_index", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.to_frame", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.to_list", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.to_numpy", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.to_series", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.tolist", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.transpose", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.union", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.unique", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.value_counts", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.view", "width": 1}, {"arrows": "to", "from": "pandas.Index", "to": "pandas.Index.where", "width": 1}, {"arrows": "to", "from": "pandas.Int16Dtype", "to": "pandas.Int16Dtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.Int16Dtype", "to": "pandas.Int16Dtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.Int16Dtype", "to": "pandas.Int16Dtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.Int16Dtype", "to": "pandas.Int16Dtype.from_numpy_dtype", "width": 1}, {"arrows": "to", "from": "pandas.Int16Dtype", "to": "pandas.Int16Dtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.Int16Dtype", "to": "pandas.Int16Dtype.type", "width": 1}, {"arrows": "to", "from": "pandas.Int32Dtype", "to": "pandas.Int32Dtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.Int32Dtype", "to": "pandas.Int32Dtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.Int32Dtype", "to": "pandas.Int32Dtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.Int32Dtype", "to": "pandas.Int32Dtype.from_numpy_dtype", "width": 1}, {"arrows": "to", "from": "pandas.Int32Dtype", "to": "pandas.Int32Dtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.Int32Dtype", "to": "pandas.Int32Dtype.type", "width": 1}, {"arrows": "to", "from": "pandas.Int64Dtype", "to": "pandas.Int64Dtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.Int64Dtype", "to": "pandas.Int64Dtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.Int64Dtype", "to": "pandas.Int64Dtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.Int64Dtype", "to": "pandas.Int64Dtype.from_numpy_dtype", "width": 1}, {"arrows": "to", "from": "pandas.Int64Dtype", "to": "pandas.Int64Dtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.Int64Dtype", "to": "pandas.Int64Dtype.type", "width": 1}, {"arrows": "to", "from": "pandas.Int8Dtype", "to": "pandas.Int8Dtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.Int8Dtype", "to": "pandas.Int8Dtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.Int8Dtype", "to": "pandas.Int8Dtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.Int8Dtype", "to": "pandas.Int8Dtype.from_numpy_dtype", "width": 1}, {"arrows": "to", "from": "pandas.Int8Dtype", "to": "pandas.Int8Dtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.Int8Dtype", "to": "pandas.Int8Dtype.type", "width": 1}, {"arrows": "to", "from": "pandas.IntervalDtype", "to": "pandas.IntervalDtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.IntervalDtype", "to": "pandas.IntervalDtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.IntervalDtype", "to": "pandas.IntervalDtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.IntervalDtype", "to": "pandas.IntervalDtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.IntervalDtype", "to": "pandas.IntervalDtype.reset_cache", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.all", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.any", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.append", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.argmax", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.argmin", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.argsort", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.asof", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.asof_locs", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.astype", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.contains", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.copy", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.delete", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.diff", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.difference", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.drop", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.drop_duplicates", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.droplevel", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.dropna", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.duplicated", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.equals", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.factorize", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.fillna", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.format", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.from_arrays", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.from_breaks", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.from_tuples", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.get_indexer", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.get_indexer_for", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.get_indexer_non_unique", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.get_level_values", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.get_loc", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.get_slice_bound", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.groupby", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.holds_integer", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.identical", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.infer_objects", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.insert", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.intersection", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.is_", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.is_boolean", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.is_categorical", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.is_floating", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.is_integer", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.is_interval", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.is_numeric", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.is_object", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.isin", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.isna", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.isnull", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.item", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.join", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.map", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.max", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.memory_usage", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.min", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.notna", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.notnull", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.nunique", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.overlaps", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.putmask", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.ravel", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.reindex", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.rename", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.repeat", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.round", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.searchsorted", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.set_closed", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.set_names", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.shift", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.slice_indexer", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.slice_locs", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.sort", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.sort_values", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.sortlevel", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.str", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.symmetric_difference", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.take", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.to_flat_index", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.to_frame", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.to_list", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.to_numpy", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.to_series", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.to_tuples", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.tolist", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.transpose", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.union", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.unique", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.value_counts", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.view", "width": 1}, {"arrows": "to", "from": "pandas.IntervalIndex", "to": "pandas.IntervalIndex.where", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.all", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.any", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.append", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.argmax", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.argmin", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.argsort", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.asof", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.asof_locs", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.astype", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.copy", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.delete", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.diff", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.difference", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.drop", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.drop_duplicates", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.droplevel", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.dropna", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.duplicated", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.equal_levels", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.equals", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.factorize", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.fillna", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.format", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.from_arrays", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.from_frame", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.from_product", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.from_tuples", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.get_indexer", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.get_indexer_for", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.get_indexer_non_unique", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.get_level_values", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.get_loc", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.get_loc_level", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.get_locs", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.get_slice_bound", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.groupby", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.holds_integer", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.identical", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.infer_objects", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.insert", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.intersection", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.is_", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.is_boolean", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.is_categorical", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.is_floating", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.is_integer", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.is_interval", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.is_numeric", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.is_object", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.isin", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.isna", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.isnull", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.item", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.join", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.map", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.max", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.memory_usage", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.min", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.notna", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.notnull", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.nunique", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.putmask", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.ravel", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.reindex", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.remove_unused_levels", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.rename", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.reorder_levels", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.repeat", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.round", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.searchsorted", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.set_codes", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.set_levels", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.set_names", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.shift", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.slice_indexer", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.slice_locs", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.sort", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.sort_values", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.sortlevel", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.str", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.swaplevel", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.symmetric_difference", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.take", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.to_flat_index", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.to_frame", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.to_list", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.to_numpy", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.to_series", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.tolist", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.transpose", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.truncate", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.union", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.unique", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.value_counts", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.view", "width": 1}, {"arrows": "to", "from": "pandas.MultiIndex", "to": "pandas.MultiIndex.where", "width": 1}, {"arrows": "to", "from": "pandas.Period", "to": "pandas.Period.now", "width": 1}, {"arrows": "to", "from": "pandas.PeriodDtype", "to": "pandas.PeriodDtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.PeriodDtype", "to": "pandas.PeriodDtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.PeriodDtype", "to": "pandas.PeriodDtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.PeriodDtype", "to": "pandas.PeriodDtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.PeriodDtype", "to": "pandas.PeriodDtype.reset_cache", "width": 1}, {"arrows": "to", "from": "pandas.PeriodDtype", "to": "pandas.PeriodDtype.type", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.all", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.any", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.append", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.argmax", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.argmin", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.argsort", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.asfreq", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.asof", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.asof_locs", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.astype", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.copy", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.delete", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.diff", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.difference", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.drop", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.drop_duplicates", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.droplevel", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.dropna", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.duplicated", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.equals", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.factorize", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.fillna", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.format", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.from_fields", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.from_ordinals", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.get_indexer", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.get_indexer_for", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.get_indexer_non_unique", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.get_level_values", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.get_loc", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.get_slice_bound", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.groupby", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.holds_integer", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.identical", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.infer_objects", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.insert", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.intersection", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.is_", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.is_boolean", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.is_categorical", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.is_floating", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.is_integer", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.is_interval", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.is_numeric", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.is_object", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.isin", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.isna", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.isnull", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.item", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.join", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.map", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.max", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.mean", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.memory_usage", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.min", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.notna", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.notnull", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.nunique", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.putmask", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.ravel", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.reindex", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.rename", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.repeat", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.round", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.searchsorted", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.set_names", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.shift", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.slice_indexer", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.slice_locs", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.sort", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.sort_values", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.sortlevel", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.str", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.strftime", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.symmetric_difference", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.take", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.to_flat_index", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.to_frame", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.to_list", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.to_numpy", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.to_series", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.to_timestamp", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.tolist", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.transpose", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.union", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.unique", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.value_counts", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.view", "width": 1}, {"arrows": "to", "from": "pandas.PeriodIndex", "to": "pandas.PeriodIndex.where", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.all", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.any", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.append", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.argmax", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.argmin", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.argsort", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.asof", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.asof_locs", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.astype", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.copy", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.delete", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.diff", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.difference", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.drop", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.drop_duplicates", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.droplevel", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.dropna", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.duplicated", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.equals", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.factorize", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.fillna", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.format", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.from_range", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.get_indexer", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.get_indexer_for", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.get_indexer_non_unique", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.get_level_values", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.get_loc", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.get_slice_bound", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.groupby", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.holds_integer", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.identical", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.infer_objects", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.insert", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.intersection", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.is_", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.is_boolean", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.is_categorical", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.is_floating", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.is_integer", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.is_interval", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.is_numeric", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.is_object", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.isin", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.isna", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.isnull", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.item", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.join", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.map", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.max", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.memory_usage", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.min", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.notna", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.notnull", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.nunique", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.putmask", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.ravel", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.reindex", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.rename", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.repeat", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.round", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.searchsorted", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.set_names", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.shift", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.slice_indexer", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.slice_locs", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.sort", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.sort_values", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.sortlevel", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.str", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.symmetric_difference", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.take", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.to_flat_index", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.to_frame", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.to_list", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.to_numpy", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.to_series", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.tolist", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.transpose", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.union", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.unique", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.value_counts", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.view", "width": 1}, {"arrows": "to", "from": "pandas.RangeIndex", "to": "pandas.RangeIndex.where", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.abs", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.add", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.add_prefix", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.add_suffix", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.agg", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.aggregate", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.align", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.all", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.any", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.apply", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.argmax", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.argmin", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.argsort", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.asfreq", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.asof", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.astype", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.at_time", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.autocorr", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.backfill", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.between", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.between_time", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.bfill", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.bool", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.case_when", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.cat", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.clip", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.combine", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.combine_first", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.compare", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.convert_dtypes", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.copy", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.corr", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.count", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.cov", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.cummax", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.cummin", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.cumprod", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.cumsum", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.describe", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.diff", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.div", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.divide", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.divmod", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.dot", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.drop", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.drop_duplicates", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.droplevel", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.dropna", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.dt", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.duplicated", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.eq", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.equals", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.ewm", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.expanding", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.explode", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.factorize", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.ffill", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.fillna", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.filter", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.first", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.first_valid_index", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.floordiv", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.ge", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.get", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.groupby", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.gt", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.head", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.hist", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.idxmax", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.idxmin", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.infer_objects", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.info", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.interpolate", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.isin", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.isna", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.isnull", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.item", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.items", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.keys", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.kurt", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.kurtosis", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.last", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.last_valid_index", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.le", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.list", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.lt", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.map", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.mask", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.max", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.mean", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.median", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.memory_usage", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.min", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.mod", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.mode", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.mul", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.multiply", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.ne", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.nlargest", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.notna", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.notnull", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.nsmallest", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.nunique", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.pad", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.pct_change", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.pipe", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.plot", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.pop", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.pow", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.prod", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.product", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.quantile", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.radd", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.rank", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.ravel", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.rdiv", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.rdivmod", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.reindex", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.reindex_like", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.rename", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.rename_axis", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.reorder_levels", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.repeat", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.replace", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.resample", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.reset_index", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.rfloordiv", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.rmod", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.rmul", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.rolling", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.round", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.rpow", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.rsub", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.rtruediv", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.sample", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.searchsorted", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.sem", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.set_axis", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.set_flags", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.shift", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.skew", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.sort_index", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.sort_values", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.sparse", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.squeeze", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.std", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.str", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.struct", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.sub", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.subtract", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.sum", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.swapaxes", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.swaplevel", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.tail", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.take", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.to_clipboard", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.to_csv", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.to_dict", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.to_excel", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.to_frame", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.to_hdf", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.to_json", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.to_latex", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.to_list", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.to_markdown", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.to_numpy", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.to_period", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.to_pickle", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.to_sql", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.to_string", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.to_timestamp", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.to_xarray", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.tolist", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.transform", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.transpose", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.truediv", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.truncate", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.tz_convert", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.tz_localize", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.unique", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.unstack", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.update", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.value_counts", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.var", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.view", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.where", "width": 1}, {"arrows": "to", "from": "pandas.Series", "to": "pandas.Series.xs", "width": 1}, {"arrows": "to", "from": "pandas.SparseDtype", "to": "pandas.SparseDtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.SparseDtype", "to": "pandas.SparseDtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.SparseDtype", "to": "pandas.SparseDtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.SparseDtype", "to": "pandas.SparseDtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.SparseDtype", "to": "pandas.SparseDtype.update_dtype", "width": 1}, {"arrows": "to", "from": "pandas.StringDtype", "to": "pandas.StringDtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.StringDtype", "to": "pandas.StringDtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.StringDtype", "to": "pandas.StringDtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.StringDtype", "to": "pandas.StringDtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.all", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.any", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.append", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.argmax", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.argmin", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.argsort", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.as_unit", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.asof", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.asof_locs", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.astype", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.ceil", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.copy", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.delete", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.diff", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.difference", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.drop", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.drop_duplicates", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.droplevel", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.dropna", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.duplicated", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.equals", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.factorize", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.fillna", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.floor", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.format", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.get_indexer", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.get_indexer_for", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.get_indexer_non_unique", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.get_level_values", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.get_loc", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.get_slice_bound", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.groupby", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.holds_integer", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.identical", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.infer_objects", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.insert", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.intersection", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.is_", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.is_boolean", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.is_categorical", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.is_floating", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.is_integer", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.is_interval", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.is_numeric", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.is_object", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.isin", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.isna", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.isnull", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.item", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.join", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.map", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.max", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.mean", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.median", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.memory_usage", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.min", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.notna", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.notnull", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.nunique", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.putmask", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.ravel", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.reindex", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.rename", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.repeat", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.round", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.searchsorted", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.set_names", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.shift", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.slice_indexer", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.slice_locs", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.sort", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.sort_values", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.sortlevel", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.std", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.str", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.sum", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.symmetric_difference", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.take", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.to_flat_index", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.to_frame", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.to_list", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.to_numpy", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.to_pytimedelta", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.to_series", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.tolist", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.total_seconds", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.transpose", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.union", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.unique", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.value_counts", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.view", "width": 1}, {"arrows": "to", "from": "pandas.TimedeltaIndex", "to": "pandas.TimedeltaIndex.where", "width": 1}, {"arrows": "to", "from": "pandas.UInt16Dtype", "to": "pandas.UInt16Dtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.UInt16Dtype", "to": "pandas.UInt16Dtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.UInt16Dtype", "to": "pandas.UInt16Dtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.UInt16Dtype", "to": "pandas.UInt16Dtype.from_numpy_dtype", "width": 1}, {"arrows": "to", "from": "pandas.UInt16Dtype", "to": "pandas.UInt16Dtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.UInt16Dtype", "to": "pandas.UInt16Dtype.type", "width": 1}, {"arrows": "to", "from": "pandas.UInt32Dtype", "to": "pandas.UInt32Dtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.UInt32Dtype", "to": "pandas.UInt32Dtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.UInt32Dtype", "to": "pandas.UInt32Dtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.UInt32Dtype", "to": "pandas.UInt32Dtype.from_numpy_dtype", "width": 1}, {"arrows": "to", "from": "pandas.UInt32Dtype", "to": "pandas.UInt32Dtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.UInt32Dtype", "to": "pandas.UInt32Dtype.type", "width": 1}, {"arrows": "to", "from": "pandas.UInt64Dtype", "to": "pandas.UInt64Dtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.UInt64Dtype", "to": "pandas.UInt64Dtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.UInt64Dtype", "to": "pandas.UInt64Dtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.UInt64Dtype", "to": "pandas.UInt64Dtype.from_numpy_dtype", "width": 1}, {"arrows": "to", "from": "pandas.UInt64Dtype", "to": "pandas.UInt64Dtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.UInt64Dtype", "to": "pandas.UInt64Dtype.type", "width": 1}, {"arrows": "to", "from": "pandas.UInt8Dtype", "to": "pandas.UInt8Dtype.construct_array_type", "width": 1}, {"arrows": "to", "from": "pandas.UInt8Dtype", "to": "pandas.UInt8Dtype.construct_from_string", "width": 1}, {"arrows": "to", "from": "pandas.UInt8Dtype", "to": "pandas.UInt8Dtype.empty", "width": 1}, {"arrows": "to", "from": "pandas.UInt8Dtype", "to": "pandas.UInt8Dtype.from_numpy_dtype", "width": 1}, {"arrows": "to", "from": "pandas.UInt8Dtype", "to": "pandas.UInt8Dtype.is_dtype", "width": 1}, {"arrows": "to", "from": "pandas.UInt8Dtype", "to": "pandas.UInt8Dtype.type", "width": 1}, {"arrows": "to", "from": "pandas.api", "to": "pandas.api.extensions", "width": 1}, {"arrows": "to", "from": "pandas.api", "to": "pandas.api.indexers", "width": 1}, {"arrows": "to", "from": "pandas.api", "to": "pandas.api.interchange", "width": 1}, {"arrows": "to", "from": "pandas.api", "to": "pandas.api.types", "width": 1}, {"arrows": "to", "from": "pandas.api", "to": "pandas.api.typing", "width": 1}, {"arrows": "to", "from": "pandas.arrays", "to": "pandas.arrays.ArrowExtensionArray", "width": 1}, {"arrows": "to", "from": "pandas.arrays", "to": "pandas.arrays.ArrowStringArray", "width": 1}, {"arrows": "to", "from": "pandas.arrays", "to": "pandas.arrays.BooleanArray", "width": 1}, {"arrows": "to", "from": "pandas.arrays", "to": "pandas.arrays.Categorical", "width": 1}, {"arrows": "to", "from": "pandas.arrays", "to": "pandas.arrays.DatetimeArray", "width": 1}, {"arrows": "to", "from": "pandas.arrays", "to": "pandas.arrays.FloatingArray", "width": 1}, {"arrows": "to", "from": "pandas.arrays", "to": "pandas.arrays.IntegerArray", "width": 1}, {"arrows": "to", "from": "pandas.arrays", "to": "pandas.arrays.IntervalArray", "width": 1}, {"arrows": "to", "from": "pandas.arrays", "to": "pandas.arrays.NumpyExtensionArray", "width": 1}, {"arrows": "to", "from": "pandas.arrays", "to": "pandas.arrays.PeriodArray", "width": 1}, {"arrows": "to", "from": "pandas.arrays", "to": "pandas.arrays.SparseArray", "width": 1}, {"arrows": "to", "from": "pandas.arrays", "to": "pandas.arrays.StringArray", "width": 1}, {"arrows": "to", "from": "pandas.arrays", "to": "pandas.arrays.TimedeltaArray", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.compressors", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.get_bz2_file", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.get_lzma_file", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.is_ci_environment", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.is_platform_arm", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.is_platform_linux", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.is_platform_little_endian", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.is_platform_mac", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.is_platform_power", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.is_platform_windows", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.numpy", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.os", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.pandas", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.pickle_compat", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.platform", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.pyarrow", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.set_function_name", "width": 1}, {"arrows": "to", "from": "pandas.compat", "to": "pandas.compat.sys", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.accessor", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.algorithms", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.api", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.apply", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.array_algos", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.arraylike", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.arrays", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.base", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.common", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.computation", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.config_init", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.construction", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.dtypes", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.flags", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.frame", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.generic", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.groupby", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.indexers", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.indexes", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.indexing", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.interchange", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.internals", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.methods", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.missing", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.nanops", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.ops", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.resample", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.reshape", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.roperator", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.sample", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.series", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.shared_docs", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.sorting", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.strings", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.tools", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.util", "width": 1}, {"arrows": "to", "from": "pandas.core", "to": "pandas.core.window", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.AbstractMethodError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.AttributeConflictWarning", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.CSSWarning", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.CategoricalConversionWarning", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.ChainedAssignmentError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.ClosedFileError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.DataError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.DatabaseError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.DtypeWarning", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.DuplicateLabelError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.EmptyDataError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.IncompatibilityWarning", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.IndexingError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.IntCastingNaNError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.InvalidColumnName", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.InvalidComparison", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.InvalidIndexError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.InvalidVersion", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.LossySetitemError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.MergeError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.NoBufferPresent", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.NullFrequencyError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.NumExprClobberingError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.NumbaUtilError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.OptionError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.OutOfBoundsDatetime", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.OutOfBoundsTimedelta", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.ParserError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.ParserWarning", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.PerformanceWarning", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.PossibleDataLossError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.PossiblePrecisionLoss", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.PyperclipException", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.PyperclipWindowsException", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.SettingWithCopyError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.SettingWithCopyWarning", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.SpecificationError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.UndefinedVariableError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.UnsortedIndexError", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.UnsupportedFunctionCall", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.ValueLabelTypeMismatch", "width": 1}, {"arrows": "to", "from": "pandas.errors", "to": "pandas.errors.ctypes", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.api", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.clipboards", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.common", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.excel", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.feather_format", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.formats", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.gbq", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.html", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.json", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.orc", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.parquet", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.parsers", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.pickle", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.pytables", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.sas", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.spss", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.sql", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.stata", "width": 1}, {"arrows": "to", "from": "pandas.io", "to": "pandas.io.xml", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.BDay", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.BMonthBegin", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.BMonthEnd", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.BQuarterBegin", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.BQuarterEnd", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.BYearBegin", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.BYearEnd", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.BaseOffset", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.BusinessDay", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.BusinessHour", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.BusinessMonthBegin", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.BusinessMonthEnd", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.CBMonthBegin", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.CBMonthEnd", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.CDay", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.CustomBusinessDay", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.CustomBusinessHour", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.CustomBusinessMonthBegin", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.CustomBusinessMonthEnd", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.DateOffset", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.Day", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.Easter", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.FY5253", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.FY5253Quarter", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.Hour", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.LastWeekOfMonth", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.Micro", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.Milli", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.Minute", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.MonthBegin", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.MonthEnd", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.Nano", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.QuarterBegin", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.QuarterEnd", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.Second", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.SemiMonthBegin", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.SemiMonthEnd", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.Tick", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.Week", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.WeekOfMonth", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.YearBegin", "width": 1}, {"arrows": "to", "from": "pandas.offsets", "to": "pandas.offsets.YearEnd", "width": 1}, {"arrows": "to", "from": "pandas.plotting", "to": "pandas.plotting.PlotAccessor", "width": 1}, {"arrows": "to", "from": "pandas.plotting", "to": "pandas.plotting.andrews_curves", "width": 1}, {"arrows": "to", "from": "pandas.plotting", "to": "pandas.plotting.autocorrelation_plot", "width": 1}, {"arrows": "to", "from": "pandas.plotting", "to": "pandas.plotting.bootstrap_plot", "width": 1}, {"arrows": "to", "from": "pandas.plotting", "to": "pandas.plotting.boxplot", "width": 1}, {"arrows": "to", "from": "pandas.plotting", "to": "pandas.plotting.boxplot_frame", "width": 1}, {"arrows": "to", "from": "pandas.plotting", "to": "pandas.plotting.boxplot_frame_groupby", "width": 1}, {"arrows": "to", "from": "pandas.plotting", "to": "pandas.plotting.deregister_matplotlib_converters", "width": 1}, {"arrows": "to", "from": "pandas.plotting", "to": "pandas.plotting.hist_frame", "width": 1}, {"arrows": "to", "from": "pandas.plotting", "to": "pandas.plotting.hist_series", "width": 1}, {"arrows": "to", "from": "pandas.plotting", "to": "pandas.plotting.lag_plot", "width": 1}, {"arrows": "to", "from": "pandas.plotting", "to": "pandas.plotting.parallel_coordinates", "width": 1}, {"arrows": "to", "from": "pandas.plotting", "to": "pandas.plotting.radviz", "width": 1}, {"arrows": "to", "from": "pandas.plotting", "to": "pandas.plotting.register_matplotlib_converters", "width": 1}, {"arrows": "to", "from": "pandas.plotting", "to": "pandas.plotting.scatter_matrix", "width": 1}, {"arrows": "to", "from": "pandas.plotting", "to": "pandas.plotting.table", "width": 1}, {"arrows": "to", "from": "pandas.testing", "to": "pandas.testing.assert_extension_array_equal", "width": 1}, {"arrows": "to", "from": "pandas.testing", "to": "pandas.testing.assert_frame_equal", "width": 1}, {"arrows": "to", "from": "pandas.testing", "to": "pandas.testing.assert_index_equal", "width": 1}, {"arrows": "to", "from": "pandas.testing", "to": "pandas.testing.assert_series_equal", "width": 1}, {"arrows": "to", "from": "pandas.tseries", "to": "pandas.tseries.api", "width": 1}, {"arrows": "to", "from": "pandas.tseries", "to": "pandas.tseries.frequencies", "width": 1}, {"arrows": "to", "from": "pandas.tseries", "to": "pandas.tseries.offsets", "width": 1}, {"arrows": "to", "from": "pandas.util", "to": "pandas.util.capitalize_first_letter", "width": 1}, {"arrows": "to", "from": "pandas.util", "to": "pandas.util.version", "width": 1}]);

                  nodeColors = {};
                  allNodes = nodes.get({ returnType: "Object" });
                  for (nodeId in allNodes) {
                    nodeColors[nodeId] = allNodes[nodeId].color;
                  }
                  allEdges = edges.get({ returnType: "Object" });
                  // adding nodes and edges to the graph
                  data = {nodes: nodes, edges: edges};

                  var options = {"physics": {"enabled": true, "repulsion": {"nodeDistance": 200, "centralGravity": 0.15}, "solver": "repulsion", "stabilization": {"enabled": true, "iterations": 1000}}, "interaction": {"hover": true, "tooltipDelay": 200}};

                  


                  

                  network = new vis.Network(container, data, options);

                  

                  

                  


                  
                      network.on("stabilizationProgress", function(params) {
                          document.getElementById('loadingBar').removeAttribute("style");
                          var maxWidth = 496;
                          var minWidth = 20;
                          var widthFactor = params.iterations/params.total;
                          var width = Math.max(minWidth,maxWidth * widthFactor);
                          document.getElementById('bar').style.width = width + 'px';
                          document.getElementById('text').innerHTML = Math.round(widthFactor*100) + '%';
                      });
                      network.once("stabilizationIterationsDone", function() {
                          document.getElementById('text').innerHTML = '100%';
                          document.getElementById('bar').style.width = '496px';
                          document.getElementById('loadingBar').style.opacity = 0;
                          // really clean the dom element
                          setTimeout(function () {document.getElementById('loadingBar').style.display = 'none';}, 500);
                      });
                  

                  return network;

              }
              drawGraph();
        </script>
    </body>
</html>